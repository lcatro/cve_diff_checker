From 702ab4746dcdfb760f1d6f9dacb472961e1f9c96 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Thu, 9 Sep 2021 00:34:47 -0400
Subject: [PATCH 01/25] Demonstrate blaze-server response-splitting attacks

---
 .../server/blaze/Http1ServerStageSpec.scala   | 44 +++++++++++++++++++
 1 file changed, 44 insertions(+)

diff --git a/blaze-server/src/test/scala/org/http4s/server/blaze/Http1ServerStageSpec.scala b/blaze-server/src/test/scala/org/http4s/server/blaze/Http1ServerStageSpec.scala
index e902325d8a0..218825023bd 100644
--- a/blaze-server/src/test/scala/org/http4s/server/blaze/Http1ServerStageSpec.scala
+++ b/blaze-server/src/test/scala/org/http4s/server/blaze/Http1ServerStageSpec.scala
@@ -521,4 +521,48 @@ class Http1ServerStageSpec extends Http4sSuite {
       assert(head.closeCauses == Seq(None))
     }
   }
+
+  tickWheel.test("Prevent response splitting attacks on status reason phrase") { tw =>
+    val rawReq = "GET /?reason=%0D%0AEvil:true%0D%0A HTTP/1.0\r\n\r\n"
+    val head = runRequest(
+      tw,
+      List(rawReq),
+      HttpApp { req =>
+        Response[IO](Status.NoContent.withReason(req.params("reason"))).pure[IO]
+      })
+    head.result.map { buff =>
+      val (_, headers, _) = ResponseParser.parseBuffer(buff)
+      assertEquals(headers.find(_.name === "Evil".ci), None)
+    }
+  }
+
+  tickWheel.test("Prevent response splitting attacks on field name") { tw =>
+    val rawReq = "GET /?fieldName=Fine:%0D%0AEvil:true%0D%0A HTTP/1.0\r\n\r\n"
+    val head = runRequest(
+      tw,
+      List(rawReq),
+      HttpApp { req =>
+        Response[IO](Status.NoContent).putHeaders(Header(req.params("fieldName"), "oops")).pure[IO]
+      })
+    head.result.map { buff =>
+      val (_, headers, _) = ResponseParser.parseBuffer(buff)
+      assertEquals(headers.find(_.name === "Evil".ci), None)
+    }
+  }
+
+  tickWheel.test("Prevent response splitting attacks on field value") { tw =>
+    val rawReq = "GET /?fieldValue=%0D%0AEvil:true%0D%0A HTTP/1.0\r\n\r\n"
+    val head = runRequest(
+      tw,
+      List(rawReq),
+      HttpApp { req =>
+        Response[IO](Status.NoContent)
+          .putHeaders(Header("X-Oops", req.params("fieldValue")))
+          .pure[IO]
+      })
+    head.result.map { buff =>
+      val (_, headers, _) = ResponseParser.parseBuffer(buff)
+      assertEquals(headers.find(_.name === "Evil".ci), None)
+    }
+  }
 }

From f99ddc6c88105765c1e61178b21f988435d982a1 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Thu, 9 Sep 2021 16:31:50 -0400
Subject: [PATCH 02/25] Demonstrate ember-core response-splitting attacks

---
 .../ember/core/ResponseSplittingSuite.scala   | 64 +++++++++++++++++++
 1 file changed, 64 insertions(+)
 create mode 100644 ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala

diff --git a/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala b/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala
new file mode 100644
index 00000000000..f72efdf0f57
--- /dev/null
+++ b/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2019 http4s.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.http4s
+package ember.core
+
+import cats.effect.{Concurrent, IO}
+import cats.implicits._
+import org.http4s.implicits._
+
+class ResponseSplittingSuite extends Http4sSuite {
+  def attack[F[_]](app: HttpApp[F], req: Request[F])(implicit F: Concurrent[F]): F[Response[F]] =
+    for {
+      resp <- app(req)
+      respBytes <- Encoder
+        .respToBytes(resp)
+        .compile
+        .to(Array)
+      result <- Parser.Response.parser[F](1024)(respBytes, F.pure(None))
+    } yield (result._1)
+
+  test("Prevent response splitting attacks on status reason phrase") {
+    val app = HttpApp[IO] { req =>
+      Response(Status.NoContent.withReason(req.params("reason"))).pure[IO]
+    }
+    val req = Request[IO](uri = uri"/?reason=%0D%0AEvil:true%0D%0A")
+    attack(app, req).map { resp =>
+      assertEquals(resp.headers.find(_.name === "Evil".ci), None)
+    }
+  }
+
+  test("Prevent response splitting attacks on field name") {
+    val app = HttpApp[IO] { req =>
+      Response(Status.NoContent).putHeaders(Header(req.params("fieldName"), "oops")).pure[IO]
+    }
+    val req = Request[IO](uri = uri"/?fieldName=Fine:%0D%0AEvil:true%0D%0A")
+    attack(app, req).map { resp =>
+      assertEquals(resp.headers.find(_.name === "Evil".ci), None)
+    }
+  }
+
+  test("Prevent response splitting attacks on field value") {
+    val app = HttpApp[IO] { req =>
+      Response(Status.NoContent).putHeaders(Header(req.params("fieldName"), "oops")).pure[IO]
+    }
+    val req = Request[IO](uri = uri"/?fieldValue=%0D%0AEvil:true%0D%0A")
+    attack(app, req).map { resp =>
+      assertEquals(resp.headers.find(_.name === "Evil".ci), None)
+    }
+  }
+}

From 4cb7101e0920a37cc906aeb19e1ce416266d7811 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Thu, 9 Sep 2021 23:48:02 -0400
Subject: [PATCH 03/25] Sanitize status reasons

---
 .../server/blaze/Http1ServerStage.scala       |   2 +-
 core/src/main/scala/org/http4s/Status.scala   | 158 ++++++++++--------
 .../laws/discipline/ArbitraryInstances.scala  |  27 ++-
 .../test/scala/org/http4s/StatusSpec.scala    |  15 ++
 4 files changed, 130 insertions(+), 72 deletions(-)

diff --git a/blaze-server/src/main/scala/org/http4s/server/blaze/Http1ServerStage.scala b/blaze-server/src/main/scala/org/http4s/server/blaze/Http1ServerStage.scala
index 05f56970010..97d3628609e 100644
--- a/blaze-server/src/main/scala/org/http4s/server/blaze/Http1ServerStage.scala
+++ b/blaze-server/src/main/scala/org/http4s/server/blaze/Http1ServerStage.scala
@@ -224,7 +224,7 @@ private[blaze] class Http1ServerStage[F[_]](
       resp: Response[F],
       bodyCleanup: () => Future[ByteBuffer]): Unit = {
     val rr = new StringWriter(512)
-    rr << req.httpVersion << ' ' << resp.status.code << ' ' << resp.status.reason << "\r\n"
+    rr << req.httpVersion << ' ' << resp.status << "\r\n"
 
     Http1Stage.encodeHeaders(resp.headers.toList, rr, isServer = true)
 
diff --git a/core/src/main/scala/org/http4s/Status.scala b/core/src/main/scala/org/http4s/Status.scala
index ede76fa0c3d..9e41b095e8e 100644
--- a/core/src/main/scala/org/http4s/Status.scala
+++ b/core/src/main/scala/org/http4s/Status.scala
@@ -18,6 +18,7 @@ package org.http4s
 
 import cats.{Order, Show}
 import org.http4s.Status.ResponseClass
+import org.http4s.internal.parboiled2.CharPredicate
 import org.http4s.util.Renderable
 
 /** Representation of the HTTP response code and reason
@@ -48,7 +49,13 @@ sealed abstract case class Status private (code: Int)(
 
   def withReason(reason: String): Status = Status(code, reason, isEntityAllowed)
 
-  override def render(writer: org.http4s.util.Writer): writer.type = writer << code << ' ' << reason
+  /** A sanitized [[reason]] phrase. Blank if reason is invalid per
+    * RFC7230, otherwise equivalent to reason.
+    */
+  def sanitizedReason: String = ""
+
+  override def render(writer: org.http4s.util.Writer): writer.type =
+    writer << code << ' ' << sanitizedReason
 
   /** Helpers for for matching against a [[Response]] */
   def unapply[F[_]](msg: Response[F]): Option[Response[F]] =
@@ -58,8 +65,23 @@ sealed abstract case class Status private (code: Int)(
 object Status {
   import Registry._
 
+  private val ReasonPhrasePredicate =
+    CharPredicate("\t ") ++ CharPredicate(0x21.toChar to 0x7e.toChar) ++ CharPredicate(
+      0x80.toChar to Char.MaxValue)
+
   def apply(code: Int, reason: String = "", isEntityAllowed: Boolean = true): Status =
-    new Status(code)(reason, isEntityAllowed) {}
+    new Status(code)(reason, isEntityAllowed) {
+      override lazy val sanitizedReason =
+        if (reason.forall(ReasonPhrasePredicate))
+          reason
+        else
+          ""
+    }
+
+  private def trust(code: Int, reason: String, isEntityAllowed: Boolean = true): Status =
+    new Status(code)(reason, isEntityAllowed) {
+      override val sanitizedReason = reason
+    }
 
   sealed trait ResponseClass {
     def isSuccess: Boolean
@@ -98,7 +120,7 @@ object Status {
     withRangeCheck(code) {
       lookup(code) match {
         case right: Right[_, _] => right
-        case _ => ParseResult.success(Status(code, ""))
+        case _ => ParseResult.success(trust(code, ""))
       }
     }
 
@@ -143,73 +165,73 @@ object Status {
   /** Status code list taken from http://www.iana.org/assignments/http-status-codes/http-status-codes.xml
     */
   // scalastyle:off magic.number
-  val Continue: Status = register(Status(100, "Continue", isEntityAllowed = false))
+  val Continue: Status = register(trust(100, "Continue", isEntityAllowed = false))
   val SwitchingProtocols: Status = register(
-    Status(101, "Switching Protocols", isEntityAllowed = false))
-  val Processing: Status = register(Status(102, "Processing", isEntityAllowed = false))
-  val EarlyHints: Status = register(Status(103, "Early Hints", isEntityAllowed = false))
-
-  val Ok: Status = register(Status(200, "OK"))
-  val Created: Status = register(Status(201, "Created"))
-  val Accepted: Status = register(Status(202, "Accepted"))
-  val NonAuthoritativeInformation: Status = register(Status(203, "Non-Authoritative Information"))
-  val NoContent: Status = register(Status(204, "No Content", isEntityAllowed = false))
-  val ResetContent: Status = register(Status(205, "Reset Content", isEntityAllowed = false))
-  val PartialContent: Status = register(Status(206, "Partial Content"))
-  val MultiStatus: Status = register(Status(207, "Multi-Status"))
-  val AlreadyReported: Status = register(Status(208, "Already Reported"))
-  val IMUsed: Status = register(Status(226, "IM Used"))
-
-  val MultipleChoices: Status = register(Status(300, "Multiple Choices"))
-  val MovedPermanently: Status = register(Status(301, "Moved Permanently"))
-  val Found: Status = register(Status(302, "Found"))
-  val SeeOther: Status = register(Status(303, "See Other"))
-  val NotModified: Status = register(Status(304, "Not Modified", isEntityAllowed = false))
-  val UseProxy: Status = register(Status(305, "Use Proxy"))
-  val TemporaryRedirect: Status = register(Status(307, "Temporary Redirect"))
-  val PermanentRedirect: Status = register(Status(308, "Permanent Redirect"))
-
-  val BadRequest: Status = register(Status(400, "Bad Request"))
-  val Unauthorized: Status = register(Status(401, "Unauthorized"))
-  val PaymentRequired: Status = register(Status(402, "Payment Required"))
-  val Forbidden: Status = register(Status(403, "Forbidden"))
-  val NotFound: Status = register(Status(404, "Not Found"))
-  val MethodNotAllowed: Status = register(Status(405, "Method Not Allowed"))
-  val NotAcceptable: Status = register(Status(406, "Not Acceptable"))
-  val ProxyAuthenticationRequired: Status = register(Status(407, "Proxy Authentication Required"))
-  val RequestTimeout: Status = register(Status(408, "Request Timeout"))
-  val Conflict: Status = register(Status(409, "Conflict"))
-  val Gone: Status = register(Status(410, "Gone"))
-  val LengthRequired: Status = register(Status(411, "Length Required"))
-  val PreconditionFailed: Status = register(Status(412, "Precondition Failed"))
-  val PayloadTooLarge: Status = register(Status(413, "Payload Too Large"))
-  val UriTooLong: Status = register(Status(414, "URI Too Long"))
-  val UnsupportedMediaType: Status = register(Status(415, "Unsupported Media Type"))
-  val RangeNotSatisfiable: Status = register(Status(416, "Range Not Satisfiable"))
-  val ExpectationFailed: Status = register(Status(417, "Expectation Failed"))
-  val MisdirectedRequest: Status = register(Status(421, "Misdirected Request"))
-  val UnprocessableEntity: Status = register(Status(422, "Unprocessable Entity"))
-  val Locked: Status = register(Status(423, "Locked"))
-  val FailedDependency: Status = register(Status(424, "Failed Dependency"))
-  val TooEarly: Status = register(Status(425, "Too Early"))
-  val UpgradeRequired: Status = register(Status(426, "Upgrade Required"))
-  val PreconditionRequired: Status = register(Status(428, "Precondition Required"))
-  val TooManyRequests: Status = register(Status(429, "Too Many Requests"))
-  val RequestHeaderFieldsTooLarge: Status = register(Status(431, "Request Header Fields Too Large"))
-  val UnavailableForLegalReasons: Status = register(Status(451, "Unavailable For Legal Reasons"))
-
-  val InternalServerError: Status = register(Status(500, "Internal Server Error"))
-  val NotImplemented: Status = register(Status(501, "Not Implemented"))
-  val BadGateway: Status = register(Status(502, "Bad Gateway"))
-  val ServiceUnavailable: Status = register(Status(503, "Service Unavailable"))
-  val GatewayTimeout: Status = register(Status(504, "Gateway Timeout"))
-  val HttpVersionNotSupported: Status = register(Status(505, "HTTP Version not supported"))
-  val VariantAlsoNegotiates: Status = register(Status(506, "Variant Also Negotiates"))
-  val InsufficientStorage: Status = register(Status(507, "Insufficient Storage"))
-  val LoopDetected: Status = register(Status(508, "Loop Detected"))
-  val NotExtended: Status = register(Status(510, "Not Extended"))
+    trust(101, "Switching Protocols", isEntityAllowed = false))
+  val Processing: Status = register(trust(102, "Processing", isEntityAllowed = false))
+  val EarlyHints: Status = register(trust(103, "Early Hints", isEntityAllowed = false))
+
+  val Ok: Status = register(trust(200, "OK"))
+  val Created: Status = register(trust(201, "Created"))
+  val Accepted: Status = register(trust(202, "Accepted"))
+  val NonAuthoritativeInformation: Status = register(trust(203, "Non-Authoritative Information"))
+  val NoContent: Status = register(trust(204, "No Content", isEntityAllowed = false))
+  val ResetContent: Status = register(trust(205, "Reset Content", isEntityAllowed = false))
+  val PartialContent: Status = register(trust(206, "Partial Content"))
+  val MultiStatus: Status = register(trust(207, "Multi-Status"))
+  val AlreadyReported: Status = register(trust(208, "Already Reported"))
+  val IMUsed: Status = register(trust(226, "IM Used"))
+
+  val MultipleChoices: Status = register(trust(300, "Multiple Choices"))
+  val MovedPermanently: Status = register(trust(301, "Moved Permanently"))
+  val Found: Status = register(trust(302, "Found"))
+  val SeeOther: Status = register(trust(303, "See Other"))
+  val NotModified: Status = register(trust(304, "Not Modified", isEntityAllowed = false))
+  val UseProxy: Status = register(trust(305, "Use Proxy"))
+  val TemporaryRedirect: Status = register(trust(307, "Temporary Redirect"))
+  val PermanentRedirect: Status = register(trust(308, "Permanent Redirect"))
+
+  val BadRequest: Status = register(trust(400, "Bad Request"))
+  val Unauthorized: Status = register(trust(401, "Unauthorized"))
+  val PaymentRequired: Status = register(trust(402, "Payment Required"))
+  val Forbidden: Status = register(trust(403, "Forbidden"))
+  val NotFound: Status = register(trust(404, "Not Found"))
+  val MethodNotAllowed: Status = register(trust(405, "Method Not Allowed"))
+  val NotAcceptable: Status = register(trust(406, "Not Acceptable"))
+  val ProxyAuthenticationRequired: Status = register(trust(407, "Proxy Authentication Required"))
+  val RequestTimeout: Status = register(trust(408, "Request Timeout"))
+  val Conflict: Status = register(trust(409, "Conflict"))
+  val Gone: Status = register(trust(410, "Gone"))
+  val LengthRequired: Status = register(trust(411, "Length Required"))
+  val PreconditionFailed: Status = register(trust(412, "Precondition Failed"))
+  val PayloadTooLarge: Status = register(trust(413, "Payload Too Large"))
+  val UriTooLong: Status = register(trust(414, "URI Too Long"))
+  val UnsupportedMediaType: Status = register(trust(415, "Unsupported Media Type"))
+  val RangeNotSatisfiable: Status = register(trust(416, "Range Not Satisfiable"))
+  val ExpectationFailed: Status = register(trust(417, "Expectation Failed"))
+  val MisdirectedRequest: Status = register(trust(421, "Misdirected Request"))
+  val UnprocessableEntity: Status = register(trust(422, "Unprocessable Entity"))
+  val Locked: Status = register(trust(423, "Locked"))
+  val FailedDependency: Status = register(trust(424, "Failed Dependency"))
+  val TooEarly: Status = register(trust(425, "Too Early"))
+  val UpgradeRequired: Status = register(trust(426, "Upgrade Required"))
+  val PreconditionRequired: Status = register(trust(428, "Precondition Required"))
+  val TooManyRequests: Status = register(trust(429, "Too Many Requests"))
+  val RequestHeaderFieldsTooLarge: Status = register(trust(431, "Request Header Fields Too Large"))
+  val UnavailableForLegalReasons: Status = register(trust(451, "Unavailable For Legal Reasons"))
+
+  val InternalServerError: Status = register(trust(500, "Internal Server Error"))
+  val NotImplemented: Status = register(trust(501, "Not Implemented"))
+  val BadGateway: Status = register(trust(502, "Bad Gateway"))
+  val ServiceUnavailable: Status = register(trust(503, "Service Unavailable"))
+  val GatewayTimeout: Status = register(trust(504, "Gateway Timeout"))
+  val HttpVersionNotSupported: Status = register(trust(505, "HTTP Version not supported"))
+  val VariantAlsoNegotiates: Status = register(trust(506, "Variant Also Negotiates"))
+  val InsufficientStorage: Status = register(trust(507, "Insufficient Storage"))
+  val LoopDetected: Status = register(trust(508, "Loop Detected"))
+  val NotExtended: Status = register(trust(510, "Not Extended"))
   val NetworkAuthenticationRequired: Status = register(
-    Status(511, "Network Authentication Required"))
+    trust(511, "Network Authentication Required"))
   // scalastyle:on magic.number
 
   implicit val http4sOrderForStatus: Order[Status] = Order.fromOrdering[Status]
diff --git a/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala b/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
index 87bfa5e7bb7..be303b0268f 100644
--- a/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
+++ b/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
@@ -44,6 +44,8 @@ import scala.concurrent.Future
 import scala.util.Try
 
 private[http4s] trait ArbitraryInstances {
+  import ArbitraryInstances._
+
   private implicit class ParseResultSyntax[A](self: ParseResult[A]) {
     def yolo: A = self.valueOr(e => sys.error(e.toString))
   }
@@ -145,12 +147,12 @@ private[http4s] trait ArbitraryInstances {
 
   val genCustomStatus = for {
     code <- genValidStatusCode
-    reason <- getArbitrary[String]
-  } yield Status.fromIntAndReason(code, reason).yolo
+    reason <- genCustomStatusReason
+  } yield Status.fromInt(code).yolo.withReason(reason)
 
   implicit val http4sTestingArbitraryForStatus: Arbitrary[Status] = Arbitrary(
     frequency(
-      10 -> genStandardStatus,
+      4 -> genStandardStatus,
       1 -> genCustomStatus
     ))
   implicit val http4sTestingCogenForStatus: Cogen[Status] =
@@ -917,4 +919,23 @@ object ArbitraryInstances extends ArbitraryInstances {
     Cogen
       .tuple3[Option[Uri.UserInfo], Uri.Host, Option[Int]]
       .contramap(a => (a.userInfo, a.host, a.port))
+
+  val genCustomStatusReason: Gen[String] = {
+    val word = poisson(5).flatMap(stringOfN(_, alphaChar))
+    val normal = poisson(3).flatMap(listOfN(_, word)).map(_.mkString(" "))
+    val exotic = stringOf(
+      frequency(
+        1 -> '\t',
+        1 -> const(' '),
+        94 -> asciiPrintableChar
+      ))
+    val unsanitizedAscii = asciiStr
+    val unsanitized = getArbitrary[String]
+    oneOf(
+      normal,
+      exotic,
+      unsanitizedAscii,
+      unsanitized
+    )
+  }
 }
diff --git a/tests/src/test/scala/org/http4s/StatusSpec.scala b/tests/src/test/scala/org/http4s/StatusSpec.scala
index 4873a8e05d8..99fe47f0713 100644
--- a/tests/src/test/scala/org/http4s/StatusSpec.scala
+++ b/tests/src/test/scala/org/http4s/StatusSpec.scala
@@ -18,6 +18,7 @@ package org.http4s
 
 import org.http4s.laws.discipline.arbitrary._
 import cats.kernel.laws.discipline.OrderTests
+import java.nio.charset.StandardCharsets
 import org.http4s.Status._
 import org.scalacheck.Gen
 import org.scalacheck.Prop.{forAll, propBoolean}
@@ -114,6 +115,20 @@ class StatusSpec extends Http4sSuite {
     assertEquals(getStatus(NotFound.code, "Not Found").reason, "Not Found")
   }
 
+  test("all known status have a reason") {
+    Status.registered.foreach { status =>
+      assert(status.renderString.drop(4).nonEmpty, status.renderString)
+    }
+  }
+
+  test("rendering sanitizes statuses") {
+    forAll { (s: Status) =>
+      s.renderString
+        .getBytes(StandardCharsets.ISO_8859_1)
+        .forall(b => b == ' ' || b == '\t' || (b >= 0x21 && b <= 0x7e) || ((b & 0xff) > 0x80))
+    }
+  }
+
   private def getStatus(code: Int) =
     fromInt(code) match {
       case Right(s) => s

From 97f8ede138bd1ff1e189a76fd1c2d18fa085696b Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 10 Sep 2021 00:01:00 -0400
Subject: [PATCH 04/25] Drop headers with invalid names

---
 .../main/scala/org/http4s/blazecore/Http1Stage.scala | 10 ++++++----
 core/src/main/scala/org/http4s/Header.scala          | 12 ++++++++++++
 .../main/scala/org/http4s/ember/core/Encoder.scala   | 10 ++++++----
 .../http4s/laws/discipline/ArbitraryInstances.scala  |  2 +-
 tests/src/test/scala/org/http4s/HeaderSuite.scala    | 10 +++++++++-
 5 files changed, 34 insertions(+), 10 deletions(-)

diff --git a/blaze-core/src/main/scala/org/http4s/blazecore/Http1Stage.scala b/blaze-core/src/main/scala/org/http4s/blazecore/Http1Stage.scala
index 82fa25bea86..d2a2d0eb054 100644
--- a/blaze-core/src/main/scala/org/http4s/blazecore/Http1Stage.scala
+++ b/blaze-core/src/main/scala/org/http4s/blazecore/Http1Stage.scala
@@ -329,16 +329,18 @@ object Http1Stage {
       Future.successful(buffer)
     } else CachedEmptyBufferThunk
 
-  /** Encodes the headers into the Writer. Does not encode `Transfer-Encoding` or
-    * `Content-Length` headers, which are left for the body encoder. Adds
-    * `Date` header if one is missing and this is a server response.
+  /** Encodes the headers into the Writer. Does not encode
+    * `Transfer-Encoding` or `Content-Length` headers, which are left
+    * for the body encoder. Does not encode headers with invalid
+    * names. Adds `Date` header if one is missing and this is a server
+    * response.
     *
     * Note: this method is very niche but useful for both server and client.
     */
   def encodeHeaders(headers: Iterable[Header], rr: Writer, isServer: Boolean): Unit = {
     var dateEncoded = false
     headers.foreach { h =>
-      if (h.name != `Transfer-Encoding`.name && h.name != `Content-Length`.name) {
+      if (h.name != `Transfer-Encoding`.name && h.name != `Content-Length`.name && h.isNameValid) {
         if (isServer && h.name == Date.name) dateEncoded = true
         rr << h << "\r\n"
       }
diff --git a/core/src/main/scala/org/http4s/Header.scala b/core/src/main/scala/org/http4s/Header.scala
index 281bc21f448..3f743dc8aec 100644
--- a/core/src/main/scala/org/http4s/Header.scala
+++ b/core/src/main/scala/org/http4s/Header.scala
@@ -13,6 +13,7 @@ package org.http4s
 import cats.{Eq, Order, Show}
 import cats.data.NonEmptyList
 import cats.syntax.all._
+import org.http4s.internal.parboiled2.CharPredicate
 import org.http4s.syntax.string._
 import org.http4s.util._
 import scala.util.hashing.MurmurHash3
@@ -25,6 +26,11 @@ sealed trait Header extends Renderable with Product {
 
   def name: CaseInsensitiveString
 
+  /** True if [[name]] is a valid field-name per RFC7230.  Where it
+    * is not, the header may be dropped by the backend.
+    */
+  def isNameValid: Boolean = true
+
   def parsed: Header
 
   def renderValue(writer: Writer): writer.type
@@ -71,6 +77,9 @@ object Header {
 
   def apply(name: String, value: String): Raw = Raw(name.ci, value)
 
+  private val FieldNamePredicate =
+    CharPredicate("!#$%&'*+-.^_`|~`") ++ CharPredicate.AlphaNum
+
   /** Raw representation of the Header
     *
     * This can be considered the simplest representation where the header is specified as the product of
@@ -86,6 +95,9 @@ object Header {
       _parsed
     }
     override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+    override lazy val isNameValid: Boolean =
+      name.toString.nonEmpty && name.toString.forall(FieldNamePredicate)
   }
 
   /** A Header that is already parsed from its String representation. */
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
index a729974c8ff..c6cf0abd12f 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
@@ -51,10 +51,12 @@ private[ember] object Encoder {
         if (h.is(`Content-Length`)) appliedContentLength = true
         else ()
 
-        stringBuilder
-          .append(h.renderString)
-          .append(CRLF)
-        ()
+        if (h.isNameValid) {
+          stringBuilder
+            .append(h.renderString)
+            .append(CRLF)
+          ()
+        }
       }
       if (!chunked && !appliedContentLength && resp.status.isEntityAllowed) {
         stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)
diff --git a/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala b/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
index be303b0268f..b44fa7695f2 100644
--- a/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
+++ b/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
@@ -539,7 +539,7 @@ private[http4s] trait ArbitraryInstances {
   implicit val http4sTestingArbitraryForRawHeader: Arbitrary[Header.Raw] =
     Arbitrary {
       for {
-        token <- genToken
+        token <- frequency(8 -> genToken, 1 -> asciiStr, 1 -> getArbitrary[String])
         value <- genFieldValue
       } yield Header.Raw(token.ci, value)
     }
diff --git a/tests/src/test/scala/org/http4s/HeaderSuite.scala b/tests/src/test/scala/org/http4s/HeaderSuite.scala
index 3cbdbda3338..d7b02a7943d 100644
--- a/tests/src/test/scala/org/http4s/HeaderSuite.scala
+++ b/tests/src/test/scala/org/http4s/HeaderSuite.scala
@@ -19,8 +19,8 @@ package org.http4s
 import cats.kernel.laws.discipline.OrderTests
 import java.nio.charset.StandardCharsets.ISO_8859_1
 import org.http4s.headers._
-import org.http4s.util.StringWriter
 import org.http4s.laws.discipline.ArbitraryInstances._
+import org.http4s.util.StringWriter
 import org.scalacheck.Prop._
 
 class HeaderSuite extends munit.DisciplineSuite {
@@ -93,4 +93,12 @@ class HeaderSuite extends munit.DisciplineSuite {
   test("Order instance for Header should be lawful") {
     checkAll("Order[Header]", OrderTests[Header].order)
   }
+
+  test("isNameValid") {
+    forAll { (h: Header) =>
+      val tchar =
+        Set(0x21.toChar to 0x7e.toChar: _*).diff(Set("\"(),/:;<=>?@[\\]{}": _*)).map(_.toByte)
+      assertEquals(h.isNameValid, h.name.toString.getBytes(ISO_8859_1).forall(tchar), h.name)
+    }
+  }
 }

From 8507ea2004f84e5f56952d674331e3ad53073624 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 10 Sep 2021 17:59:23 -0400
Subject: [PATCH 05/25] Sanitize header values with 0x0, '\r', and '\n'

---
 core/src/main/scala/org/http4s/Header.scala   |  6 ++-
 .../scala/org/http4s/internal/package.scala   | 22 +++++++++
 .../scala/org/http4s/headers/HeaderLaws.scala | 13 +++++
 .../org/http4s/internal/SanitizeSpec.scala    | 49 +++++++++++++++++++
 4 files changed, 89 insertions(+), 1 deletion(-)
 create mode 100644 tests/src/test/scala/org/http4s/internal/SanitizeSpec.scala

diff --git a/core/src/main/scala/org/http4s/Header.scala b/core/src/main/scala/org/http4s/Header.scala
index 3f743dc8aec..689b2e545e6 100644
--- a/core/src/main/scala/org/http4s/Header.scala
+++ b/core/src/main/scala/org/http4s/Header.scala
@@ -14,6 +14,7 @@ import cats.{Eq, Order, Show}
 import cats.data.NonEmptyList
 import cats.syntax.all._
 import org.http4s.internal.parboiled2.CharPredicate
+import org.http4s.internal.sanitize
 import org.http4s.syntax.string._
 import org.http4s.util._
 import scala.util.hashing.MurmurHash3
@@ -79,6 +80,8 @@ object Header {
 
   private val FieldNamePredicate =
     CharPredicate("!#$%&'*+-.^_`|~`") ++ CharPredicate.AlphaNum
+  private val FieldValueInvalidPredicate =
+    CharPredicate(0x0.toChar, '\r', '\n')
 
   /** Raw representation of the Header
     *
@@ -94,7 +97,8 @@ object Header {
         _parsed = parser.HttpHeaderParser.parseHeader(this).getOrElse(this)
       _parsed
     }
-    override def renderValue(writer: Writer): writer.type = writer.append(value)
+    override def renderValue(writer: Writer): writer.type =
+      writer.append(sanitize(value, FieldValueInvalidPredicate, ' '))
 
     override lazy val isNameValid: Boolean =
       name.toString.nonEmpty && name.toString.forall(FieldNamePredicate)
diff --git a/core/src/main/scala/org/http4s/internal/package.scala b/core/src/main/scala/org/http4s/internal/package.scala
index e5c25fe0cf4..18b38b6a70a 100644
--- a/core/src/main/scala/org/http4s/internal/package.scala
+++ b/core/src/main/scala/org/http4s/internal/package.scala
@@ -30,6 +30,7 @@ import cats.effect.{Async, Concurrent, ConcurrentEffect, ContextShift, Effect, I
 import cats.syntax.all._
 import fs2.{Chunk, Pipe, Pull, RaiseThrowable, Stream}
 import java.nio.{ByteBuffer, CharBuffer}
+import org.http4s.internal.parboiled2.CharPredicate
 import org.http4s.util.execution.direct
 import org.log4s.Logger
 
@@ -355,4 +356,25 @@ package object internal {
       tail: Eval[Int]*
   ): Int =
     reduceComparisons_(NonEmptyChain(Eval.now(head), tail: _*))
+
+  /** Sanitizes String {{s}}, replacing any characters matching
+    * {{invalid}} with {{replacement}}.
+    */
+  private[http4s] def sanitize(s: String, invalid: CharPredicate, replacement: Char): String = {
+    var i = 0
+    val len = s.length
+    while (i < len && !invalid(s.charAt(i))) i += 1
+    if (i == len) {
+      s
+    } else {
+      val chars = s.toCharArray
+      while (i < len) {
+        if (invalid(chars(i))) {
+          chars(i) = replacement
+        }
+        i += 1
+      }
+      new String(chars)
+    }
+  }
 }
diff --git a/tests/src/test/scala/org/http4s/headers/HeaderLaws.scala b/tests/src/test/scala/org/http4s/headers/HeaderLaws.scala
index 77242196d25..b05e12faaa6 100644
--- a/tests/src/test/scala/org/http4s/headers/HeaderLaws.scala
+++ b/tests/src/test/scala/org/http4s/headers/HeaderLaws.scala
@@ -21,8 +21,11 @@ import org.scalacheck.Arbitrary
 import org.scalacheck.Prop._
 import org.typelevel.discipline.Laws
 import org.http4s.laws.discipline.ArbitraryInstances._
+import org.http4s.util.StringWriter
 
 trait HeaderLaws extends munit.DisciplineSuite with Laws {
+  import HeaderLaws._
+
   def headerLaws(key: HeaderKey)(implicit
       arbHeader: Arbitrary[key.HeaderT]
   ): RuleSet =
@@ -42,6 +45,16 @@ trait HeaderLaws extends munit.DisciplineSuite with Laws {
       },
       """matchHeader does not match other names""" -> forAll { (header: Header) =>
         key.name != header.name ==> assert(key.matchHeader(header).isEmpty)
+      },
+      """sanitizes prohibited header characters""" -> forAll { (header: Header) =>
+        val sw = new StringWriter
+        header.renderValue(sw)
+        val value = sw.result
+        assert(!value.exists(ProhibitedFieldValueChars), value)
       }
     )
 }
+
+object HeaderLaws {
+  private val ProhibitedFieldValueChars = Set(0x0.toChar, '\r', '\n')
+}
diff --git a/tests/src/test/scala/org/http4s/internal/SanitizeSpec.scala b/tests/src/test/scala/org/http4s/internal/SanitizeSpec.scala
new file mode 100644
index 00000000000..7ece38ecae5
--- /dev/null
+++ b/tests/src/test/scala/org/http4s/internal/SanitizeSpec.scala
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2013 http4s.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.http4s
+package internal
+
+import org.http4s.internal.parboiled2.CharPredicate
+import org.scalacheck.Prop._
+
+class SanitizeSpec extends Http4sSuite {
+  test("eliminates invalid characters") {
+    forAll { (s: String, invalid: Set[Char], replacement: Char) =>
+      !invalid.contains(replacement) ==> {
+        val cp = CharPredicate(invalid.toSeq)
+        val sanitized = sanitize(s, cp, replacement)
+        assert(sanitized.forall(cp.negated), sanitized)
+      }
+    }
+  }
+
+  test("returns string of same length") {
+    forAll { (s: String, invalid: Set[Char], replacement: Char) =>
+      val cp = CharPredicate(invalid.toSeq)
+      assertEquals(sanitize(s, cp, replacement).length, s.length)
+    }
+  }
+
+  test("returns same string if all valid") {
+    forAll { (s: String, invalid: Set[Char], replacement: Char) =>
+      val cp = CharPredicate(invalid.toSeq)
+      s.forall(cp.negated) ==> {
+        assertEquals(sanitize(s, cp, replacement), s)
+      }
+    }
+  }
+}

From de1f696377f0de1f12637225694acb7766e999fc Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 10 Sep 2021 23:31:13 -0400
Subject: [PATCH 06/25] Refactor sanitization of headers

---
 core/src/main/scala/org/http4s/Header.scala   | 12 +++--
 .../scala/org/http4s/internal/package.scala   | 22 --------
 .../scala/org/http4s/util/Renderable.scala    | 52 +++++++++++++++++-
 .../ember/core/ResponseSplittingSuite.scala   |  2 +-
 .../test/scala/org/http4s/HeaderSuite.scala   |  2 +-
 .../scala/org/http4s/headers/HeaderLaws.scala |  9 ++--
 .../org/http4s/internal/SanitizeSpec.scala    | 49 -----------------
 .../org/http4s/util/StringWriterSuite.scala   | 53 +++++++++++++++++++
 8 files changed, 115 insertions(+), 86 deletions(-)
 delete mode 100644 tests/src/test/scala/org/http4s/internal/SanitizeSpec.scala
 create mode 100644 tests/src/test/scala/org/http4s/util/StringWriterSuite.scala

diff --git a/core/src/main/scala/org/http4s/Header.scala b/core/src/main/scala/org/http4s/Header.scala
index 689b2e545e6..094f99eb91a 100644
--- a/core/src/main/scala/org/http4s/Header.scala
+++ b/core/src/main/scala/org/http4s/Header.scala
@@ -14,7 +14,6 @@ import cats.{Eq, Order, Show}
 import cats.data.NonEmptyList
 import cats.syntax.all._
 import org.http4s.internal.parboiled2.CharPredicate
-import org.http4s.internal.sanitize
 import org.http4s.syntax.string._
 import org.http4s.util._
 import scala.util.hashing.MurmurHash3
@@ -41,6 +40,11 @@ sealed trait Header extends Renderable with Product {
     renderValue(w).result
   }
 
+  final def sanitizedValue: String = {
+    val w = new StringWriter
+    w.sanitize(renderValue(_)).result
+  }
+
   def is(key: HeaderKey): Boolean = key.matchHeader(this).isDefined
 
   def isNot(key: HeaderKey): Boolean = !is(key)
@@ -51,7 +55,7 @@ sealed trait Header extends Renderable with Product {
 
   final def render(writer: Writer): writer.type = {
     writer << name << ':' << ' '
-    renderValue(writer)
+    writer.sanitize(renderValue(_))
   }
 
   final override def hashCode(): Int =
@@ -80,8 +84,6 @@ object Header {
 
   private val FieldNamePredicate =
     CharPredicate("!#$%&'*+-.^_`|~`") ++ CharPredicate.AlphaNum
-  private val FieldValueInvalidPredicate =
-    CharPredicate(0x0.toChar, '\r', '\n')
 
   /** Raw representation of the Header
     *
@@ -98,7 +100,7 @@ object Header {
       _parsed
     }
     override def renderValue(writer: Writer): writer.type =
-      writer.append(sanitize(value, FieldValueInvalidPredicate, ' '))
+      writer.append(value)
 
     override lazy val isNameValid: Boolean =
       name.toString.nonEmpty && name.toString.forall(FieldNamePredicate)
diff --git a/core/src/main/scala/org/http4s/internal/package.scala b/core/src/main/scala/org/http4s/internal/package.scala
index 18b38b6a70a..e5c25fe0cf4 100644
--- a/core/src/main/scala/org/http4s/internal/package.scala
+++ b/core/src/main/scala/org/http4s/internal/package.scala
@@ -30,7 +30,6 @@ import cats.effect.{Async, Concurrent, ConcurrentEffect, ContextShift, Effect, I
 import cats.syntax.all._
 import fs2.{Chunk, Pipe, Pull, RaiseThrowable, Stream}
 import java.nio.{ByteBuffer, CharBuffer}
-import org.http4s.internal.parboiled2.CharPredicate
 import org.http4s.util.execution.direct
 import org.log4s.Logger
 
@@ -356,25 +355,4 @@ package object internal {
       tail: Eval[Int]*
   ): Int =
     reduceComparisons_(NonEmptyChain(Eval.now(head), tail: _*))
-
-  /** Sanitizes String {{s}}, replacing any characters matching
-    * {{invalid}} with {{replacement}}.
-    */
-  private[http4s] def sanitize(s: String, invalid: CharPredicate, replacement: Char): String = {
-    var i = 0
-    val len = s.length
-    while (i < len && !invalid(s.charAt(i))) i += 1
-    if (i == len) {
-      s
-    } else {
-      val chars = s.toCharArray
-      while (i < len) {
-        if (invalid(chars(i))) {
-          chars(i) = replacement
-        }
-        i += 1
-      }
-      new String(chars)
-    }
-  }
 }
diff --git a/core/src/main/scala/org/http4s/util/Renderable.scala b/core/src/main/scala/org/http4s/util/Renderable.scala
index d915d6a8248..98aa6a76f13 100644
--- a/core/src/main/scala/org/http4s/util/Renderable.scala
+++ b/core/src/main/scala/org/http4s/util/Renderable.scala
@@ -103,7 +103,7 @@ object Writer {
 }
 
 /** Efficiently accumulate [[Renderable]] representations */
-trait Writer {
+trait Writer { self =>
   def append(s: String): this.type
   def append(ci: CaseInsensitiveString): this.type = append(ci.toString)
   def append(char: Char): this.type = append(char.toString)
@@ -179,12 +179,30 @@ trait Writer {
   final def <<(int: Int): this.type = append(int)
   final def <<(long: Long): this.type = append(long)
   final def <<[T: Renderer](r: T): this.type = append(r)
+
+  def sanitize(f: Writer => Writer): this.type = {
+    val w = new Writer {
+      def append(s: String): this.type = {
+        s.foreach(append(_))
+        this
+      }
+      override def append(c: Char): this.type = {
+        if (c == 0x0.toChar || c == '\r' || c == '\n')
+          self.append(' ')
+        else
+          self.append(c)
+        this
+      }
+    }
+    f(w)
+    this
+  }
 }
 
 /** [[Writer]] that will result in a `String`
   * @param size initial buffer size of the underlying `StringBuilder`
   */
-class StringWriter(size: Int = StringWriter.InitialCapacity) extends Writer {
+class StringWriter(size: Int = StringWriter.InitialCapacity) extends Writer { self =>
   private val sb = new java.lang.StringBuilder(size)
 
   def append(s: String): this.type = { sb.append(s); this }
@@ -194,6 +212,31 @@ class StringWriter(size: Int = StringWriter.InitialCapacity) extends Writer {
   override def append(int: Int): this.type = { sb.append(int); this }
   override def append(long: Long): this.type = { sb.append(long); this }
 
+  override def sanitize(f: Writer => Writer): this.type = {
+    val w = new Writer {
+      def append(s: String): this.type = {
+        val start = sb.length
+        self.append(s)
+        for (i <- start until sb.length) {
+          val c = sb.charAt(i)
+          if (c == 0x0.toChar || c == '\r' || c == '\n') {
+            sb.setCharAt(i, ' ')
+          }
+        }
+        this
+      }
+      override def append(c: Char): this.type = {
+        if (c == 0x0.toChar || c == '\r' || c == '\n')
+          self.append(' ')
+        else
+          self.append(c)
+        this
+      }
+    }
+    f(w)
+    this
+  }
+
   def result: String = sb.toString
 }
 
@@ -209,4 +252,9 @@ private[http4s] class HeaderLengthCountingWriter extends Writer {
     length = length + s.length
     this
   }
+
+  override def sanitize(f: Writer => Writer): this.type = {
+    f(this)
+    this
+  }
 }
diff --git a/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala b/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala
index f72efdf0f57..b809ad370ff 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala
@@ -54,7 +54,7 @@ class ResponseSplittingSuite extends Http4sSuite {
 
   test("Prevent response splitting attacks on field value") {
     val app = HttpApp[IO] { req =>
-      Response(Status.NoContent).putHeaders(Header(req.params("fieldName"), "oops")).pure[IO]
+      Response(Status.NoContent).putHeaders(Header(req.params("fieldValue"), "oops")).pure[IO]
     }
     val req = Request[IO](uri = uri"/?fieldValue=%0D%0AEvil:true%0D%0A")
     attack(app, req).map { resp =>
diff --git a/tests/src/test/scala/org/http4s/HeaderSuite.scala b/tests/src/test/scala/org/http4s/HeaderSuite.scala
index d7b02a7943d..50ebef62512 100644
--- a/tests/src/test/scala/org/http4s/HeaderSuite.scala
+++ b/tests/src/test/scala/org/http4s/HeaderSuite.scala
@@ -98,7 +98,7 @@ class HeaderSuite extends munit.DisciplineSuite {
     forAll { (h: Header) =>
       val tchar =
         Set(0x21.toChar to 0x7e.toChar: _*).diff(Set("\"(),/:;<=>?@[\\]{}": _*)).map(_.toByte)
-      assertEquals(h.isNameValid, h.name.toString.getBytes(ISO_8859_1).forall(tchar), h.name)
+      assertEquals(h.isNameValid, h.name.toString.nonEmpty && h.name.toString.getBytes(ISO_8859_1).forall(tchar), h.name)
     }
   }
 }
diff --git a/tests/src/test/scala/org/http4s/headers/HeaderLaws.scala b/tests/src/test/scala/org/http4s/headers/HeaderLaws.scala
index b05e12faaa6..073aaaff3d9 100644
--- a/tests/src/test/scala/org/http4s/headers/HeaderLaws.scala
+++ b/tests/src/test/scala/org/http4s/headers/HeaderLaws.scala
@@ -21,7 +21,6 @@ import org.scalacheck.Arbitrary
 import org.scalacheck.Prop._
 import org.typelevel.discipline.Laws
 import org.http4s.laws.discipline.ArbitraryInstances._
-import org.http4s.util.StringWriter
 
 trait HeaderLaws extends munit.DisciplineSuite with Laws {
   import HeaderLaws._
@@ -46,11 +45,9 @@ trait HeaderLaws extends munit.DisciplineSuite with Laws {
       """matchHeader does not match other names""" -> forAll { (header: Header) =>
         key.name != header.name ==> assert(key.matchHeader(header).isEmpty)
       },
-      """sanitizes prohibited header characters""" -> forAll { (header: Header) =>
-        val sw = new StringWriter
-        header.renderValue(sw)
-        val value = sw.result
-        assert(!value.exists(ProhibitedFieldValueChars), value)
+      """sanitizes prohibited header characters""" -> forAll { (a: key.HeaderT) =>
+        val s = a.renderString
+        assert(!s.exists(ProhibitedFieldValueChars), s)
       }
     )
 }
diff --git a/tests/src/test/scala/org/http4s/internal/SanitizeSpec.scala b/tests/src/test/scala/org/http4s/internal/SanitizeSpec.scala
deleted file mode 100644
index 7ece38ecae5..00000000000
--- a/tests/src/test/scala/org/http4s/internal/SanitizeSpec.scala
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright 2013 http4s.org
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.http4s
-package internal
-
-import org.http4s.internal.parboiled2.CharPredicate
-import org.scalacheck.Prop._
-
-class SanitizeSpec extends Http4sSuite {
-  test("eliminates invalid characters") {
-    forAll { (s: String, invalid: Set[Char], replacement: Char) =>
-      !invalid.contains(replacement) ==> {
-        val cp = CharPredicate(invalid.toSeq)
-        val sanitized = sanitize(s, cp, replacement)
-        assert(sanitized.forall(cp.negated), sanitized)
-      }
-    }
-  }
-
-  test("returns string of same length") {
-    forAll { (s: String, invalid: Set[Char], replacement: Char) =>
-      val cp = CharPredicate(invalid.toSeq)
-      assertEquals(sanitize(s, cp, replacement).length, s.length)
-    }
-  }
-
-  test("returns same string if all valid") {
-    forAll { (s: String, invalid: Set[Char], replacement: Char) =>
-      val cp = CharPredicate(invalid.toSeq)
-      s.forall(cp.negated) ==> {
-        assertEquals(sanitize(s, cp, replacement), s)
-      }
-    }
-  }
-}
diff --git a/tests/src/test/scala/org/http4s/util/StringWriterSuite.scala b/tests/src/test/scala/org/http4s/util/StringWriterSuite.scala
new file mode 100644
index 00000000000..36556acaf89
--- /dev/null
+++ b/tests/src/test/scala/org/http4s/util/StringWriterSuite.scala
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2013 http4s.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.http4s
+package util
+
+import org.scalacheck.Arbitrary.arbitrary
+import org.scalacheck.Gen._
+import org.scalacheck.Prop._
+
+class StringWriterSuite extends Http4sSuite {
+
+  test("sanitize works on chars") {
+    val sw = new StringWriter
+    sw.sanitize(_ << 'x' << 0x0.toChar << '\r' << '\n' << 'x')
+    assertEquals("x   x", sw.result)
+  }
+
+  test("sanitize works on strings") {
+    val sw = new StringWriter
+    sw.sanitize(_ << "x\u0000\r\nx")
+    assertEquals("x   x", sw.result)
+  }
+
+  test("sanitizes between appends") {
+    val forbiddenChars = Set(0x0.toChar, '\r', '\n')
+    val unsanitaryGen = stringOf(oneOf(oneOf(forbiddenChars), arbitrary[Char]))
+    forAll(arbitrary[String], unsanitaryGen, arbitrary[String]) {
+      (s1: String, s2: String, s3: String) =>
+        s2.exists(forbiddenChars) ==> {
+          val sw = new StringWriter
+          (sw << s1).sanitize(_ << s2) << s3
+          val s = sw.result
+          assert(s.startsWith(s1))
+          assert(s.endsWith(s3))
+          assert(!s.drop(s1.length).dropRight(s3.length).exists(forbiddenChars))
+        }
+    }
+  }
+}

From 617b9e76b686bc48c46e55a2d9cca3426c4c3fbc Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Sat, 11 Sep 2021 15:59:56 -0400
Subject: [PATCH 07/25] Demonstrate request splitting in Ember

---
 .../ember/core/RequestSplittingSuite.scala    | 53 +++++++++++++++++++
 1 file changed, 53 insertions(+)
 create mode 100644 ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala

diff --git a/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala b/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala
new file mode 100644
index 00000000000..bd0a7c35c11
--- /dev/null
+++ b/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2019 http4s.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.http4s
+package ember.core
+
+import cats.effect.{Concurrent, IO}
+import cats.implicits._
+import org.http4s.implicits._
+
+class RequestSplittingSuite extends Http4sSuite {
+  def attack[F[_]](req: Request[F])(implicit F: Concurrent[F]): F[Response[F]] =
+    for {
+      reqBytes <- Encoder
+        .reqToBytes(req)
+        .compile
+        .to(Array)
+      app = HttpApp[F] { req =>
+        (req.headers.get("Evil".ci) match {
+          case Some(_) => Response[F](Status.InternalServerError)
+          case None => Response[F](Status.Ok)
+        }).pure[F]
+      }
+      result <- Parser.Request.parser[F](1024)(reqBytes, F.pure(None))
+      (req0, _) = result
+      resp <- app(req0)
+    } yield resp
+
+  test("Prevent request splitting attacks on URI path") {
+    val req = Request[IO](uri = Uri(path = "/ HTTP/1.0\r\nEvil:true\r\nHide-Protocol-Version:"))
+    attack(req).map(_.status).assertEquals(Status.Ok)
+  }
+
+  test("Prevent request splitting attacks on URI regname") {
+    val req = Request[IO](uri = Uri(
+      authority = Uri.Authority(None, Uri.RegName("example.com\r\nEvil:true\r\n")).some,
+      path = "/"))
+    attack(req).map(_.status).assertEquals(Status.Ok)
+  }
+}

From 82aa0fc0df2450fa808300b4e2f904fa50d17b03 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Sat, 11 Sep 2021 22:20:16 -0400
Subject: [PATCH 08/25] Demonstate request splitting in other clients

---
 .../client/ClientRouteTestBattery.scala       | 39 +++++++++++++++++--
 .../org/http4s/client/jetty/JettyClient.scala |  8 ++--
 .../test/scala/org/http4s/HeaderSuite.scala   |  5 ++-
 3 files changed, 44 insertions(+), 8 deletions(-)

diff --git a/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala b/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
index fa5e52c66f4..e6b66373bc7 100644
--- a/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
+++ b/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
@@ -37,10 +37,19 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
   def testServlet =
     new HttpServlet {
       override def doGet(req: HttpServletRequest, srv: HttpServletResponse): Unit =
-        GetRoutes.getPaths.get(req.getRequestURI) match {
-          case Some(r) =>
-            renderResponse(srv, r.unsafeRunSync()).unsafeRunSync() // We are outside the IO world
-          case None => srv.sendError(404)
+        req.getPathInfo match {
+          case "/request-splitting" =>
+            Option(req.getHeader("Evil")) match {
+              case None => srv.setStatus(200)
+              case Some(_) => srv.sendError(500)
+            }
+          case _ =>
+            GetRoutes.getPaths.get(req.getRequestURI) match {
+              case Some(r) =>
+                renderResponse(srv, r.unsafeRunSync())
+                  .unsafeRunSync() // We are outside the IO world
+              case None => srv.sendError(404)
+            }
         }
 
       override def doPost(req: HttpServletRequest, srv: HttpServletResponse): Unit = {
@@ -120,6 +129,28 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
     }
   }
 
+  test("Mitigates request splitting attack in URI path") {
+    val address = jetty().addresses.head
+    val name = address.getHostName
+    val port = address.getPort
+    val req = Request[IO](
+      uri = Uri(
+        authority = Uri.Authority(None, Uri.RegName(name), port = port.some).some,
+        path = "/request-splitting HTTP/1.0\r\nEvil:true\r\nHide-Protocol-Version:"))
+    client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
+  }
+
+  test("Mitigates request splitting attack in URI RegName") {
+    val address = jetty().addresses.head
+    val name = address.getHostName
+    val port = address.getPort
+    val req = Request[IO](uri = Uri(
+      authority =
+        Uri.Authority(None, Uri.RegName(s"${name}\r\nEvil:true\r\n"), port = port.some).some,
+      path = "/request-splitting"))
+    client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
+  }
+
   private def checkResponse(rec: Response[IO], expected: Response[IO]): IO[Boolean] = {
     val hs = rec.headers.toList
     for {
diff --git a/jetty-client/src/main/scala/org/http4s/client/jetty/JettyClient.scala b/jetty-client/src/main/scala/org/http4s/client/jetty/JettyClient.scala
index 7ac4daebe3a..bf8fb358ef3 100644
--- a/jetty-client/src/main/scala/org/http4s/client/jetty/JettyClient.scala
+++ b/jetty-client/src/main/scala/org/http4s/client/jetty/JettyClient.scala
@@ -39,12 +39,14 @@ object JettyClient {
         Client[F] { req =>
           Resource.suspend(F.asyncF[Resource[F, Response[F]]] { cb =>
             F.bracket(StreamRequestContentProvider()) { dcp =>
-              val jReq = toJettyRequest(client, req, dcp)
-              for {
+              (for {
+                jReq <- F.catchNonFatal(toJettyRequest(client, req, dcp))
                 rl <- ResponseListener(cb)
                 _ <- F.delay(jReq.send(rl))
                 _ <- dcp.write(req)
-              } yield ()
+              } yield ()).recover { case e =>
+                cb(Left(e))
+              }
             } { dcp =>
               F.delay(dcp.close())
             }
diff --git a/tests/src/test/scala/org/http4s/HeaderSuite.scala b/tests/src/test/scala/org/http4s/HeaderSuite.scala
index 50ebef62512..27866702229 100644
--- a/tests/src/test/scala/org/http4s/HeaderSuite.scala
+++ b/tests/src/test/scala/org/http4s/HeaderSuite.scala
@@ -98,7 +98,10 @@ class HeaderSuite extends munit.DisciplineSuite {
     forAll { (h: Header) =>
       val tchar =
         Set(0x21.toChar to 0x7e.toChar: _*).diff(Set("\"(),/:;<=>?@[\\]{}": _*)).map(_.toByte)
-      assertEquals(h.isNameValid, h.name.toString.nonEmpty && h.name.toString.getBytes(ISO_8859_1).forall(tchar), h.name)
+      assertEquals(
+        h.isNameValid,
+        h.name.toString.nonEmpty && h.name.toString.getBytes(ISO_8859_1).forall(tchar),
+        h.name)
     }
   }
 }

From 95773bae79729b2b8ae1e6223c351f4853642ff6 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Sat, 11 Sep 2021 22:34:01 -0400
Subject: [PATCH 09/25] Mitigate request attacks in blaze-client

---
 .../http4s/client/blaze/Http1Connection.scala   | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/blaze-client/src/main/scala/org/http4s/client/blaze/Http1Connection.scala b/blaze-client/src/main/scala/org/http4s/client/blaze/Http1Connection.scala
index 456e178ffaa..ae7023e39e2 100644
--- a/blaze-client/src/main/scala/org/http4s/client/blaze/Http1Connection.scala
+++ b/blaze-client/src/main/scala/org/http4s/client/blaze/Http1Connection.scala
@@ -32,6 +32,7 @@ import org.http4s.blaze.pipeline.Command.EOF
 import org.http4s.blazecore.{Http1Stage, IdleTimeoutStage}
 import org.http4s.blazecore.util.Http1Writer
 import org.http4s.headers.{Connection, Host, `Content-Length`, `User-Agent`}
+import org.http4s.internal.parboiled2.CharPredicate
 import org.http4s.util.{StringWriter, Writer}
 
 import scala.annotation.tailrec
@@ -411,16 +412,22 @@ private final class Http1Connection[F[_]](
     else if (minor == 1 && req.uri.host.isEmpty) // this is unlikely if not impossible
       if (Host.from(req.headers).isDefined) {
         val host = Host.from(req.headers).get
-        val newAuth = req.uri.authority match {
-          case Some(auth) => auth.copy(host = RegName(host.host), port = host.port)
-          case None => Authority(host = RegName(host.host), port = host.port)
+        if (host.host.exists(ForbiddenUriCharacters)) {
+          Left(new IllegalArgumentException(s"Invalid Host: $host"))
+        } else {
+          val newAuth = req.uri.authority match {
+            case Some(auth) => auth.copy(host = RegName(host.host), port = host.port)
+            case None => Authority(host = RegName(host.host), port = host.port)
+          }
+          validateRequest(req.withUri(req.uri.copy(authority = Some(newAuth))))
         }
-        validateRequest(req.withUri(req.uri.copy(authority = Some(newAuth))))
       } else if (`Content-Length`.from(req.headers).nonEmpty) // translate to HTTP/1.0
         validateRequest(req.withHttpVersion(HttpVersion.`HTTP/1.0`))
       else
         Left(new IllegalArgumentException("Host header required for HTTP/1.1 request"))
     else if (req.uri.path == "") Right(req.withUri(req.uri.copy(path = "/")))
+    else if (req.uri.path.exists(ForbiddenUriCharacters))
+      Left(new IllegalArgumentException(s"Invalid URI path: ${req.uri.path}"))
     else Right(req) // All appears to be well
   }
 
@@ -463,4 +470,6 @@ private object Http1Connection {
       writer
     } else writer
   }
+
+  private val ForbiddenUriCharacters = CharPredicate(0x0.toChar, ' ', '\r', '\n')
 }

From 2d2655c7eb5f702f4e795e9671ebe435b1eec0ce Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Sat, 11 Sep 2021 23:07:32 -0400
Subject: [PATCH 10/25] Mitigate request attacks in ember-client

---
 .../scala/org/http4s/ember/core/Encoder.scala | 96 +++++++++++--------
 .../ember/core/RequestSplittingSuite.scala    |  4 +-
 2 files changed, 57 insertions(+), 43 deletions(-)

diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
index c6cf0abd12f..846dac26321 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
@@ -19,7 +19,8 @@ package org.http4s.ember.core
 import cats.effect._
 import fs2._
 import org.http4s._
-import org.http4s.headers.`Content-Length`
+import org.http4s.headers.{Host, `Content-Length`}
+import org.http4s.internal.parboiled2.CharPredicate
 import java.nio.charset.StandardCharsets
 import scala.annotation.nowarn
 
@@ -79,57 +80,70 @@ private[ember] object Encoder {
   private val NoPayloadMethods: Set[Method] =
     Set(Method.GET, Method.DELETE, Method.CONNECT, Method.TRACE)
 
-  @nowarn("cat=unused")
   def reqToBytes[F[_]: Sync](req: Request[F], writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {
-    var chunked = req.isChunked
-    val initSection = {
-      var appliedContentLength = false
-      val stringBuilder = new StringBuilder()
+    val uriOriginFormString = req.uri.toOriginForm.renderString
+    val hostFromUriString = Host.from(req.headers) match {
+      case Some(_) => None
+      case None => req.uri.authority.map(_.renderString)
+    }
 
-      // Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
-      stringBuilder
-        .append(req.method.renderString)
-        .append(SPACE)
-        .append(req.uri.toOriginForm.renderString)
-        .append(SPACE)
-        .append(req.httpVersion.renderString)
-        .append(CRLF)
+    if (uriOriginFormString.exists(ForbiddenUriCharacters))
+      Stream.raiseError(new IllegalArgumentException(s"Invalid URI: ${uriOriginFormString}"))
+    else if (hostFromUriString.fold(false)(_.exists(ForbiddenUriCharacters))) {
+      Stream.raiseError(
+        new IllegalArgumentException(s"Invalid host in URI: ${hostFromUriString.getOrElse("")}"))
+    } else {
+      var chunked = req.isChunked
+      val initSection = {
+        var appliedContentLength = false
+        val stringBuilder = new StringBuilder()
+
+        // Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
+        stringBuilder
+          .append(req.method.renderString)
+          .append(SPACE)
+          .append(uriOriginFormString)
+          .append(SPACE)
+          .append(req.httpVersion.renderString)
+          .append(CRLF)
 
-      // Host From Uri Becomes Header if not already present in headers
-      if (org.http4s.headers.Host.from(req.headers).isEmpty)
-        req.uri.authority.foreach { auth =>
+        // Host From Uri Becomes Header if not already present in headers
+        hostFromUriString.foreach { auth =>
           stringBuilder
             .append("Host: ")
-            .append(auth.renderString)
+            .append(auth)
             .append(CRLF)
         }
 
-      // Apply each header followed by a CRLF
-      req.headers.foreach { h =>
-        if (h.is(`Content-Length`)) appliedContentLength = true
-        else ()
+        // Apply each header followed by a CRLF
+        req.headers.foreach { h =>
+          if (h.is(`Content-Length`)) appliedContentLength = true
+          else ()
 
-        stringBuilder
-          .append(h.renderString)
-          .append(CRLF)
-        ()
-      }
+          stringBuilder
+            .append(h.renderString)
+            .append(CRLF)
+          ()
+        }
 
-      if (!chunked && !appliedContentLength && !NoPayloadMethods.contains(req.method)) {
-        stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)
-        chunked = true
-        ()
-      }
+        if (!chunked && !appliedContentLength && !NoPayloadMethods.contains(req.method)) {
+          stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)
+          chunked = true
+          ()
+        }
 
-      // Final CRLF terminates headers and signals body to follow.
-      stringBuilder.append(CRLF)
-      stringBuilder.toString.getBytes(StandardCharsets.ISO_8859_1)
+        // Final CRLF terminates headers and signals body to follow.
+        stringBuilder.append(CRLF)
+        stringBuilder.toString.getBytes(StandardCharsets.ISO_8859_1)
+      }
+      if (chunked)
+        Stream.chunk(Chunk.array(initSection)) ++ req.body.through(ChunkedEncoding.encode[F])
+      else
+        (Stream.chunk(Chunk.array(initSection)) ++ req.body)
+          .chunkMin(writeBufferSize)
+          .flatMap(Stream.chunk)
     }
-    if (chunked)
-      Stream.chunk(Chunk.array(initSection)) ++ req.body.through(ChunkedEncoding.encode[F])
-    else
-      (Stream.chunk(Chunk.array(initSection)) ++ req.body)
-        .chunkMin(writeBufferSize)
-        .flatMap(Stream.chunk)
   }
+
+  private val ForbiddenUriCharacters = CharPredicate(0x0.toChar, ' ', '\r', '\n')
 }
diff --git a/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala b/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala
index bd0a7c35c11..27ee0c139d1 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala
@@ -41,13 +41,13 @@ class RequestSplittingSuite extends Http4sSuite {
 
   test("Prevent request splitting attacks on URI path") {
     val req = Request[IO](uri = Uri(path = "/ HTTP/1.0\r\nEvil:true\r\nHide-Protocol-Version:"))
-    attack(req).map(_.status).assertEquals(Status.Ok)
+    attack(req).intercept[IllegalArgumentException]
   }
 
   test("Prevent request splitting attacks on URI regname") {
     val req = Request[IO](uri = Uri(
       authority = Uri.Authority(None, Uri.RegName("example.com\r\nEvil:true\r\n")).some,
       path = "/"))
-    attack(req).map(_.status).assertEquals(Status.Ok)
+    attack(req).intercept[IllegalArgumentException]
   }
 }

From 96b9ad7d250e160de93ca933b24f9cea5961d05f Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Sat, 11 Sep 2021 23:48:28 -0400
Subject: [PATCH 11/25] Eliminate unused isNameValid

---
 core/src/main/scala/org/http4s/Header.scala | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/core/src/main/scala/org/http4s/Header.scala b/core/src/main/scala/org/http4s/Header.scala
index c836e28d589..882185e70cc 100644
--- a/core/src/main/scala/org/http4s/Header.scala
+++ b/core/src/main/scala/org/http4s/Header.scala
@@ -14,18 +14,11 @@ import cats.data.Ior
   * `Header[YourModelledHeader]`
   */
 trait Header[A, T <: Header.Type] {
-  import Header._
 
   /** Name of the header. Not case sensitive.
     */
   def name: CIString
 
-  /** True if [[name]] is a valid field-name per RFC7230.  Where it
-    * is not, the header may be dropped by the backend.
-    */
-  def isNameValid: Boolean =
-    name.toString.nonEmpty && name.toString.forall(FieldNamePredicate)
-
   /** Value of the header, which is represented as a String.
     * Will be a comma separated String for headers with multiple values.
     */

From a6f96809304e0050d23939f493c2c353576962c9 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Tue, 14 Sep 2021 17:04:23 -0400
Subject: [PATCH 12/25] Validate all header names

---
 core/src/main/scala/org/http4s/Header.scala | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/core/src/main/scala/org/http4s/Header.scala b/core/src/main/scala/org/http4s/Header.scala
index 094f99eb91a..06968658dc8 100644
--- a/core/src/main/scala/org/http4s/Header.scala
+++ b/core/src/main/scala/org/http4s/Header.scala
@@ -22,14 +22,15 @@ import scala.util.hashing.MurmurHash3
   * @see org.http4s.HeaderKey
   */
 sealed trait Header extends Renderable with Product {
-  import Header.Raw
+  import Header._
 
   def name: CaseInsensitiveString
 
   /** True if [[name]] is a valid field-name per RFC7230.  Where it
     * is not, the header may be dropped by the backend.
     */
-  def isNameValid: Boolean = true
+  def isNameValid: Boolean =
+    name.toString.nonEmpty && name.toString.forall(FieldNamePredicate)
 
   def parsed: Header
 
@@ -101,9 +102,6 @@ object Header {
     }
     override def renderValue(writer: Writer): writer.type =
       writer.append(value)
-
-    override lazy val isNameValid: Boolean =
-      name.toString.nonEmpty && name.toString.forall(FieldNamePredicate)
   }
 
   /** A Header that is already parsed from its String representation. */

From 891a5acd308566b7db14e8f5a258ca054af8e6c2 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Tue, 14 Sep 2021 22:15:44 -0400
Subject: [PATCH 13/25] Override isNameValid where it's safe

---
 core/src/main/scala/org/http4s/headers/Accept-Charset.scala     | 2 ++
 core/src/main/scala/org/http4s/headers/Accept-Encoding.scala    | 2 ++
 core/src/main/scala/org/http4s/headers/Accept-Language.scala    | 2 ++
 core/src/main/scala/org/http4s/headers/Accept-Ranges.scala      | 2 ++
 core/src/main/scala/org/http4s/headers/Accept.scala             | 2 ++
 core/src/main/scala/org/http4s/headers/Age.scala                | 2 ++
 core/src/main/scala/org/http4s/headers/Allow.scala              | 2 ++
 core/src/main/scala/org/http4s/headers/Authorization.scala      | 2 ++
 core/src/main/scala/org/http4s/headers/Cache-Control.scala      | 2 ++
 core/src/main/scala/org/http4s/headers/Connection.scala         | 2 ++
 .../src/main/scala/org/http4s/headers/Content-Disposition.scala | 2 ++
 core/src/main/scala/org/http4s/headers/Content-Encoding.scala   | 2 ++
 core/src/main/scala/org/http4s/headers/Content-Length.scala     | 2 ++
 core/src/main/scala/org/http4s/headers/Content-Range.scala      | 2 ++
 core/src/main/scala/org/http4s/headers/Content-Type.scala       | 2 ++
 core/src/main/scala/org/http4s/headers/Cookie.scala             | 2 ++
 core/src/main/scala/org/http4s/headers/Date.scala               | 2 ++
 core/src/main/scala/org/http4s/headers/ETag.scala               | 2 ++
 core/src/main/scala/org/http4s/headers/Expires.scala            | 2 ++
 core/src/main/scala/org/http4s/headers/Forwarded.scala          | 2 ++
 core/src/main/scala/org/http4s/headers/Host.scala               | 2 ++
 core/src/main/scala/org/http4s/headers/If-Match.scala           | 2 ++
 core/src/main/scala/org/http4s/headers/If-Modified-Since.scala  | 2 ++
 core/src/main/scala/org/http4s/headers/If-None-Match.scala      | 2 ++
 .../src/main/scala/org/http4s/headers/If-Unmodified-Since.scala | 2 ++
 core/src/main/scala/org/http4s/headers/Last-Event-Id.scala      | 2 ++
 core/src/main/scala/org/http4s/headers/Last-Modified.scala      | 2 ++
 core/src/main/scala/org/http4s/headers/Link.scala               | 2 ++
 core/src/main/scala/org/http4s/headers/Location.scala           | 2 ++
 core/src/main/scala/org/http4s/headers/Origin.scala             | 2 ++
 core/src/main/scala/org/http4s/headers/Proxy-Authenticate.scala | 2 ++
 core/src/main/scala/org/http4s/headers/Range.scala              | 2 ++
 core/src/main/scala/org/http4s/headers/Referer.scala            | 2 ++
 core/src/main/scala/org/http4s/headers/Retry-After.scala        | 2 ++
 core/src/main/scala/org/http4s/headers/Set-Cookie.scala         | 2 ++
 .../scala/org/http4s/headers/Strict-Transport-Security.scala    | 2 ++
 core/src/main/scala/org/http4s/headers/Transfer-Encoding.scala  | 2 ++
 core/src/main/scala/org/http4s/headers/User-Agent.scala         | 2 ++
 core/src/main/scala/org/http4s/headers/WWW-Authenticate.scala   | 2 ++
 core/src/main/scala/org/http4s/headers/X-B3-Flags.scala         | 2 ++
 core/src/main/scala/org/http4s/headers/X-B3-ParentSpanId.scala  | 2 ++
 core/src/main/scala/org/http4s/headers/X-B3-Sampled.scala       | 2 ++
 core/src/main/scala/org/http4s/headers/X-B3-SpanId.scala        | 2 ++
 core/src/main/scala/org/http4s/headers/X-B3-TraceId.scala       | 2 ++
 core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala    | 2 ++
 45 files changed, 90 insertions(+)

diff --git a/core/src/main/scala/org/http4s/headers/Accept-Charset.scala b/core/src/main/scala/org/http4s/headers/Accept-Charset.scala
index d2700fd62bb..dd3ebc2dca0 100644
--- a/core/src/main/scala/org/http4s/headers/Accept-Charset.scala
+++ b/core/src/main/scala/org/http4s/headers/Accept-Charset.scala
@@ -55,4 +55,6 @@ final case class `Accept-Charset`(values: NonEmptyList[CharsetRange])
   def satisfiedBy(charset: Charset): Boolean = qValue(charset) > QValue.Zero
 
   def map(f: CharsetRange => CharsetRange): `Accept-Charset` = `Accept-Charset`(values.map(f))
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Accept-Encoding.scala b/core/src/main/scala/org/http4s/headers/Accept-Encoding.scala
index c649e1c711c..f5223afe1a7 100644
--- a/core/src/main/scala/org/http4s/headers/Accept-Encoding.scala
+++ b/core/src/main/scala/org/http4s/headers/Accept-Encoding.scala
@@ -48,4 +48,6 @@ final case class `Accept-Encoding`(values: NonEmptyList[ContentCoding])
   }
 
   def satisfiedBy(coding: ContentCoding): Boolean = qValue(coding) > QValue.Zero
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Accept-Language.scala b/core/src/main/scala/org/http4s/headers/Accept-Language.scala
index ba069729019..fadc8868467 100644
--- a/core/src/main/scala/org/http4s/headers/Accept-Language.scala
+++ b/core/src/main/scala/org/http4s/headers/Accept-Language.scala
@@ -50,4 +50,6 @@ final case class `Accept-Language`(values: NonEmptyList[LanguageTag])
       .fold(QValue.Zero)(_._2)
 
   def satisfiedBy(languageTag: LanguageTag): Boolean = qValue(languageTag) > QValue.Zero
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Accept-Ranges.scala b/core/src/main/scala/org/http4s/headers/Accept-Ranges.scala
index ece61a75b99..38935336f24 100644
--- a/core/src/main/scala/org/http4s/headers/Accept-Ranges.scala
+++ b/core/src/main/scala/org/http4s/headers/Accept-Ranges.scala
@@ -39,4 +39,6 @@ final case class `Accept-Ranges` private[http4s] (rangeUnits: List[RangeUnit])
       rangeUnits.tail.foreach(r => writer.append(", ").append(r))
       writer
     }
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Accept.scala b/core/src/main/scala/org/http4s/headers/Accept.scala
index f814806694a..6284f87466b 100644
--- a/core/src/main/scala/org/http4s/headers/Accept.scala
+++ b/core/src/main/scala/org/http4s/headers/Accept.scala
@@ -44,4 +44,6 @@ final case class Accept(values: NonEmptyList[MediaRangeAndQValue])
     extends Header.RecurringRenderable {
   def key: Accept.type = Accept
   type Value = MediaRangeAndQValue
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Age.scala b/core/src/main/scala/org/http4s/headers/Age.scala
index 3af61f792a7..aebdee54bbb 100644
--- a/core/src/main/scala/org/http4s/headers/Age.scala
+++ b/core/src/main/scala/org/http4s/headers/Age.scala
@@ -57,4 +57,6 @@ sealed abstract case class Age(age: Long) extends Header.Parsed {
   def duration: Option[FiniteDuration] = Try(age.seconds).toOption
 
   def unsafeDuration: FiniteDuration = age.seconds
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Allow.scala b/core/src/main/scala/org/http4s/headers/Allow.scala
index 02566ffa25a..e1e41f00aa4 100644
--- a/core/src/main/scala/org/http4s/headers/Allow.scala
+++ b/core/src/main/scala/org/http4s/headers/Allow.scala
@@ -36,4 +36,6 @@ final case class Allow(methods: Set[Method]) extends Header.Parsed {
   override def key: Allow.type = Allow
   override def renderValue(writer: Writer): writer.type =
     writer.addSet[Method](methods, sep = ", ")
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Authorization.scala b/core/src/main/scala/org/http4s/headers/Authorization.scala
index 2fd9c5e789b..828149917e6 100644
--- a/core/src/main/scala/org/http4s/headers/Authorization.scala
+++ b/core/src/main/scala/org/http4s/headers/Authorization.scala
@@ -31,4 +31,6 @@ object Authorization extends HeaderKey.Internal[Authorization] with HeaderKey.Si
 final case class Authorization(credentials: Credentials) extends Header.Parsed {
   override def key: `Authorization`.type = `Authorization`
   override def renderValue(writer: Writer): writer.type = credentials.render(writer)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Cache-Control.scala b/core/src/main/scala/org/http4s/headers/Cache-Control.scala
index 7916ce97bb7..574a7be0143 100644
--- a/core/src/main/scala/org/http4s/headers/Cache-Control.scala
+++ b/core/src/main/scala/org/http4s/headers/Cache-Control.scala
@@ -29,4 +29,6 @@ final case class `Cache-Control`(values: NonEmptyList[CacheDirective])
     extends Header.RecurringRenderable {
   override def key: `Cache-Control`.type = `Cache-Control`
   type Value = CacheDirective
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Connection.scala b/core/src/main/scala/org/http4s/headers/Connection.scala
index db51bd96c75..fbb820a513a 100644
--- a/core/src/main/scala/org/http4s/headers/Connection.scala
+++ b/core/src/main/scala/org/http4s/headers/Connection.scala
@@ -37,4 +37,6 @@ final case class Connection(values: NonEmptyList[CaseInsensitiveString]) extends
   def hasKeepAlive: Boolean = values.contains_("keep-alive".ci)
   override def renderValue(writer: Writer): writer.type =
     writer.addStringNel(values.map(_.toString), ", ")
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Content-Disposition.scala b/core/src/main/scala/org/http4s/headers/Content-Disposition.scala
index 27fcff615e2..ffac6eecff5 100644
--- a/core/src/main/scala/org/http4s/headers/Content-Disposition.scala
+++ b/core/src/main/scala/org/http4s/headers/Content-Disposition.scala
@@ -37,4 +37,6 @@ final case class `Content-Disposition`(dispositionType: String, parameters: Map[
     parameters.foreach(p => writer << "; " << p._1 << "=\"" << p._2 << '"')
     writer
   }
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Content-Encoding.scala b/core/src/main/scala/org/http4s/headers/Content-Encoding.scala
index 7d1278e7d04..39a87af6dfc 100644
--- a/core/src/main/scala/org/http4s/headers/Content-Encoding.scala
+++ b/core/src/main/scala/org/http4s/headers/Content-Encoding.scala
@@ -28,4 +28,6 @@ object `Content-Encoding` extends HeaderKey.Internal[`Content-Encoding`] with He
 final case class `Content-Encoding`(contentCoding: ContentCoding) extends Header.Parsed {
   override def key: `Content-Encoding`.type = `Content-Encoding`
   override def renderValue(writer: Writer): writer.type = contentCoding.render(writer)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Content-Length.scala b/core/src/main/scala/org/http4s/headers/Content-Length.scala
index f62a9a368b9..1996ec79886 100644
--- a/core/src/main/scala/org/http4s/headers/Content-Length.scala
+++ b/core/src/main/scala/org/http4s/headers/Content-Length.scala
@@ -32,6 +32,8 @@ sealed abstract case class `Content-Length`(length: Long) extends Header.Parsed
   override def renderValue(writer: Writer): writer.type = writer.append(length)
   def modify(f: Long => Long): Option[`Content-Length`] =
     `Content-Length`.fromLong(f(length)).toOption
+
+  override def isNameValid: Boolean = true
 }
 
 object `Content-Length` extends HeaderKey.Internal[`Content-Length`] with HeaderKey.Singleton {
diff --git a/core/src/main/scala/org/http4s/headers/Content-Range.scala b/core/src/main/scala/org/http4s/headers/Content-Range.scala
index 262d673b503..38bbd95af86 100644
--- a/core/src/main/scala/org/http4s/headers/Content-Range.scala
+++ b/core/src/main/scala/org/http4s/headers/Content-Range.scala
@@ -43,4 +43,6 @@ final case class `Content-Range`(unit: RangeUnit, range: Range.SubRange, length:
       case None => writer << '*'
     }
   }
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Content-Type.scala b/core/src/main/scala/org/http4s/headers/Content-Type.scala
index f9bbf9cee6d..d16a6302b92 100644
--- a/core/src/main/scala/org/http4s/headers/Content-Type.scala
+++ b/core/src/main/scala/org/http4s/headers/Content-Type.scala
@@ -56,4 +56,6 @@ final case class `Content-Type` private (mediaType: MediaType, charset: Option[C
 
   def isCharsetDefined: Boolean = charset.isDefined
   def noCharsetDefined: Boolean = charset.isEmpty
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Cookie.scala b/core/src/main/scala/org/http4s/headers/Cookie.scala
index 11d4a491d6f..80c02913d2b 100644
--- a/core/src/main/scala/org/http4s/headers/Cookie.scala
+++ b/core/src/main/scala/org/http4s/headers/Cookie.scala
@@ -34,4 +34,6 @@ final case class Cookie(values: NonEmptyList[RequestCookie]) extends Header.Recu
     values.tail.foreach(writer << "; " << _)
     writer
   }
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Date.scala b/core/src/main/scala/org/http4s/headers/Date.scala
index ece89683d45..8565214b6af 100644
--- a/core/src/main/scala/org/http4s/headers/Date.scala
+++ b/core/src/main/scala/org/http4s/headers/Date.scala
@@ -29,4 +29,6 @@ final case class Date(date: HttpDate) extends Header.Parsed {
   def key: Date.type = Date
   override def value: String = Renderer.renderString(date)
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/ETag.scala b/core/src/main/scala/org/http4s/headers/ETag.scala
index 6932e7b408e..2df8e360906 100644
--- a/core/src/main/scala/org/http4s/headers/ETag.scala
+++ b/core/src/main/scala/org/http4s/headers/ETag.scala
@@ -43,4 +43,6 @@ final case class ETag(tag: ETag.EntityTag) extends Header.Parsed {
   def key: ETag.type = ETag
   override def value: String = tag.toString()
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Expires.scala b/core/src/main/scala/org/http4s/headers/Expires.scala
index e8aae274091..9f576ef323d 100644
--- a/core/src/main/scala/org/http4s/headers/Expires.scala
+++ b/core/src/main/scala/org/http4s/headers/Expires.scala
@@ -40,4 +40,6 @@ final case class Expires(expirationDate: HttpDate) extends Header.Parsed {
   val key = `Expires`
   override val value = Renderer.renderString(expirationDate)
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Forwarded.scala b/core/src/main/scala/org/http4s/headers/Forwarded.scala
index 0aa6dc63193..13d416136ca 100644
--- a/core/src/main/scala/org/http4s/headers/Forwarded.scala
+++ b/core/src/main/scala/org/http4s/headers/Forwarded.scala
@@ -204,4 +204,6 @@ final case class Forwarded(values: NonEmptyList[Forwarded.Element])
 
   def apply(firstElem: Forwarded.Element, otherElems: Forwarded.Element*): Forwarded =
     Forwarded(NonEmptyList.of(firstElem, otherElems: _*))
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Host.scala b/core/src/main/scala/org/http4s/headers/Host.scala
index 73cbbc518f6..31649f82b26 100644
--- a/core/src/main/scala/org/http4s/headers/Host.scala
+++ b/core/src/main/scala/org/http4s/headers/Host.scala
@@ -46,4 +46,6 @@ final case class Host(host: String, port: Option[Int] = None) extends Header.Par
     if (port.isDefined) writer << ':' << port.get
     writer
   }
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/If-Match.scala b/core/src/main/scala/org/http4s/headers/If-Match.scala
index 1481b25616a..ca8fd9f4a03 100644
--- a/core/src/main/scala/org/http4s/headers/If-Match.scala
+++ b/core/src/main/scala/org/http4s/headers/If-Match.scala
@@ -47,4 +47,6 @@ final case class `If-Match`(tags: Option[NonEmptyList[ETag.EntityTag]]) extends
       case Some(tags) => tags.mkString_("", ",", "")
     }
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/If-Modified-Since.scala b/core/src/main/scala/org/http4s/headers/If-Modified-Since.scala
index 0dc5ee0d59a..2f8e330a1a8 100644
--- a/core/src/main/scala/org/http4s/headers/If-Modified-Since.scala
+++ b/core/src/main/scala/org/http4s/headers/If-Modified-Since.scala
@@ -39,4 +39,6 @@ final case class `If-Modified-Since`(date: HttpDate) extends Header.Parsed {
   override def key: `If-Modified-Since`.type = `If-Modified-Since`
   override def value: String = Renderer.renderString(date)
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/If-None-Match.scala b/core/src/main/scala/org/http4s/headers/If-None-Match.scala
index 3cf5c43dfbc..aaf9dd4db59 100644
--- a/core/src/main/scala/org/http4s/headers/If-None-Match.scala
+++ b/core/src/main/scala/org/http4s/headers/If-None-Match.scala
@@ -52,4 +52,6 @@ final case class `If-None-Match`(tags: Option[NonEmptyList[ETag.EntityTag]]) ext
       case Some(tags) => tags.mkString_("", ",", "")
     }
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/If-Unmodified-Since.scala b/core/src/main/scala/org/http4s/headers/If-Unmodified-Since.scala
index 895118ec086..a4fff1772db 100644
--- a/core/src/main/scala/org/http4s/headers/If-Unmodified-Since.scala
+++ b/core/src/main/scala/org/http4s/headers/If-Unmodified-Since.scala
@@ -31,4 +31,6 @@ final case class `If-Unmodified-Since`(date: HttpDate) extends Header.Parsed {
   override def key: `If-Unmodified-Since`.type = `If-Unmodified-Since`
   override def value: String = Renderer.renderString(date)
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Last-Event-Id.scala b/core/src/main/scala/org/http4s/headers/Last-Event-Id.scala
index d008110e570..f6bb5007051 100644
--- a/core/src/main/scala/org/http4s/headers/Last-Event-Id.scala
+++ b/core/src/main/scala/org/http4s/headers/Last-Event-Id.scala
@@ -26,6 +26,8 @@ final case class `Last-Event-Id`(id: EventId) extends Header.Parsed {
   override def key: http4s.headers.`Last-Event-Id`.type = `Last-Event-Id`
   override def renderValue(writer: Writer): writer.type =
     writer.append(id.value)
+
+  override def isNameValid: Boolean = true
 }
 
 object `Last-Event-Id` extends HeaderKey.Internal[`Last-Event-Id`] with HeaderKey.Singleton {
diff --git a/core/src/main/scala/org/http4s/headers/Last-Modified.scala b/core/src/main/scala/org/http4s/headers/Last-Modified.scala
index c221f0e6fbc..7003f89df49 100644
--- a/core/src/main/scala/org/http4s/headers/Last-Modified.scala
+++ b/core/src/main/scala/org/http4s/headers/Last-Modified.scala
@@ -34,4 +34,6 @@ final case class `Last-Modified`(date: HttpDate) extends Header.Parsed {
   override def key: `Last-Modified`.type = `Last-Modified`
   override def value: String = Renderer.renderString(date)
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Link.scala b/core/src/main/scala/org/http4s/headers/Link.scala
index f3bdb74be29..274b8850b15 100644
--- a/core/src/main/scala/org/http4s/headers/Link.scala
+++ b/core/src/main/scala/org/http4s/headers/Link.scala
@@ -28,4 +28,6 @@ object Link extends HeaderKey.Internal[Link] with HeaderKey.Recurring {
 final case class Link(values: NonEmptyList[LinkValue]) extends Header.RecurringRenderable {
   override def key: Link.type = Link
   type Value = LinkValue
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Location.scala b/core/src/main/scala/org/http4s/headers/Location.scala
index 982911720fa..49bb3ab5998 100644
--- a/core/src/main/scala/org/http4s/headers/Location.scala
+++ b/core/src/main/scala/org/http4s/headers/Location.scala
@@ -29,4 +29,6 @@ final case class Location(uri: Uri) extends Header.Parsed {
   def key: `Location`.type = `Location`
   override def value: String = uri.toString
   def renderValue(writer: Writer): writer.type = writer << uri.toString
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Origin.scala b/core/src/main/scala/org/http4s/headers/Origin.scala
index 0a3cd266e6f..c6a00195a8f 100644
--- a/core/src/main/scala/org/http4s/headers/Origin.scala
+++ b/core/src/main/scala/org/http4s/headers/Origin.scala
@@ -24,6 +24,8 @@ import org.http4s.util.{Renderable, Writer}
 sealed abstract class Origin extends Header.Parsed {
   def key: Origin.type =
     Origin
+
+  override def isNameValid: Boolean = true
 }
 
 object Origin extends HeaderKey.Internal[Origin] with HeaderKey.Singleton {
diff --git a/core/src/main/scala/org/http4s/headers/Proxy-Authenticate.scala b/core/src/main/scala/org/http4s/headers/Proxy-Authenticate.scala
index 1ffa53b9a06..22d6c3a5406 100644
--- a/core/src/main/scala/org/http4s/headers/Proxy-Authenticate.scala
+++ b/core/src/main/scala/org/http4s/headers/Proxy-Authenticate.scala
@@ -38,4 +38,6 @@ final case class `Proxy-Authenticate`(values: NonEmptyList[Challenge])
     extends Header.RecurringRenderable {
   override def key: `Proxy-Authenticate`.type = `Proxy-Authenticate`
   type Value = Challenge
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Range.scala b/core/src/main/scala/org/http4s/headers/Range.scala
index a2f10598897..2939f29fdc2 100644
--- a/core/src/main/scala/org/http4s/headers/Range.scala
+++ b/core/src/main/scala/org/http4s/headers/Range.scala
@@ -60,4 +60,6 @@ final case class Range(unit: RangeUnit, ranges: NonEmptyList[Range.SubRange])
     ranges.tail.foreach(writer << ',' << _)
     writer
   }
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Referer.scala b/core/src/main/scala/org/http4s/headers/Referer.scala
index 216b2605f85..b40239c156e 100644
--- a/core/src/main/scala/org/http4s/headers/Referer.scala
+++ b/core/src/main/scala/org/http4s/headers/Referer.scala
@@ -28,4 +28,6 @@ object Referer extends HeaderKey.Internal[Referer] with HeaderKey.Singleton {
 final case class Referer(uri: Uri) extends Header.Parsed {
   override def key: `Referer`.type = `Referer`
   override def renderValue(writer: Writer): writer.type = uri.render(writer)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Retry-After.scala b/core/src/main/scala/org/http4s/headers/Retry-After.scala
index d8dec6cd024..6c366161fbf 100644
--- a/core/src/main/scala/org/http4s/headers/Retry-After.scala
+++ b/core/src/main/scala/org/http4s/headers/Retry-After.scala
@@ -56,4 +56,6 @@ sealed abstract case class `Retry-After`(retry: Either[HttpDate, Long]) extends
   val key = `Retry-After`
   override val value = Renderer.renderString(retry)
   override def renderValue(writer: Writer): writer.type = writer.append(value)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Set-Cookie.scala b/core/src/main/scala/org/http4s/headers/Set-Cookie.scala
index a8066833599..2ead9f463a4 100644
--- a/core/src/main/scala/org/http4s/headers/Set-Cookie.scala
+++ b/core/src/main/scala/org/http4s/headers/Set-Cookie.scala
@@ -41,4 +41,6 @@ object `Set-Cookie` extends HeaderKey.Internal[`Set-Cookie`] {
 final case class `Set-Cookie`(cookie: ResponseCookie) extends Header.Parsed {
   override def key: `Set-Cookie`.type = `Set-Cookie`
   override def renderValue(writer: Writer): writer.type = cookie.render(writer)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Strict-Transport-Security.scala b/core/src/main/scala/org/http4s/headers/Strict-Transport-Security.scala
index d85cce04c0a..d497e340a52 100644
--- a/core/src/main/scala/org/http4s/headers/Strict-Transport-Security.scala
+++ b/core/src/main/scala/org/http4s/headers/Strict-Transport-Security.scala
@@ -84,4 +84,6 @@ sealed abstract case class `Strict-Transport-Security`(
       this.maxAge,
       this.includeSubDomains,
       preload)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/Transfer-Encoding.scala b/core/src/main/scala/org/http4s/headers/Transfer-Encoding.scala
index 3539cd33bbb..c8e5052356b 100644
--- a/core/src/main/scala/org/http4s/headers/Transfer-Encoding.scala
+++ b/core/src/main/scala/org/http4s/headers/Transfer-Encoding.scala
@@ -33,4 +33,6 @@ final case class `Transfer-Encoding`(values: NonEmptyList[TransferCoding])
   override def key: `Transfer-Encoding`.type = `Transfer-Encoding`
   def hasChunked: Boolean = values.exists(_ === TransferCoding.chunked)
   type Value = TransferCoding
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/User-Agent.scala b/core/src/main/scala/org/http4s/headers/User-Agent.scala
index 85f8a3c341c..43d66cd4adb 100644
--- a/core/src/main/scala/org/http4s/headers/User-Agent.scala
+++ b/core/src/main/scala/org/http4s/headers/User-Agent.scala
@@ -53,4 +53,6 @@ final case class `User-Agent`(product: AgentProduct, other: List[AgentToken] = N
     }
     writer
   }
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/WWW-Authenticate.scala b/core/src/main/scala/org/http4s/headers/WWW-Authenticate.scala
index 5624972bcf9..b6ef2737a84 100644
--- a/core/src/main/scala/org/http4s/headers/WWW-Authenticate.scala
+++ b/core/src/main/scala/org/http4s/headers/WWW-Authenticate.scala
@@ -29,4 +29,6 @@ final case class `WWW-Authenticate`(values: NonEmptyList[Challenge])
     extends Header.RecurringRenderable {
   override def key: `WWW-Authenticate`.type = `WWW-Authenticate`
   type Value = Challenge
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/X-B3-Flags.scala b/core/src/main/scala/org/http4s/headers/X-B3-Flags.scala
index 57b0f1c3b8f..2084c7de22e 100644
--- a/core/src/main/scala/org/http4s/headers/X-B3-Flags.scala
+++ b/core/src/main/scala/org/http4s/headers/X-B3-Flags.scala
@@ -65,4 +65,6 @@ final case class `X-B3-Flags`(flags: Set[`X-B3-Flags`.Flag]) extends Header.Pars
 
   override def renderValue(writer: Writer): writer.type =
     writer.append(flags.foldLeft(0L)((sum, next) => sum + next.longValue).toString)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/X-B3-ParentSpanId.scala b/core/src/main/scala/org/http4s/headers/X-B3-ParentSpanId.scala
index d6f62ea1d56..6fc418b0efb 100644
--- a/core/src/main/scala/org/http4s/headers/X-B3-ParentSpanId.scala
+++ b/core/src/main/scala/org/http4s/headers/X-B3-ParentSpanId.scala
@@ -32,4 +32,6 @@ final case class `X-B3-ParentSpanId`(id: Long) extends Header.Parsed {
 
   override def renderValue(writer: Writer): writer.type =
     xB3RenderValueImpl(writer, id)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/X-B3-Sampled.scala b/core/src/main/scala/org/http4s/headers/X-B3-Sampled.scala
index 5427d66f7b0..3229e69a75d 100644
--- a/core/src/main/scala/org/http4s/headers/X-B3-Sampled.scala
+++ b/core/src/main/scala/org/http4s/headers/X-B3-Sampled.scala
@@ -32,4 +32,6 @@ final case class `X-B3-Sampled`(sampled: Boolean) extends Header.Parsed {
     val b: String = if (sampled) "1" else "0"
     writer.append(b)
   }
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/X-B3-SpanId.scala b/core/src/main/scala/org/http4s/headers/X-B3-SpanId.scala
index c1e1ee057a2..e357f12766c 100644
--- a/core/src/main/scala/org/http4s/headers/X-B3-SpanId.scala
+++ b/core/src/main/scala/org/http4s/headers/X-B3-SpanId.scala
@@ -30,4 +30,6 @@ final case class `X-B3-SpanId`(id: Long) extends Header.Parsed {
 
   override def renderValue(writer: Writer): writer.type =
     xB3RenderValueImpl(writer, id)
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/X-B3-TraceId.scala b/core/src/main/scala/org/http4s/headers/X-B3-TraceId.scala
index dbaea813769..60d0972078e 100644
--- a/core/src/main/scala/org/http4s/headers/X-B3-TraceId.scala
+++ b/core/src/main/scala/org/http4s/headers/X-B3-TraceId.scala
@@ -35,4 +35,6 @@ final case class `X-B3-TraceId`(idMostSigBits: Long, idLeastSigBits: Option[Long
     xB3RenderValueImpl(writer, idMostSigBits, idLeastSigBits)
 
   def asUUID: UUID = new UUID(idMostSigBits, idLeastSigBits.getOrElse(0L))
+
+  override def isNameValid: Boolean = true
 }
diff --git a/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala b/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
index d599006db57..1b94fdac737 100644
--- a/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
+++ b/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
@@ -44,4 +44,6 @@ final case class `X-Forwarded-For`(values: NonEmptyList[Option[InetAddress]])
     if (add.isDefined) w.append(add.get.getHostAddress)
     else w.append("unknown")
   }
+
+  override def isNameValid: Boolean = true
 }

From 8ce1de3cb2ec041eeb847c6b0002aeb2e07a194b Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Thu, 16 Sep 2021 14:13:50 -0400
Subject: [PATCH 14/25] sanitizedValue is not necessary

---
 core/src/main/scala/org/http4s/Header.scala | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/core/src/main/scala/org/http4s/Header.scala b/core/src/main/scala/org/http4s/Header.scala
index 06968658dc8..a728eb74a71 100644
--- a/core/src/main/scala/org/http4s/Header.scala
+++ b/core/src/main/scala/org/http4s/Header.scala
@@ -41,11 +41,6 @@ sealed trait Header extends Renderable with Product {
     renderValue(w).result
   }
 
-  final def sanitizedValue: String = {
-    val w = new StringWriter
-    w.sanitize(renderValue(_)).result
-  }
-
   def is(key: HeaderKey): Boolean = key.matchHeader(this).isDefined
 
   def isNot(key: HeaderKey): Boolean = !is(key)

From f3e2b46867c5ba460e98626765b846fccd4d456a Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Thu, 16 Sep 2021 14:17:17 -0400
Subject: [PATCH 15/25] Fix Ember field-value sanitization test

---
 .../scala/org/http4s/ember/core/ResponseSplittingSuite.scala  | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala b/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala
index b809ad370ff..4f34435f504 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/ResponseSplittingSuite.scala
@@ -54,7 +54,9 @@ class ResponseSplittingSuite extends Http4sSuite {
 
   test("Prevent response splitting attacks on field value") {
     val app = HttpApp[IO] { req =>
-      Response(Status.NoContent).putHeaders(Header(req.params("fieldValue"), "oops")).pure[IO]
+      Response[IO](Status.NoContent)
+        .putHeaders(Header("X-Oops", req.params("fieldValue")))
+        .pure[IO]
     }
     val req = Request[IO](uri = uri"/?fieldValue=%0D%0AEvil:true%0D%0A")
     attack(app, req).map { resp =>

From 6156bc56d1b85ca3bb4197e177855204c76a67e1 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Thu, 16 Sep 2021 14:26:49 -0400
Subject: [PATCH 16/25] Drop headers with invalid names in Ember request
 encoder

---
 .../src/main/scala/org/http4s/ember/core/Encoder.scala | 10 ++++++----
 .../org/http4s/ember/core/RequestSplittingSuite.scala  | 10 ++++++++++
 2 files changed, 16 insertions(+), 4 deletions(-)

diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
index 846dac26321..dba3d1a6ed1 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
@@ -120,10 +120,12 @@ private[ember] object Encoder {
           if (h.is(`Content-Length`)) appliedContentLength = true
           else ()
 
-          stringBuilder
-            .append(h.renderString)
-            .append(CRLF)
-          ()
+          if (h.isNameValid) {
+            stringBuilder
+              .append(h.renderString)
+              .append(CRLF)
+            ()
+          }
         }
 
         if (!chunked && !appliedContentLength && !NoPayloadMethods.contains(req.method)) {
diff --git a/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala b/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala
index 27ee0c139d1..bcf564f072d 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/RequestSplittingSuite.scala
@@ -50,4 +50,14 @@ class RequestSplittingSuite extends Http4sSuite {
       path = "/"))
     attack(req).intercept[IllegalArgumentException]
   }
+
+  test("Prevent request splitting attacks on field name") {
+    val req = Request[IO]().putHeaders(Header.Raw("Fine:\r\nEvil:true\r\n".ci, "oops"))
+    attack(req).map(_.status).assertEquals(Status.Ok)
+  }
+
+  test("Prevent request splitting attacks on field value") {
+    val req = Request[IO]().putHeaders(Header.Raw("X-Carrier".ci, "\r\nEvil:true\r\n"))
+    attack(req).map(_.status).assertEquals(Status.Ok)
+  }
 }

From dd0b730fa013cfbdc6450f2c086c0fd3aa989c7a Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Thu, 16 Sep 2021 15:56:49 -0400
Subject: [PATCH 17/25] Drop headers with invalid names in Jetty client

---
 .../client/ClientRouteTestBattery.scala       | 20 +++++++++++++------
 .../org/http4s/client/jetty/JettyClient.scala |  3 ++-
 2 files changed, 16 insertions(+), 7 deletions(-)

diff --git a/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala b/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
index e6b66373bc7..efdca97863b 100644
--- a/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
+++ b/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
@@ -25,6 +25,7 @@ import javax.servlet.http.{HttpServlet, HttpServletRequest, HttpServletResponse}
 import org.http4s.client.testroutes.GetRoutes
 import org.http4s.client.dsl.Http4sClientDsl
 import org.http4s.dsl.io._
+import org.http4s.implicits._
 import org.http4s.multipart.{Multipart, Part}
 import scala.concurrent.duration._
 import java.util.Arrays
@@ -142,12 +143,19 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
 
   test("Mitigates request splitting attack in URI RegName") {
     val address = jetty().addresses.head
-    val name = address.getHostName
-    val port = address.getPort
-    val req = Request[IO](uri = Uri(
-      authority =
-        Uri.Authority(None, Uri.RegName(s"${name}\r\nEvil:true\r\n"), port = port.some).some,
-      path = "/request-splitting"))
+    val req = Request[IO](
+      uri =
+        Uri.fromString(s"http://${address.getHostName}:${address.getPort}/request-splitting").yolo)
+      .putHeaders(Header.Raw("Fine:\r\nEvil:true\r\n".ci, "oops"))
+    client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
+  }
+
+  test("Mitigates request splitting attack in field name") {
+    val address = jetty().addresses.head
+    val req = Request[IO](
+      uri =
+        Uri.fromString(s"http://${address.getHostName}:${address.getPort}/request-splitting").yolo)
+      .putHeaders(Header.Raw("X-Carrier".ci, "\r\nEvil:true\r\n"))
     client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
   }
 
diff --git a/jetty-client/src/main/scala/org/http4s/client/jetty/JettyClient.scala b/jetty-client/src/main/scala/org/http4s/client/jetty/JettyClient.scala
index bf8fb358ef3..242abdf7a69 100644
--- a/jetty-client/src/main/scala/org/http4s/client/jetty/JettyClient.scala
+++ b/jetty-client/src/main/scala/org/http4s/client/jetty/JettyClient.scala
@@ -90,7 +90,8 @@ object JettyClient {
         }
       )
 
-    for (h <- request.headers.toList) jReq.header(h.name.toString, h.value)
+    for (h <- request.headers.toList if h.isNameValid)
+      jReq.header(h.name.toString, h.value)
     jReq.content(dcp)
   }
 }

From 39bbc63082207edcebaa0443e190b0de62b8dde4 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 17 Sep 2021 09:09:38 -0400
Subject: [PATCH 18/25] Fix ClientRouteTestBattery

---
 .../org/http4s/client/ClientRouteTestBattery.scala  | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala b/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
index efdca97863b..6acfcbbdbc1 100644
--- a/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
+++ b/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
@@ -142,6 +142,17 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
   }
 
   test("Mitigates request splitting attack in URI RegName") {
+    val address = jetty().addresses.head
+    val name = address.getHostName
+    val port = address.getPort
+    val req = Request[IO](uri = Uri(
+      authority =
+        Uri.Authority(None, Uri.RegName(s"${name}\r\nEvil:true\r\n"), port = port.some).some,
+      path = "/request-splitting"))
+    client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
+  }
+
+  test("Mitigates request splitting attack in field name") {
     val address = jetty().addresses.head
     val req = Request[IO](
       uri =
@@ -150,7 +161,7 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
     client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
   }
 
-  test("Mitigates request splitting attack in field name") {
+  test("Mitigates request splitting attack in field value") {
     val address = jetty().addresses.head
     val req = Request[IO](
       uri =

From f26f7454d8821af50af06f9c21518ef711e78bed Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 17 Sep 2021 14:16:49 -0400
Subject: [PATCH 19/25] Fix cross builds

---
 .../scala/org/http4s/client/ClientRouteTestBattery.scala  | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala b/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
index 6acfcbbdbc1..fc64a5f2ec7 100644
--- a/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
+++ b/client/src/test/scala/org/http4s/client/ClientRouteTestBattery.scala
@@ -138,7 +138,7 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
       uri = Uri(
         authority = Uri.Authority(None, Uri.RegName(name), port = port.some).some,
         path = "/request-splitting HTTP/1.0\r\nEvil:true\r\nHide-Protocol-Version:"))
-    client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
+    client().status(req).handleError(_ => Status.Ok).assertEquals(Status.Ok)
   }
 
   test("Mitigates request splitting attack in URI RegName") {
@@ -149,7 +149,7 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
       authority =
         Uri.Authority(None, Uri.RegName(s"${name}\r\nEvil:true\r\n"), port = port.some).some,
       path = "/request-splitting"))
-    client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
+    client().status(req).handleError(_ => Status.Ok).assertEquals(Status.Ok)
   }
 
   test("Mitigates request splitting attack in field name") {
@@ -158,7 +158,7 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
       uri =
         Uri.fromString(s"http://${address.getHostName}:${address.getPort}/request-splitting").yolo)
       .putHeaders(Header.Raw("Fine:\r\nEvil:true\r\n".ci, "oops"))
-    client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
+    client().status(req).handleError(_ => Status.Ok).assertEquals(Status.Ok)
   }
 
   test("Mitigates request splitting attack in field value") {
@@ -167,7 +167,7 @@ abstract class ClientRouteTestBattery(name: String) extends Http4sSuite with Htt
       uri =
         Uri.fromString(s"http://${address.getHostName}:${address.getPort}/request-splitting").yolo)
       .putHeaders(Header.Raw("X-Carrier".ci, "\r\nEvil:true\r\n"))
-    client().status(req).recover(_ => Status.Ok).assertEquals(Status.Ok)
+    client().status(req).handleError(_ => Status.Ok).assertEquals(Status.Ok)
   }
 
   private def checkResponse(rec: Response[IO], expected: Response[IO]): IO[Boolean] = {

From 456d511b7f0a43c4f0d134ec5278fa38066422b8 Mon Sep 17 00:00:00 2001
From: Scala Steward <me@scala-steward.org>
Date: Sun, 19 Sep 2021 08:21:01 +0200
Subject: [PATCH 20/25] Update keypool to 0.4.7

---
 project/Http4sPlugin.scala | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/project/Http4sPlugin.scala b/project/Http4sPlugin.scala
index 494b37a46ab..9ce6ecfd3c5 100644
--- a/project/Http4sPlugin.scala
+++ b/project/Http4sPlugin.scala
@@ -297,7 +297,7 @@ object Http4sPlugin extends AutoPlugin {
     val jawn = "1.2.0"
     val jawnFs2 = "2.1.0"
     val jetty = "9.4.43.v20210629"
-    val keypool = "0.4.6"
+    val keypool = "0.4.7"
     val literally = "1.0.2"
     val logback = "1.2.5"
     val log4cats = "2.1.1"

From 2f399c67b9f28ead7130a8203f54da21c04771db Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Sun, 19 Sep 2021 09:50:41 -0400
Subject: [PATCH 21/25] Fix keypool deprecation

---
 .../scala/org/http4s/ember/client/EmberClientBuilder.scala   | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
index 821602e7d0d..c9f2a479c4e 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
@@ -127,7 +127,7 @@ final class EmberClientBuilder[F[_]: Async] private (
       tlsContextOptWithDefault <- Resource.eval(
         tlsContextOpt.fold(Network[F].tlsContext.system.attempt.map(_.toOption))(_.some.pure[F]))
       builder =
-        KeyPoolBuilder
+        KeyPool.Builder
           .apply[F, RequestKey, EmberConnection[F]](
             (requestKey: RequestKey) =>
               EmberConnection(
@@ -139,11 +139,10 @@ final class EmberClientBuilder[F[_]: Async] private (
                     sg,
                     additionalSocketOptions
                   )) <* logger.trace(s"Created Connection - RequestKey: ${requestKey}"),
-            { case connection =>
+            (connection: EmberConnection[F]) =>
               logger.trace(
                 s"Shutting Down Connection - RequestKey: ${connection.keySocket.requestKey}") >>
                 connection.cleanup
-            }
           )
           .withDefaultReuseState(Reusable.DontReuse)
           .withIdleTimeAllowedInPool(idleTimeInPool)

From 6434074d59e1bd762507e2a135b21236deee9a44 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 20 Sep 2021 09:09:53 -0400
Subject: [PATCH 22/25] Remove unused import

---
 .../scala/org/http4s/laws/discipline/ArbitraryInstances.scala    | 1 -
 1 file changed, 1 deletion(-)

diff --git a/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala b/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
index 81ea1b55291..c6734cd5f35 100644
--- a/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
+++ b/laws/src/main/scala/org/http4s/laws/discipline/ArbitraryInstances.scala
@@ -35,7 +35,6 @@ import java.time._
 import java.util.Locale
 import org.http4s.headers._
 import org.http4s.internal.CollectionCompat.CollectionConverters._
-import org.http4s.laws.discipline.ArbitraryInstances.genAlphaToken
 import org.http4s.syntax.literals._
 import org.scalacheck._
 import org.scalacheck.Arbitrary.{arbitrary => getArbitrary}

From fee82a4bbc6dc634a46997ee5361ed84fa147873 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 20 Sep 2021 12:39:39 -0400
Subject: [PATCH 23/25] Add endpoint for request-splitting tests

---
 scripts/scaffold_server.js | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/scripts/scaffold_server.js b/scripts/scaffold_server.js
index f04b0b6413f..4eebdca2620 100755
--- a/scripts/scaffold_server.js
+++ b/scripts/scaffold_server.js
@@ -52,6 +52,10 @@ http.createServer(async (req, res) => {
         res.statusCode = 500;
         res.end();
         break;
+      case '/request-splitting':
+        res.statusCode = req.headers['Evil'] ? 500 : 200;
+        res.end();
+        break;
       default:
         res.statusCode = 404;
         res.end();

From 7e35f79375624f8e9eaa64308e215145b03257ee Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 20 Sep 2021 13:55:36 -0400
Subject: [PATCH 24/25] Add more generous endpoint for request-splitting tests

---
 scripts/scaffold_server.js | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/scripts/scaffold_server.js b/scripts/scaffold_server.js
index 4eebdca2620..2bdcc8b3e98 100755
--- a/scripts/scaffold_server.js
+++ b/scripts/scaffold_server.js
@@ -52,13 +52,15 @@ http.createServer(async (req, res) => {
         res.statusCode = 500;
         res.end();
         break;
-      case '/request-splitting':
-        res.statusCode = req.headers['Evil'] ? 500 : 200;
-        res.end();
-        break;
       default:
-        res.statusCode = 404;
+        if (req.url.startsWith('/request-splitting')) {
+          res.statusCode = req.headers['Evil'] ? 500 : 200;
+        }
+        else {
+          res.statusCode = 404;
+        }
         res.end();
+        break;
     }
   } else if (req.method === 'POST') {
     req.on('data', (chunk) => {

From 6dd04b5bb121a4f85f8242d74a80514b112990f1 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 20 Sep 2021 16:38:01 -0400
Subject: [PATCH 25/25] Duplicate the /request-splitting endpoint for Ember

---
 .../org/http4s/server/ServerRouteTestBattery.scala     | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/server-testing/src/test/scala/org/http4s/server/ServerRouteTestBattery.scala b/server-testing/src/test/scala/org/http4s/server/ServerRouteTestBattery.scala
index 41ba0b4d04f..1c4b930e245 100644
--- a/server-testing/src/test/scala/org/http4s/server/ServerRouteTestBattery.scala
+++ b/server-testing/src/test/scala/org/http4s/server/ServerRouteTestBattery.scala
@@ -18,12 +18,14 @@ package org.http4s.server
 
 import cats.effect.IO
 import cats.effect.kernel.Resource
+import cats.syntax.all._
 import org.http4s.HttpApp
 import org.http4s.Method
 import org.http4s.Response
 import org.http4s.Status
 import org.http4s.client.ClientRouteTestBattery
 import org.http4s.client.testroutes.GetRoutes
+import org.typelevel.ci._
 
 abstract class ServerRouteTestBattery(name: String) extends ClientRouteTestBattery(name) {
 
@@ -38,7 +40,13 @@ object ServerRouteTestBattery {
 
   val App: HttpApp[IO] = HttpApp[IO] { request =>
     val get = Some(request).filter(_.method == Method.GET).flatMap { r =>
-      GetRoutes.getPaths.get(r.uri.path.toString)
+      r.uri.path.toString match {
+        case p if p.startsWith("/request-splitting") =>
+          if (r.headers.get(ci"Evil").isDefined) IO(Response[IO](Status.InternalServerError)).some
+          else IO(Response[IO](Status.Ok)).some
+        case p =>
+          GetRoutes.getPaths.get(r.uri.path.toString)
+      }
     }
 
     val post = Some(request).filter(_.method == Method.POST).map { r =>
