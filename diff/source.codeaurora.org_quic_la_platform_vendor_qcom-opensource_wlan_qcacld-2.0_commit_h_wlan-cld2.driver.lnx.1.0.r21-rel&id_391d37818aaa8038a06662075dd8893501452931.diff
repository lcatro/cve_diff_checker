From 391d37818aaa8038a06662075dd8893501452931 Mon Sep 17 00:00:00 2001
From: Zhang Qian <zhangq@codeaurora.org>
Date: Wed, 23 May 2018 13:46:22 +0800
Subject: qcacld-2.0: use hdd request manager for ocb set config

Change hdd_ocb_set_config_req to hdd request manager framework.

Change-Id: I57e327e61943f0754dd1b0db7e129ebb39be4f80
CRs-Fixed: 2230058
---
 CORE/HDD/inc/wlan_hdd_main.h |   1 -
 CORE/HDD/src/wlan_hdd_ocb.c  | 163 +++++++++++++++++++++++--------------------
 2 files changed, 87 insertions(+), 77 deletions(-)

diff --git a/CORE/HDD/inc/wlan_hdd_main.h b/CORE/HDD/inc/wlan_hdd_main.h
index dfad4de..b985b01 100644
--- a/CORE/HDD/inc/wlan_hdd_main.h
+++ b/CORE/HDD/inc/wlan_hdd_main.h
@@ -1417,7 +1417,6 @@ struct hdd_adapter_s
     v_TIME_t startRocTs;
 
     /* State for synchronous OCB requests to WMI */
-    struct sir_ocb_set_config_response ocb_set_config_resp;
     struct sir_dcc_update_ndl_response dcc_update_ndl_resp;
     struct dsrc_radio_chan_stats_ctxt dsrc_chan_stats;
 #ifdef WLAN_FEATURE_DSRC
diff --git a/CORE/HDD/src/wlan_hdd_ocb.c b/CORE/HDD/src/wlan_hdd_ocb.c
index dbb2d37..2019cc5 100644
--- a/CORE/HDD/src/wlan_hdd_ocb.c
+++ b/CORE/HDD/src/wlan_hdd_ocb.c
@@ -429,7 +429,7 @@ struct sir_ocb_config *hdd_ocb_config_new(uint32_t num_channels,
 					  uint32_t ndl_active_state_list_len)
 {
 	struct sir_ocb_config *ret = 0;
-	uint32_t len;
+	size_t len;
 	void *cursor;
 
 	if (num_channels > CFG_TGT_NUM_OCB_CHANNELS ||
@@ -472,6 +472,26 @@ fail:
 }
 
 /**
+ * hdd_ocb_set_config_priv - private parameter for ocb set config
+ * @status: status of set config
+ */
+struct hdd_ocb_set_config_priv {
+	int status;
+};
+
+/**
+ * enum ocb_channel_config_status - ocb config status
+ * @OCB_CHANNEL_CONFIG_SUCCESS: success
+ * @OCB_CHANNEL_CONFIG_FAIL: failure
+ * @OCB_CHANNEL_CONFIG_STATUS_MAX: place holder, not a real status
+ */
+enum ocb_channel_config_status {
+	OCB_CHANNEL_CONFIG_SUCCESS = 0,
+	OCB_CHANNEL_CONFIG_FAIL,
+	OCB_CHANNEL_CONFIG_STATUS_MAX
+};
+
+/**
  * hdd_ocb_set_config_callback() - OCB set config callback function
  * @context_ptr: OCB call context
  * @response_ptr: Pointer to response structure
@@ -481,46 +501,27 @@ fail:
  */
 static void hdd_ocb_set_config_callback(void *context_ptr, void *response_ptr)
 {
-	struct hdd_ocb_ctxt *context = context_ptr;
-	struct sir_ocb_set_config_response *resp = response_ptr;
+	struct hdd_request *hdd_request;
+	struct hdd_ocb_set_config_priv *priv;
+	struct sir_ocb_set_config_response *response = response_ptr;
 
-	if (!context)
+	hdd_request = hdd_request_get(context_ptr);
+	if (!hdd_request) {
+		hddLog(LOGE, FL("Obsolete request"));
 		return;
+	}
+	priv = hdd_request_priv(hdd_request);
 
-	if (resp && resp->status)
-		hddLog(LOGE, FL("Operation failed: %d"), resp->status);
-
-	spin_lock(&hdd_context_lock);
-	if (context->magic == HDD_OCB_MAGIC) {
-		hdd_adapter_t *adapter = context->adapter;
-		if (!resp) {
-			context->status = -EINVAL;
-			complete(&context->completion_evt);
-			spin_unlock(&hdd_context_lock);
-			return;
-		}
+	if (response && (response->status != OCB_CHANNEL_CONFIG_SUCCESS))
+		hddLog(LOGE, FL("Operation failed: %d"), response->status);
 
-		context->adapter->ocb_set_config_resp = *resp;
-		spin_unlock(&hdd_context_lock);
-		if (!resp->status) {
-			/*
-			 * OCB set config command successful.
-			 * Open the TX data path
-			 */
-			if (!hdd_ocb_register_sta(adapter)) {
-				wlan_hdd_netif_queue_control(adapter,
-					WLAN_START_ALL_NETIF_QUEUE_N_CARRIER,
-					WLAN_CONTROL_PATH);
-			}
-		}
+	if (response && (response->status == OCB_CHANNEL_CONFIG_SUCCESS))
+		priv->status = 0;
+	else
+		priv->status = -EINVAL;
 
-		spin_lock(&hdd_context_lock);
-		if (context->magic == HDD_OCB_MAGIC)
-			complete(&context->completion_evt);
-		spin_unlock(&hdd_context_lock);
-	} else {
-		spin_unlock(&hdd_context_lock);
-	}
+	hdd_request_complete(hdd_request);
+	hdd_request_put(hdd_request);
 }
 
 /**
@@ -536,8 +537,14 @@ static int hdd_ocb_set_config_req(hdd_adapter_t *adapter,
 	int i, rc;
 	eHalStatus halStatus;
 	bool enable_chan_stats;
-	struct hdd_ocb_ctxt context = {0};
 	struct dsrc_radio_chan_stats_ctxt *ctx;
+	void *cookie;
+	struct hdd_request *hdd_request;
+	struct hdd_ocb_set_config_priv *priv;
+	static const struct hdd_request_params params = {
+		.priv_size = sizeof(*priv),
+		.timeout_ms = WLAN_WAIT_TIME_OCB_CMD,
+	};
 
 	if (hdd_ocb_validate_config(adapter, config)) {
 		hddLog(LOGE, FL("The configuration is invalid"));
@@ -561,72 +568,76 @@ static int hdd_ocb_set_config_req(hdd_adapter_t *adapter,
 	if (enable_chan_stats)
 		wlan_hdd_dsrc_config_radio_chan_stats(adapter, false);
 
-	init_completion(&context.completion_evt);
-	context.adapter = adapter;
-	context.magic = HDD_OCB_MAGIC;
+	hdd_request = hdd_request_alloc(&params);
+	if (!hdd_request) {
+		hddLog(LOGE, FL("Request allocation failure"));
+		return -ENOMEM;
+	}
+	cookie = hdd_request_cookie(hdd_request);
 
 	hddLog(LOG1, FL("Disabling queues"));
 	wlan_hdd_netif_queue_control(adapter, WLAN_NETIF_TX_DISABLE_N_CARRIER,
 				     WLAN_CONTROL_PATH);
 	/* Call the SME API to set the config */
 	halStatus = sme_ocb_set_config(
-		((hdd_context_t *)adapter->pHddCtx)->hHal, &context,
+		((hdd_context_t *)adapter->pHddCtx)->hHal, cookie,
 		hdd_ocb_set_config_callback, config);
 	if (halStatus != eHAL_STATUS_SUCCESS) {
 		hddLog(LOGE, FL("Error calling SME function."));
 		/* Convert from eHalStatus to errno */
-		return -EINVAL;
+		rc = -EINVAL;
+		goto end;
 	}
 
 	/* Wait for the function to complete. */
-	rc = wait_for_completion_timeout(&context.completion_evt,
-		msecs_to_jiffies(WLAN_WAIT_TIME_OCB_CMD));
-	if (rc == 0) {
-		rc = -ETIMEDOUT;
+	rc = hdd_request_wait_for_response(hdd_request);
+	if (rc) {
+		hddLog(LOGE, FL("Operation timed out"));
 		goto end;
 	}
-	rc = 0;
 
-	if (context.status) {
-		rc = context.status;
+	priv = hdd_request_priv(hdd_request);
+	rc = priv->status;
+	if (rc) {
+		hddLog(LOGE, FL("Operation failed: %d"), rc);
 		goto end;
 	}
 
-	if (adapter->ocb_set_config_resp.status) {
-		rc = -EINVAL;
-		goto end;
-	}
+	/*
+	 * OCB set config command successful.
+	 * Open the TX data path
+	 */
+	if (!hdd_ocb_register_sta(adapter))
+		wlan_hdd_netif_queue_control(adapter,
+					WLAN_START_ALL_NETIF_QUEUE_N_CARRIER,
+					WLAN_CONTROL_PATH);
+	if (enable_chan_stats)
+		wlan_hdd_dsrc_config_radio_chan_stats(adapter, true);
+
+	/*
+	* Net device mtu size is 1500 by default, But for OCB RAW mode,
+	* driver need later convert 802.3 data header to IEEE802.11
+	* data header and EPD header, which will increase total frame
+	* length. In such case, long packet length will exceed the
+	* target credit size. It resulted in that the packet is cut
+	* down, data would be missed and the traffic would be broken.
+	* So decrease the netdev mtu size to work around this issue
+	* in IEEE80211p RAW mode.
+	*/
+	if (config->flags & OCB_CONFIG_FLAG_80211_FRAME_MODE)
+		adapter->dev->mtu = ETH_DATA_LEN - 8;
+	else
+		adapter->dev->mtu = ETH_DATA_LEN;
 
 	/* fall through */
 end:
-	spin_lock(&hdd_context_lock);
-	context.magic = 0;
-	spin_unlock(&hdd_context_lock);
 	if (rc) {
-		hddLog(LOGE, FL("Operation failed: %d"), rc);
-
 		/* Flush already saved configured channel frequence */
 		ctx->config_chans_num = 0;
 		vos_mem_zero(ctx->config_chans_freq, 2 * sizeof(uint32_t));
-	} else {
-		if (enable_chan_stats)
-			wlan_hdd_dsrc_config_radio_chan_stats(adapter, true);
-
-		/*
-		 * Net device mtu size is 1500 by default, But for OCB RAW mode,
-		 * driver need later convert 802.3 data header to IEEE802.11
-		 * data header and EPD header, which will increase total frame
-		 * length. In such case, long packet length will exceed the
-		 * target credit size. It resulted in that the packet is cut
-		 * down, data would be missed and the traffic would be broken.
-		 * So decrease the netdev mtu size to work around this issue
-		 * in IEEE80211p RAW mode.
-		 */
-		if (config->flags & OCB_CONFIG_FLAG_80211_FRAME_MODE)
-			adapter->dev->mtu = ETH_DATA_LEN - 8;
-		else
-			adapter->dev->mtu = ETH_DATA_LEN;
 	}
+
+	hdd_request_put(hdd_request);
 	return rc;
 }
 
-- 
cgit v1.1

