From becd68bb7be9369999472b8f57c09d8cf459464b Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Fri, 29 Jan 2021 00:54:09 -0600
Subject: [PATCH 01/18] Create a separate acceptor pool on which we can block

---
 .../channel/nio1/NIO1SocketServerGroup.scala  |  37 +++---
 .../blaze/channel/nio1/SelectorLoop.scala     | 109 +++++++++---------
 2 files changed, 79 insertions(+), 67 deletions(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 998d40b6..617fff94 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -47,10 +47,11 @@ object NIO1SocketServerGroup {
     *       shutdown when the group is shutdown.
     */
   def apply(
+      acceptorPool: SelectorLoopPool,
       workerPool: SelectorLoopPool,
       channelOptions: ChannelOptions = ChannelOptions.DefaultOptions
   ): ServerChannelGroup =
-    new NIO1SocketServerGroup(workerPool, channelOptions)
+    new NIO1SocketServerGroup(acceptorPool, workerPool, channelOptions)
 
   /** Create a new [[NIO1SocketServerGroup]] with a fresh [[FixedSelectorPool]]
     *
@@ -61,10 +62,12 @@ object NIO1SocketServerGroup {
       workerThreads: Int = DefaultPoolSize,
       bufferSize: Int = DefaultBufferSize,
       channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
-      selectorThreadFactory: ThreadFactory = defaultAcceptThreadFactory
+      selectorThreadFactory: ThreadFactory = defaultAcceptThreadFactory, // TODO: different names for acceptor and worker?
+      acceptorThreads: Int = 1,
   ): ServerChannelGroup = {
-    val pool = new FixedSelectorPool(workerThreads, bufferSize, selectorThreadFactory)
-    val underlying = apply(pool, channelOptions)
+    val acceptorPool = new FixedSelectorPool(acceptorThreads, 0, selectorThreadFactory)
+    val workerPool = new FixedSelectorPool(workerThreads, bufferSize, selectorThreadFactory)
+    val underlying = apply(acceptorPool, workerPool, channelOptions)
 
     // Proxy to the underlying group. `close` calls also close
     // the worker pools since we were the ones that created it.
@@ -76,7 +79,8 @@ object NIO1SocketServerGroup {
         // shutdown since they cleanup pending tasks before dying
         // themselves.
         underlying.closeGroup()
-        pool.close()
+        workerPool.close()
+        acceptorPool.close()
       }
 
       override def bind(
@@ -90,12 +94,13 @@ object NIO1SocketServerGroup {
 
 /** A thread resource group for NIO1 network operations
   *
-  * @param selectorPool [[SelectorLoopPool]] that will belong to this group. The group
+  * @param workerPool [[SelectorLoopPool]] that will belong to this group. The group
   *                    assumes responsibility for shutting it down. Shutting down the
   *                    pool after giving it to this group will result in undefined behavior.
   */
 private final class NIO1SocketServerGroup private (
-    selectorPool: SelectorLoopPool,
+    acceptorPool: SelectorLoopPool,
+    workerPool: SelectorLoopPool,
     channelOptions: ChannelOptions)
     extends ServerChannelGroup {
   private[this] val logger = getLogger
@@ -118,12 +123,13 @@ private final class NIO1SocketServerGroup private (
     private[this] val closed = new AtomicBoolean(false)
 
     override def opsReady(unused: ByteBuffer): Unit =
-      if (key.isAcceptable)
+      if (key.isAcceptable) {
         try acceptNewConnections()
         catch {
           case ex: IOException =>
             close(Some(ex))
         }
+      }
 
     override def close(cause: Option[Throwable]): Unit =
       if (closed.compareAndSet(false, true) && !ch.channelClosed) {
@@ -143,6 +149,8 @@ private final class NIO1SocketServerGroup private (
 
     @tailrec
     private[this] def acceptNewConnections(): Unit = {
+      // TODO: when connection limiting is enabled, we should block the accept
+
       // We go in a loop just in case we have more than one.
       // Once we're out, the `.accept()` method will return `null`.
       val child = ch.selectableChannel.accept()
@@ -189,9 +197,7 @@ private final class NIO1SocketServerGroup private (
       try
       // We use `enqueueTask` deliberately so as to not jump ahead
       // of channel initialization.
-      selectorLoop.enqueueTask(new Runnable {
-        override def run(): Unit = doClose()
-      })
+      selectorLoop.enqueueTask(() => doClose())
       catch {
         case _: RejectedExecutionException =>
           logger.info("Selector loop closed. Closing in local thread.")
@@ -224,12 +230,13 @@ private final class NIO1SocketServerGroup private (
     Try {
       val ch = ServerSocketChannel.open().bind(address)
       ch.configureBlocking(false)
-      val loop = selectorPool.nextLoop()
+      val loop = acceptorPool.nextLoop()
 
       val serverChannel = new ServerChannelImpl(ch, loop)
       val closed = listeningSet.synchronized {
-        if (isClosed) true
-        else {
+        if (isClosed) {
+          true
+        } else {
           listeningSet += serverChannel
           false
         }
@@ -268,7 +275,7 @@ private final class NIO1SocketServerGroup private (
       channelOptions.applyToChannel(clientChannel)
 
       val address = clientChannel.getRemoteAddress
-      val loop = selectorPool.nextLoop()
+      val loop = workerPool.nextLoop()
       val conn = NIO1Connection(clientChannel)
 
       // From within the selector loop, constructs a pipeline or
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
index 06cd22aa..ae6df561 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
@@ -39,31 +39,6 @@ final class SelectorLoop(
     with ExecutionContext {
   require(bufferSize > 0, s"Invalid buffer size: $bufferSize")
 
-  /** A Runnable that will only execute in this selector loop and provides
-    * access to the `SelectorLoop`s scratch buffer.
-    */
-  abstract class LoopRunnable extends Runnable {
-
-    /** Execute the task with the borrowed scratch `ByteBuffer`
-      *
-      * @param scratch a `ByteBuffer` that is owned by the parent
-      *                `SelectorLoop`, and as such, the executing task
-      *                _must not_ retain a refer to it.
-      */
-    def run(scratch: ByteBuffer): Unit
-
-    final override def run(): Unit = {
-      val currentThread = Thread.currentThread
-      if (currentThread == thread) run(scratch)
-      else {
-        val msg = "Task rejected: executed RunWithScratch in incorrect " +
-          s"thread: $currentThread. Expected thread: $thread."
-        val ex = new IllegalStateException(msg)
-        logger.error(ex)(msg)
-      }
-    }
-  }
-
   @volatile
   private[this] var isClosed = false
   private[this] val scratch = ByteBuffer.allocateDirect(bufferSize)
@@ -127,7 +102,7 @@ final class SelectorLoop(
   override def execute(runnable: Runnable): Unit = enqueueTask(runnable)
 
   override def reportFailure(cause: Throwable): Unit =
-    logger.info(cause)(s"Exception executing task in selector loop $threadName")
+    logger.error(cause)(s"Exception executing task in selector loop $threadName")
 
   /** Initialize a new `Selectable` channel
     *
@@ -141,23 +116,24 @@ final class SelectorLoop(
       ch: NIO1Channel,
       mkStage: SelectionKey => Selectable
   ): Unit =
-    enqueueTask(new Runnable {
-      def run(): Unit =
-        if (!selector.isOpen) ch.close()
-        else
-          try {
-            // We place all this noise in the `try` since pretty
-            // much every method on the `SelectableChannel` can throw.
-            require(!ch.selectableChannel.isBlocking, s"Can only register non-blocking channels")
-            val key = ch.selectableChannel.register(selector, 0)
-            val head = mkStage(key)
-            key.attach(head)
-            logger.debug("Channel initialized.")
-          } catch {
-            case t @ (NonFatal(_) | _: ControlThrowable) =>
-              logger.error(t)("Caught error during channel init.")
-              ch.close()
-          }
+    enqueueTask(() => {
+      if (!selector.isOpen) {
+        ch.close()
+      } else {
+        try {
+          // We place all this noise in the `try` since pretty
+          // much every method on the `SelectableChannel` can throw.
+          require(!ch.selectableChannel.isBlocking, s"Can only register non-blocking channels")
+          val key = ch.selectableChannel.register(selector, 0)
+          val head = mkStage(key)
+          key.attach(head)
+          logger.debug("Channel initialized.")
+        } catch {
+          case t@(NonFatal(_) | _: ControlThrowable) =>
+            logger.error(t)("Caught error during channel init.")
+            ch.close()
+        }
+      }
     })
 
   // Main thread method. The loop will break if the Selector loop is closed
@@ -174,8 +150,9 @@ final class SelectorLoop(
       taskQueue.executeTasks()
 
       // We have some new I/O operations waiting for us. Process them.
-      if (selected > 0)
+      if (selected > 0) {
         processKeys(scratch, selector.selectedKeys)
+      }
     } catch {
       case e: ClosedSelectorException =>
         logger.error(e)("Selector unexpectedly closed")
@@ -202,15 +179,18 @@ final class SelectorLoop(
       it.remove()
 
       val selectable = getAttachment(k)
-      try if (k.isValid)
-        if (selectable != null)
-          selectable.opsReady(scratch)
-        else {
-          k.cancel()
-          logger.error("Illegal state: selector key had null attachment.")
+      try {
+        if (k.isValid) {
+          if (selectable != null) {
+            selectable.opsReady(scratch)
+          } else {
+            k.cancel()
+            logger.error("Illegal state: selector key had null attachment.")
+          }
+        } else if (selectable != null) {
+          selectable.close(None)
         }
-      else if (selectable != null)
-        selectable.close(None)
+      }
       catch {
         case t @ (NonFatal(_) | _: ControlThrowable) =>
           logger.error(t)("Error performing channel operations. Closing channel.")
@@ -256,4 +236,29 @@ final class SelectorLoop(
         logger.error(ex)(ex.getMessage)
         throw ex
     }
+
+  /** A Runnable that will only execute in this selector loop and provides
+    * access to the `SelectorLoop`s scratch buffer.
+    */
+  abstract class LoopRunnable extends Runnable {
+
+    /** Execute the task with the borrowed scratch `ByteBuffer`
+      *
+      * @param scratch a `ByteBuffer` that is owned by the parent
+      *                `SelectorLoop`, and as such, the executing task
+      *                _must not_ retain a refer to it.
+      */
+    def run(scratch: ByteBuffer): Unit
+
+    final override def run(): Unit = {
+      val currentThread = Thread.currentThread
+      if (currentThread == thread) run(scratch)
+      else {
+        val msg = "Task rejected: executed RunWithScratch in incorrect " +
+          s"thread: $currentThread. Expected thread: $thread."
+        val ex = new IllegalStateException(msg)
+        logger.error(ex)(msg)
+      }
+    }
+  }
 }

From da99da552b866dff58a492b0ef828e346fe60abf Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Fri, 29 Jan 2021 21:06:45 -0600
Subject: [PATCH 02/18] pr feedback and max connections handling

---
 .../blaze/channel/nio1/NIO1HeadStage.scala    | 12 ++--
 .../channel/nio1/NIO1SocketServerGroup.scala  | 68 +++++++++++--------
 .../blaze/channel/nio1/SelectorLoop.scala     | 34 +++++-----
 .../org/http4s/blaze/channel/package.scala    |  5 ++
 .../org/http4s/blaze/util/Connections.scala   | 27 ++++++++
 5 files changed, 95 insertions(+), 51 deletions(-)
 create mode 100644 core/src/main/scala/org/http4s/blaze/util/Connections.scala

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
index 7d312646..e6d9e705 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
@@ -10,11 +10,10 @@ import java.io.IOException
 import java.nio.ByteBuffer
 import java.nio.channels._
 import java.util.concurrent.RejectedExecutionException
-
 import org.http4s.blaze.channel.ChannelHead
 import org.http4s.blaze.pipeline.Command.{Disconnected, EOF}
 import org.http4s.blaze.util
-import org.http4s.blaze.util.BufferTools
+import org.http4s.blaze.util.{BufferTools, Connections}
 
 import scala.annotation.tailrec
 import scala.concurrent.{Future, Promise}
@@ -108,7 +107,8 @@ private[nio1] object NIO1HeadStage {
 private[nio1] final class NIO1HeadStage(
     ch: SocketChannel,
     selectorLoop: SelectorLoop,
-    key: SelectionKey
+    key: SelectionKey,
+    connections: Connections
 ) extends ChannelHead
     with Selectable {
   import NIO1HeadStage._
@@ -299,8 +299,10 @@ private[nio1] final class NIO1HeadStage(
       }
 
       writeData = null
-      try ch.close()
-      catch {
+      try {
+        ch.close()
+        connections.release()
+      } catch {
         case ex: IOException =>
           logger.warn(ex)("Unexpected IOException during channel close")
       }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 617fff94..47daa54f 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -12,16 +12,9 @@ import java.net.InetSocketAddress
 import java.nio.ByteBuffer
 import java.util.concurrent.{RejectedExecutionException, ThreadFactory}
 import java.util.concurrent.atomic.{AtomicBoolean, AtomicInteger}
-
-import org.http4s.blaze.channel.{
-  ChannelOptions,
-  DefaultPoolSize,
-  ServerChannel,
-  ServerChannelGroup,
-  SocketPipelineBuilder
-}
+import org.http4s.blaze.channel.{ChannelOptions, DefaultMaxConnections, DefaultPoolSize, ServerChannel, ServerChannelGroup, SocketPipelineBuilder}
 import org.http4s.blaze.pipeline.Command
-import org.http4s.blaze.util.BasicThreadFactory
+import org.http4s.blaze.util.{BasicThreadFactory, Connections}
 import org.log4s._
 
 import scala.annotation.tailrec
@@ -34,11 +27,17 @@ object NIO1SocketServerGroup {
   /** Default size of buffer to use in a [[SelectorLoop]] */
   private[this] val DefaultBufferSize: Int = 64 * 1024
 
-  private[this] val factoryNumber = new AtomicInteger(0)
-  // Default `ThreadFactory` implementation for selector threads
-  private[this] def defaultAcceptThreadFactory: ThreadFactory = {
-    val id = factoryNumber.getAndIncrement()
-    BasicThreadFactory(prefix = s"blaze-selector-$id", daemonThreads = false)
+  private[this] val acceptorNumber = new AtomicInteger(0)
+  private[this] val workerNumber = new AtomicInteger(0)
+
+  private[this] def defaultAcceptorThreadFactory: ThreadFactory = {
+    val id = acceptorNumber.getAndIncrement()
+    BasicThreadFactory(prefix = s"blaze-acceptor-$id", daemonThreads = false)
+  }
+
+  private[this] def defaultWorkerThreadFactory: ThreadFactory = {
+    val id = workerNumber.getAndIncrement()
+    BasicThreadFactory(prefix = s"blaze-worker-$id", daemonThreads = false)
   }
 
   /** Create a new [[NIO1SocketServerGroup]] from the [[SelectorLoopPool]].
@@ -49,9 +48,10 @@ object NIO1SocketServerGroup {
   def apply(
       acceptorPool: SelectorLoopPool,
       workerPool: SelectorLoopPool,
-      channelOptions: ChannelOptions = ChannelOptions.DefaultOptions
+      channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
+      maxConnections: Int = DefaultMaxConnections
   ): ServerChannelGroup =
-    new NIO1SocketServerGroup(acceptorPool, workerPool, channelOptions)
+    new NIO1SocketServerGroup(acceptorPool, workerPool, channelOptions, maxConnections)
 
   /** Create a new [[NIO1SocketServerGroup]] with a fresh [[FixedSelectorPool]]
     *
@@ -62,12 +62,14 @@ object NIO1SocketServerGroup {
       workerThreads: Int = DefaultPoolSize,
       bufferSize: Int = DefaultBufferSize,
       channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
-      selectorThreadFactory: ThreadFactory = defaultAcceptThreadFactory, // TODO: different names for acceptor and worker?
+      selectorThreadFactory: ThreadFactory = defaultWorkerThreadFactory,
       acceptorThreads: Int = 1,
+      acceptorThreadFactory: ThreadFactory = defaultAcceptorThreadFactory,
+      maxConnections: Int = DefaultMaxConnections
   ): ServerChannelGroup = {
-    val acceptorPool = new FixedSelectorPool(acceptorThreads, 0, selectorThreadFactory)
+    val acceptorPool = new FixedSelectorPool(acceptorThreads, 0, acceptorThreadFactory)
     val workerPool = new FixedSelectorPool(workerThreads, bufferSize, selectorThreadFactory)
-    val underlying = apply(acceptorPool, workerPool, channelOptions)
+    val underlying = apply(acceptorPool, workerPool, channelOptions, maxConnections)
 
     // Proxy to the underlying group. `close` calls also close
     // the worker pools since we were the ones that created it.
@@ -101,7 +103,8 @@ object NIO1SocketServerGroup {
 private final class NIO1SocketServerGroup private (
     acceptorPool: SelectorLoopPool,
     workerPool: SelectorLoopPool,
-    channelOptions: ChannelOptions)
+    channelOptions: ChannelOptions,
+    maxConnections: Int)
     extends ServerChannelGroup {
   private[this] val logger = getLogger
   // Also acts as our intrinsic lock.
@@ -109,6 +112,8 @@ private final class NIO1SocketServerGroup private (
   // protected by synchronization on the intrinsic lock.
   private[this] var isClosed = false
 
+  private[this] val connections: Connections = Connections(maxConnections)
+
   // Closing delegates to the `ServerChannelImpl` which
   // ensures only-once behavior and attempts to close the
   // channel within the `SelectorLoop`, if it's still running.
@@ -149,10 +154,9 @@ private final class NIO1SocketServerGroup private (
 
     @tailrec
     private[this] def acceptNewConnections(): Unit = {
-      // TODO: when connection limiting is enabled, we should block the accept
-
       // We go in a loop just in case we have more than one.
       // Once we're out, the `.accept()` method will return `null`.
+      connections.acquire()
       val child = ch.selectableChannel.accept()
       if (child != null) {
         handleClientChannel(child, service)
@@ -188,17 +192,21 @@ private final class NIO1SocketServerGroup private (
         listeningSet.synchronized {
           listeningSet.remove(this)
         }
-        try selectableChannel.close()
-        catch {
+        try {
+          selectableChannel.close()
+          connections.close() // allow the acceptor thread through
+        } catch {
           case NonFatal(t) => logger.warn(t)("Failure during channel close.")
         }
       }
 
-      try
-      // We use `enqueueTask` deliberately so as to not jump ahead
-      // of channel initialization.
-      selectorLoop.enqueueTask(() => doClose())
-      catch {
+      try {
+        // We use `enqueueTask` deliberately so as to not jump ahead
+        // of channel initialization.
+        selectorLoop.enqueueTask(new Runnable {
+          override def run(): Unit = doClose()
+        })
+      } catch {
         case _: RejectedExecutionException =>
           logger.info("Selector loop closed. Closing in local thread.")
           doClose()
@@ -281,7 +289,7 @@ private final class NIO1SocketServerGroup private (
       // From within the selector loop, constructs a pipeline or
       // just closes the socket if the pipeline builder rejects it.
       def fromKey(key: SelectionKey): Selectable = {
-        val head = new NIO1HeadStage(clientChannel, loop, key)
+        val head = new NIO1HeadStage(clientChannel, loop, key, connections)
         service(conn).onComplete {
           case Success(tail) =>
             tail.base(head)
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
index ae6df561..926aa71e 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
@@ -116,22 +116,24 @@ final class SelectorLoop(
       ch: NIO1Channel,
       mkStage: SelectionKey => Selectable
   ): Unit =
-    enqueueTask(() => {
-      if (!selector.isOpen) {
-        ch.close()
-      } else {
-        try {
-          // We place all this noise in the `try` since pretty
-          // much every method on the `SelectableChannel` can throw.
-          require(!ch.selectableChannel.isBlocking, s"Can only register non-blocking channels")
-          val key = ch.selectableChannel.register(selector, 0)
-          val head = mkStage(key)
-          key.attach(head)
-          logger.debug("Channel initialized.")
-        } catch {
-          case t@(NonFatal(_) | _: ControlThrowable) =>
-            logger.error(t)("Caught error during channel init.")
-            ch.close()
+    enqueueTask(new Runnable {
+      override def run(): Unit = {
+        if (!selector.isOpen) {
+          ch.close()
+        } else {
+          try {
+            // We place all this noise in the `try` since pretty
+            // much every method on the `SelectableChannel` can throw.
+            require(!ch.selectableChannel.isBlocking, s"Can only register non-blocking channels")
+            val key = ch.selectableChannel.register(selector, 0)
+            val head = mkStage(key)
+            key.attach(head)
+            logger.debug("Channel initialized.")
+          } catch {
+            case t@(NonFatal(_) | _: ControlThrowable) =>
+              logger.error(t)("Caught error during channel init.")
+              ch.close()
+          }
         }
       }
     })
diff --git a/core/src/main/scala/org/http4s/blaze/channel/package.scala b/core/src/main/scala/org/http4s/blaze/channel/package.scala
index bc5aab99..9b710ad3 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/package.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/package.scala
@@ -20,4 +20,9 @@ package object channel {
     */
   val DefaultPoolSize: Int =
     math.max(4, Runtime.getRuntime.availableProcessors() + 1)
+
+  /** Default max number of connections that can be active at any time.
+    * A negative number means that there is no max.
+    */
+  val DefaultMaxConnections: Int = -1
 }
diff --git a/core/src/main/scala/org/http4s/blaze/util/Connections.scala b/core/src/main/scala/org/http4s/blaze/util/Connections.scala
new file mode 100644
index 00000000..f34208a2
--- /dev/null
+++ b/core/src/main/scala/org/http4s/blaze/util/Connections.scala
@@ -0,0 +1,27 @@
+package org.http4s.blaze.util
+
+import java.util.concurrent.Semaphore
+
+private[blaze] sealed trait Connections {
+  def acquire(): Unit
+  def release(): Unit
+  def close(): Unit = release()
+}
+
+private[blaze] object Connections {
+
+  def apply(maxConnections: Int): Connections =
+    if (maxConnections < 0) Unbounded else new Bounded(maxConnections)
+
+  private[this] object Unbounded extends Connections {
+    override def acquire(): Unit = ()
+    override def release(): Unit = ()
+  }
+
+  private[this] final class Bounded(maxConnections: Int) extends Connections {
+    val semaphore = new Semaphore(maxConnections)
+    override def acquire(): Unit = semaphore.acquire()
+    override def release(): Unit = semaphore.release()
+  }
+
+}

From 0ed7e693eef7f3b9891f4b6eebf95b79630ef940 Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Fri, 29 Jan 2021 21:13:03 -0600
Subject: [PATCH 03/18] Initial buffer size of 1 for acceptor pool

---
 .../http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala   | 2 +-
 core/src/main/scala/org/http4s/blaze/util/Connections.scala | 6 ++++++
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 47daa54f..08dd4739 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -67,7 +67,7 @@ object NIO1SocketServerGroup {
       acceptorThreadFactory: ThreadFactory = defaultAcceptorThreadFactory,
       maxConnections: Int = DefaultMaxConnections
   ): ServerChannelGroup = {
-    val acceptorPool = new FixedSelectorPool(acceptorThreads, 0, acceptorThreadFactory)
+    val acceptorPool = new FixedSelectorPool(acceptorThreads, 1, acceptorThreadFactory)
     val workerPool = new FixedSelectorPool(workerThreads, bufferSize, selectorThreadFactory)
     val underlying = apply(acceptorPool, workerPool, channelOptions, maxConnections)
 
diff --git a/core/src/main/scala/org/http4s/blaze/util/Connections.scala b/core/src/main/scala/org/http4s/blaze/util/Connections.scala
index f34208a2..731fb7f6 100644
--- a/core/src/main/scala/org/http4s/blaze/util/Connections.scala
+++ b/core/src/main/scala/org/http4s/blaze/util/Connections.scala
@@ -1,3 +1,9 @@
+/*
+ * Copyright 2014-2021 http4s.org
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
 package org.http4s.blaze.util
 
 import java.util.concurrent.Semaphore

From 86c269c3ee75721c517c1a43596736c271842a1e Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Fri, 29 Jan 2021 23:26:44 -0600
Subject: [PATCH 04/18] Release connection if accept returns null

---
 .../org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala   | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 08dd4739..291defa1 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -161,6 +161,8 @@ private final class NIO1SocketServerGroup private (
       if (child != null) {
         handleClientChannel(child, service)
         acceptNewConnections()
+      } else {
+        connections.release()
       }
     }
   }

From eb03163aefa5788c867697c19784f0e68ee5b99d Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Fri, 29 Jan 2021 23:28:01 -0600
Subject: [PATCH 05/18] Set default max connections to 512

---
 core/src/main/scala/org/http4s/blaze/channel/package.scala | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/package.scala b/core/src/main/scala/org/http4s/blaze/channel/package.scala
index 9b710ad3..8e9e0366 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/package.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/package.scala
@@ -24,5 +24,5 @@ package object channel {
   /** Default max number of connections that can be active at any time.
     * A negative number means that there is no max.
     */
-  val DefaultMaxConnections: Int = -1
+  val DefaultMaxConnections: Int = 512
 }

From a07cece0909333c245778c9e5f666d57341da923 Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 00:24:35 -0600
Subject: [PATCH 06/18] Idempotent onClose handler

---
 .../blaze/channel/nio1/NIO1HeadStage.scala    |  5 +++--
 .../channel/nio1/NIO1SocketServerGroup.scala  | 19 ++++++++++++++-----
 .../blaze/channel/nio1/SelectorLoop.scala     | 17 ++++++++++++++---
 3 files changed, 31 insertions(+), 10 deletions(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
index e6d9e705..b4580f4a 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
@@ -108,7 +108,7 @@ private[nio1] final class NIO1HeadStage(
     ch: SocketChannel,
     selectorLoop: SelectorLoop,
     key: SelectionKey,
-    connections: Connections
+    onClose: () => Unit
 ) extends ChannelHead
     with Selectable {
   import NIO1HeadStage._
@@ -301,10 +301,11 @@ private[nio1] final class NIO1HeadStage(
       writeData = null
       try {
         ch.close()
-        connections.release()
       } catch {
         case ex: IOException =>
           logger.warn(ex)("Unexpected IOException during channel close")
+      } finally {
+        onClose()
       }
       sendInboundCommand(Disconnected)
     }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 291defa1..5e79c6c2 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -158,8 +158,13 @@ private final class NIO1SocketServerGroup private (
       // Once we're out, the `.accept()` method will return `null`.
       connections.acquire()
       val child = ch.selectableChannel.accept()
+      val closed = new AtomicBoolean(false)
       if (child != null) {
-        handleClientChannel(child, service)
+        handleClientChannel(child, service, () => {
+          if (closed.compareAndSet(false, true)) {
+            connections.release()
+          }
+        })
         acceptNewConnections()
       } else {
         connections.release()
@@ -278,7 +283,8 @@ private final class NIO1SocketServerGroup private (
 
   private[this] def handleClientChannel(
       clientChannel: SocketChannel,
-      service: SocketPipelineBuilder
+      service: SocketPipelineBuilder,
+      onClose: () => Unit
   ): Unit =
     try {
       clientChannel.configureBlocking(false)
@@ -291,7 +297,7 @@ private final class NIO1SocketServerGroup private (
       // From within the selector loop, constructs a pipeline or
       // just closes the socket if the pipeline builder rejects it.
       def fromKey(key: SelectionKey): Selectable = {
-        val head = new NIO1HeadStage(clientChannel, loop, key, connections)
+        val head = new NIO1HeadStage(clientChannel, loop, key, onClose)
         service(conn).onComplete {
           case Success(tail) =>
             tail.base(head)
@@ -311,10 +317,13 @@ private final class NIO1SocketServerGroup private (
     } catch {
       case NonFatal(t) =>
         logger.error(t)("Error handling client channel. Closing.")
-        try clientChannel.close()
-        catch {
+        try {
+          clientChannel.close()
+        } catch {
           case NonFatal(t2) =>
             logger.error(t2)("Error closing client channel after error")
+        } finally {
+          onClose()
         }
     }
 }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
index 926aa71e..00289b1a 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
@@ -114,12 +114,17 @@ final class SelectorLoop(
     */
   def initChannel(
       ch: NIO1Channel,
-      mkStage: SelectionKey => Selectable
+      mkStage: SelectionKey => Selectable,
+      onClose: () => Unit = NoopOnClose
   ): Unit =
     enqueueTask(new Runnable {
       override def run(): Unit = {
         if (!selector.isOpen) {
-          ch.close()
+          try {
+            ch.close()
+          } finally {
+            onClose()
+          }
         } else {
           try {
             // We place all this noise in the `try` since pretty
@@ -132,7 +137,11 @@ final class SelectorLoop(
           } catch {
             case t@(NonFatal(_) | _: ControlThrowable) =>
               logger.error(t)("Caught error during channel init.")
-              ch.close()
+              try {
+                ch.close()
+              } finally {
+                onClose()
+              }
           }
         }
       }
@@ -263,4 +272,6 @@ final class SelectorLoop(
       }
     }
   }
+
+  private[this] val NoopOnClose: () => Unit = () => ()
 }

From fba7b2dd97a639204f93e349c3155a68b25149a4 Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 00:28:20 -0600
Subject: [PATCH 07/18] Run selector connections close in a finally block

---
 .../http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala    | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 5e79c6c2..2a51bc98 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -201,9 +201,10 @@ private final class NIO1SocketServerGroup private (
         }
         try {
           selectableChannel.close()
-          connections.close() // allow the acceptor thread through
         } catch {
           case NonFatal(t) => logger.warn(t)("Failure during channel close.")
+        } finally {
+          connections.close() // allow the acceptor thread through
         }
       }
 
@@ -313,7 +314,7 @@ private final class NIO1SocketServerGroup private (
         head
       }
 
-      loop.initChannel(NIO1Channel(clientChannel), fromKey)
+      loop.initChannel(NIO1Channel(clientChannel), fromKey, onClose)
     } catch {
       case NonFatal(t) =>
         logger.error(t)("Error handling client channel. Closing.")

From d7ac2aec0b95b9ebbef101f9095651922cd07597 Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 00:29:40 -0600
Subject: [PATCH 08/18] Remove unused import

---
 .../scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala     | 2 +-
 core/src/main/scala/org/http4s/blaze/util/Connections.scala     | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
index b4580f4a..0b8d44fb 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
@@ -13,7 +13,7 @@ import java.util.concurrent.RejectedExecutionException
 import org.http4s.blaze.channel.ChannelHead
 import org.http4s.blaze.pipeline.Command.{Disconnected, EOF}
 import org.http4s.blaze.util
-import org.http4s.blaze.util.{BufferTools, Connections}
+import org.http4s.blaze.util.BufferTools
 
 import scala.annotation.tailrec
 import scala.concurrent.{Future, Promise}
diff --git a/core/src/main/scala/org/http4s/blaze/util/Connections.scala b/core/src/main/scala/org/http4s/blaze/util/Connections.scala
index 731fb7f6..4c5beab0 100644
--- a/core/src/main/scala/org/http4s/blaze/util/Connections.scala
+++ b/core/src/main/scala/org/http4s/blaze/util/Connections.scala
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2021 http4s.org
+ * Copyright 2014-2020 http4s.org
  *
  * SPDX-License-Identifier: Apache-2.0
  */

From 783cbde4c32e66879b8a93dde43ab9a63a2e6465 Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 00:35:02 -0600
Subject: [PATCH 09/18] Allocate the closed atomic only if a connection was
 accepted

---
 .../org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala   | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 2a51bc98..70cb4105 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -158,8 +158,8 @@ private final class NIO1SocketServerGroup private (
       // Once we're out, the `.accept()` method will return `null`.
       connections.acquire()
       val child = ch.selectableChannel.accept()
-      val closed = new AtomicBoolean(false)
       if (child != null) {
+        val closed = new AtomicBoolean(false)
         handleClientChannel(child, service, () => {
           if (closed.compareAndSet(false, true)) {
             connections.release()

From 96d4fa83f7c0906ec94dcbfb957522d07f48c54f Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 17:31:18 -0600
Subject: [PATCH 10/18] Create private NIO1ClientChannel class to encapsulate
 closure better

---
 .../blaze/channel/nio1/NIO1Channel.scala      | 10 ++---
 .../channel/nio1/NIO1ClientChannel.scala      | 42 +++++++++++++++++++
 .../blaze/channel/nio1/NIO1HeadStage.scala    | 11 ++---
 .../channel/nio1/NIO1SocketConnection.scala   |  3 ++
 .../channel/nio1/NIO1SocketServerGroup.scala  | 21 ++++------
 .../blaze/channel/nio1/SelectorLoop.scala     | 15 ++-----
 6 files changed, 63 insertions(+), 39 deletions(-)
 create mode 100644 core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1Channel.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1Channel.scala
index b0d73cb3..912078f0 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1Channel.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1Channel.scala
@@ -22,12 +22,10 @@ trait NIO1Channel {
 }
 
 object NIO1Channel {
-  // Simple proxy implementation
-  private[this] final class Impl(val selectableChannel: SelectableChannel) extends NIO1Channel {
-    override def close(): Unit = selectableChannel.close()
-  }
-
   /** Construct a basic `NIO1Channel` from any `SelectableChannel` */
   def apply(selectableChannel: SelectableChannel): NIO1Channel =
-    new Impl(selectableChannel)
+    new NIO1Channel {
+      override val selectableChannel: SelectableChannel = selectableChannel
+      override def close(): Unit = selectableChannel.close()
+    }
 }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
new file mode 100644
index 00000000..a59ce117
--- /dev/null
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
@@ -0,0 +1,42 @@
+package org.http4s.blaze.channel.nio1
+
+import org.http4s.blaze.channel.{ChannelOptions, OptionValue}
+
+import java.net.SocketAddress
+import java.nio.ByteBuffer
+import java.nio.channels.{SelectableChannel, SocketChannel}
+import java.util.concurrent.atomic.AtomicBoolean
+
+private[blaze] final class NIO1ClientChannel(private[this] val underlying: SocketChannel, private[this] val onClose: () => Unit) extends NIO1Channel {
+
+  private[this] val closed = new AtomicBoolean(false)
+
+  override val selectableChannel: SelectableChannel = underlying
+
+  def configureBlocking(block: Boolean): Unit =
+    underlying.configureBlocking(block)
+
+  def getRemoteAddress: SocketAddress =
+    underlying.getRemoteAddress
+
+  def configureOptions(options: ChannelOptions): Unit =
+    options.options.foreach { case OptionValue(k, v) =>
+      underlying.setOption(k, v)
+    }
+
+  def read(dst: ByteBuffer): Int =
+    underlying.read(dst)
+
+  def write(src: ByteBuffer): Int =
+    underlying.write(src)
+
+  def close(): Unit =
+    try {
+      underlying.close()
+    } finally {
+      if (closed.compareAndSet(false, true)) {
+        onClose()
+      }
+    }
+
+}
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
index 0b8d44fb..2c969637 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
@@ -35,7 +35,7 @@ private[nio1] object NIO1HeadStage {
     * @return a `Try` representing successfully loading data into `scratch`, or
     *         the failure cause.
     */
-  private def performRead(ch: SocketChannel, scratch: ByteBuffer, size: Int): Try[Unit] =
+  private def performRead(ch: NIO1ClientChannel, scratch: ByteBuffer, size: Int): Try[Unit] =
     try {
       scratch.clear()
       if (size >= 0 && size < scratch.remaining)
@@ -58,7 +58,7 @@ private[nio1] object NIO1HeadStage {
     * @return a WriteResult that is one of Complete, Incomplete or WriteError(e: Exception)
     */
   private def performWrite(
-      ch: SocketChannel,
+      ch: NIO1ClientChannel,
       scratch: ByteBuffer,
       buffers: Array[ByteBuffer]): WriteResult =
     try if (BufferTools.areDirectOrEmpty(buffers)) {
@@ -105,10 +105,9 @@ private[nio1] object NIO1HeadStage {
 }
 
 private[nio1] final class NIO1HeadStage(
-    ch: SocketChannel,
+    ch: NIO1ClientChannel,
     selectorLoop: SelectorLoop,
-    key: SelectionKey,
-    onClose: () => Unit
+    key: SelectionKey
 ) extends ChannelHead
     with Selectable {
   import NIO1HeadStage._
@@ -304,8 +303,6 @@ private[nio1] final class NIO1HeadStage(
       } catch {
         case ex: IOException =>
           logger.warn(ex)("Unexpected IOException during channel close")
-      } finally {
-        onClose()
       }
       sendInboundCommand(Disconnected)
     }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
index ecc5cd24..887694c1 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
@@ -26,6 +26,9 @@ object NIO1Connection {
           override def isOpen: Boolean = connection.isOpen
         }
     }
+
+  private[blaze] def apply(channel: NIO1ClientChannel): SocketConnection =
+    apply(channel.underlying)
 }
 
 private case class NIO1SocketConnection(connection: SocketChannel) extends SocketConnection {
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index 70cb4105..c87f3f92 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -159,12 +159,8 @@ private final class NIO1SocketServerGroup private (
       connections.acquire()
       val child = ch.selectableChannel.accept()
       if (child != null) {
-        val closed = new AtomicBoolean(false)
-        handleClientChannel(child, service, () => {
-          if (closed.compareAndSet(false, true)) {
-            connections.release()
-          }
-        })
+        val channel = new NIO1ClientChannel(child, () => connections.release())
+        handleClientChannel(channel, service)
         acceptNewConnections()
       } else {
         connections.release()
@@ -283,13 +279,12 @@ private final class NIO1SocketServerGroup private (
   }
 
   private[this] def handleClientChannel(
-      clientChannel: SocketChannel,
-      service: SocketPipelineBuilder,
-      onClose: () => Unit
+      clientChannel: NIO1ClientChannel,
+      service: SocketPipelineBuilder
   ): Unit =
     try {
       clientChannel.configureBlocking(false)
-      channelOptions.applyToChannel(clientChannel)
+      clientChannel.configureOptions(channelOptions)
 
       val address = clientChannel.getRemoteAddress
       val loop = workerPool.nextLoop()
@@ -298,7 +293,7 @@ private final class NIO1SocketServerGroup private (
       // From within the selector loop, constructs a pipeline or
       // just closes the socket if the pipeline builder rejects it.
       def fromKey(key: SelectionKey): Selectable = {
-        val head = new NIO1HeadStage(clientChannel, loop, key, onClose)
+        val head = new NIO1HeadStage(clientChannel, loop, key)
         service(conn).onComplete {
           case Success(tail) =>
             tail.base(head)
@@ -314,7 +309,7 @@ private final class NIO1SocketServerGroup private (
         head
       }
 
-      loop.initChannel(NIO1Channel(clientChannel), fromKey, onClose)
+      loop.initChannel(clientChannel, fromKey)
     } catch {
       case NonFatal(t) =>
         logger.error(t)("Error handling client channel. Closing.")
@@ -323,8 +318,6 @@ private final class NIO1SocketServerGroup private (
         } catch {
           case NonFatal(t2) =>
             logger.error(t2)("Error closing client channel after error")
-        } finally {
-          onClose()
         }
     }
 }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
index 00289b1a..68fc8664 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
@@ -114,17 +114,12 @@ final class SelectorLoop(
     */
   def initChannel(
       ch: NIO1Channel,
-      mkStage: SelectionKey => Selectable,
-      onClose: () => Unit = NoopOnClose
+      mkStage: SelectionKey => Selectable
   ): Unit =
     enqueueTask(new Runnable {
       override def run(): Unit = {
         if (!selector.isOpen) {
-          try {
-            ch.close()
-          } finally {
-            onClose()
-          }
+          ch.close()
         } else {
           try {
             // We place all this noise in the `try` since pretty
@@ -137,11 +132,7 @@ final class SelectorLoop(
           } catch {
             case t@(NonFatal(_) | _: ControlThrowable) =>
               logger.error(t)("Caught error during channel init.")
-              try {
-                ch.close()
-              } finally {
-                onClose()
-              }
+              ch.close()
           }
         }
       }

From a3fe309160977461d781bf59e9278da7c55672c3 Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 17:33:39 -0600
Subject: [PATCH 11/18] Fix errors

---
 .../http4s/blaze/channel/nio1/NIO1ClientChannel.scala  | 10 ++++++++--
 .../blaze/channel/nio1/NIO1SocketConnection.scala      |  3 ---
 .../org/http4s/blaze/channel/nio1/SelectorLoop.scala   |  2 --
 3 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
index a59ce117..7d873662 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
@@ -1,3 +1,9 @@
+/*
+ * Copyright 2014-2020 http4s.org
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
 package org.http4s.blaze.channel.nio1
 
 import org.http4s.blaze.channel.{ChannelOptions, OptionValue}
@@ -27,8 +33,8 @@ private[blaze] final class NIO1ClientChannel(private[this] val underlying: Socke
   def read(dst: ByteBuffer): Int =
     underlying.read(dst)
 
-  def write(src: ByteBuffer): Int =
-    underlying.write(src)
+  def write(srcs: Array[ByteBuffer]): Long =
+    underlying.write(srcs)
 
   def close(): Unit =
     try {
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
index 887694c1..ecc5cd24 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
@@ -26,9 +26,6 @@ object NIO1Connection {
           override def isOpen: Boolean = connection.isOpen
         }
     }
-
-  private[blaze] def apply(channel: NIO1ClientChannel): SocketConnection =
-    apply(channel.underlying)
 }
 
 private case class NIO1SocketConnection(connection: SocketChannel) extends SocketConnection {
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
index 68fc8664..926aa71e 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
@@ -263,6 +263,4 @@ final class SelectorLoop(
       }
     }
   }
-
-  private[this] val NoopOnClose: () => Unit = () => ()
 }

From b7186bb06513a41e37ee1df88f39c52a631d860f Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 17:39:07 -0600
Subject: [PATCH 12/18] fixes

---
 .../http4s/blaze/channel/nio1/NIO1Channel.scala   | 10 ++++++----
 .../blaze/channel/nio1/NIO1ClientChannel.scala    | 15 +++++++++++++--
 .../blaze/channel/nio1/NIO1SocketConnection.scala |  8 ++++++++
 3 files changed, 27 insertions(+), 6 deletions(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1Channel.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1Channel.scala
index 912078f0..b0d73cb3 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1Channel.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1Channel.scala
@@ -22,10 +22,12 @@ trait NIO1Channel {
 }
 
 object NIO1Channel {
+  // Simple proxy implementation
+  private[this] final class Impl(val selectableChannel: SelectableChannel) extends NIO1Channel {
+    override def close(): Unit = selectableChannel.close()
+  }
+
   /** Construct a basic `NIO1Channel` from any `SelectableChannel` */
   def apply(selectableChannel: SelectableChannel): NIO1Channel =
-    new NIO1Channel {
-      override val selectableChannel: SelectableChannel = selectableChannel
-      override def close(): Unit = selectableChannel.close()
-    }
+    new Impl(selectableChannel)
 }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
index 7d873662..c8779d84 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
@@ -19,12 +19,17 @@ private[blaze] final class NIO1ClientChannel(private[this] val underlying: Socke
 
   override val selectableChannel: SelectableChannel = underlying
 
-  def configureBlocking(block: Boolean): Unit =
+  def configureBlocking(block: Boolean): Unit = {
     underlying.configureBlocking(block)
+    ()
+  }
 
   def getRemoteAddress: SocketAddress =
     underlying.getRemoteAddress
 
+  def getLocalAddress: SocketAddress =
+    underlying.getLocalAddress
+
   def configureOptions(options: ChannelOptions): Unit =
     options.options.foreach { case OptionValue(k, v) =>
       underlying.setOption(k, v)
@@ -33,10 +38,16 @@ private[blaze] final class NIO1ClientChannel(private[this] val underlying: Socke
   def read(dst: ByteBuffer): Int =
     underlying.read(dst)
 
+  def write(src: ByteBuffer): Int =
+    underlying.write(src)
+
   def write(srcs: Array[ByteBuffer]): Long =
     underlying.write(srcs)
 
-  def close(): Unit =
+  def isOpen: Boolean =
+    underlying.isOpen
+
+  override def close(): Unit =
     try {
       underlying.close()
     } finally {
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
index ecc5cd24..9ba569e8 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketConnection.scala
@@ -26,6 +26,14 @@ object NIO1Connection {
           override def isOpen: Boolean = connection.isOpen
         }
     }
+
+  private[blaze] def apply(channel: NIO1ClientChannel): SocketConnection =
+    new SocketConnection {
+      override def remote: SocketAddress = channel.getRemoteAddress
+      override def local: SocketAddress = channel.getLocalAddress
+      override def isOpen: Boolean = channel.isOpen
+      override def close(): Unit = channel.close()
+    }
 }
 
 private case class NIO1SocketConnection(connection: SocketChannel) extends SocketConnection {

From ccea42f3a22c2a83cfb515c20f8e43b1e8206a85 Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 22:56:28 -0600
Subject: [PATCH 13/18] Deprecate NIO2 server backend

---
 .../org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala   | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
index c9881222..9b3196c3 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
@@ -27,6 +27,7 @@ object NIO2SocketServerGroup {
     * @param bufferSize buffer size use for IO operations
     * @param channelOptions options to apply to the client connections
     */
+  @deprecated("Prefer NIO1 over NIO2", "0.14.15")
   def fixedGroup(
       workerThreads: Int = DefaultPoolSize,
       bufferSize: Int = DefaultBufferSize,
@@ -47,6 +48,7 @@ object NIO2SocketServerGroup {
     * @param group optional `AsynchronousChannelGroup`, uses the system default if `None`
     * @param channelOptions options to apply to the client connections
     */
+  @deprecated("Prefer NIO1 over NIO2", "0.14.15")
   def apply(
       bufferSize: Int = 8 * 1024,
       group: Option[AsynchronousChannelGroup] = None,

From bf15e06ac4ae8a2d062f136d57faaf271ae23901 Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 23:01:57 -0600
Subject: [PATCH 14/18] Move deprecation warning

---
 .../org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala  | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
index 9b3196c3..aceed1ab 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio2/NIO2SocketServerGroup.scala
@@ -19,6 +19,7 @@ import org.log4s.getLogger
 import scala.util.{Failure, Success, Try}
 import scala.util.control.NonFatal
 
+@deprecated("Prefer NIO1 over NIO2", "0.14.15")
 object NIO2SocketServerGroup {
 
   /** Create a new fixed size NIO2 SocketServerGroup
@@ -27,7 +28,6 @@ object NIO2SocketServerGroup {
     * @param bufferSize buffer size use for IO operations
     * @param channelOptions options to apply to the client connections
     */
-  @deprecated("Prefer NIO1 over NIO2", "0.14.15")
   def fixedGroup(
       workerThreads: Int = DefaultPoolSize,
       bufferSize: Int = DefaultBufferSize,
@@ -48,7 +48,6 @@ object NIO2SocketServerGroup {
     * @param group optional `AsynchronousChannelGroup`, uses the system default if `None`
     * @param channelOptions options to apply to the client connections
     */
-  @deprecated("Prefer NIO1 over NIO2", "0.14.15")
   def apply(
       bufferSize: Int = 8 * 1024,
       group: Option[AsynchronousChannelGroup] = None,

From a62e64fa1bb982fd57ed4863ec5f90735aa3ce9a Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 23:51:06 -0600
Subject: [PATCH 15/18] Disable fatal warnings

---
 build.sbt                                       |  2 +-
 .../blaze/http/http1/server/Http1Server.scala   | 17 +++++++++++++++++
 2 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/build.sbt b/build.sbt
index 797e1174..07a2ef72 100644
--- a/build.sbt
+++ b/build.sbt
@@ -6,7 +6,7 @@ lazy val commonSettings = Seq(
   crossScalaVersions := Seq("2.11.12", "2.12.12", "2.13.3"),
   scalaVersion := crossScalaVersions.value.filter(_.startsWith("2.")).last,
   scalacOptions := scalacOptionsFor(scalaVersion.value),
-  scalacOptions in Test ~= (_.filterNot(Set("-Ywarn-dead-code", "-Wdead-code"))), // because mockito
+  scalacOptions in Test ~= (_.filterNot(Set("-Ywarn-dead-code", "-Wdead-code", "-Xfatal-warnings"))), // because mockito
   scalacOptions in (Compile, doc) += "-no-link-warnings",
   unmanagedSourceDirectories in Compile ++= {
     (unmanagedSourceDirectories in Compile).value.map { dir =>
diff --git a/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala b/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
index fedcd2a8..d0138261 100644
--- a/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
+++ b/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
@@ -23,6 +23,7 @@ object Http1Server {
   case class GroupAndChannel(group: ServerChannelGroup, channel: ServerChannel)
 
   /** Create a new Http1Server */
+  @deprecated("Prefer NIO1 over NIO2. Use alternate apply method without useNio2 option.", "0.14.15")
   def apply(
       service: SocketConnection => Future[HttpService],
       address: InetSocketAddress,
@@ -42,4 +43,20 @@ object Http1Server {
     if (channel.isFailure) group.closeGroup()
     channel.map(GroupAndChannel(group, _))
   }
+
+  def apply(
+      service: SocketConnection => Future[HttpService],
+      address: InetSocketAddress,
+      config: HttpServerStageConfig,
+      workerThreads: Int = channel.DefaultPoolSize): Try[GroupAndChannel] = {
+    val group: ServerChannelGroup = NIO1SocketServerGroup.fixedGroup(workerThreads = workerThreads)
+
+    val builder = service(_: SocketConnection).map { service =>
+      LeafBuilder(new Http1ServerStage(service, config))
+    }(Execution.directec)
+
+    val channel = group.bind(address, builder)
+    if (channel.isFailure) group.closeGroup()
+    channel.map(GroupAndChannel(group, _))
+  }
 }

From 7ea9346bcef39db458d774d59fb4c1d2b7a18c0d Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sat, 30 Jan 2021 23:54:49 -0600
Subject: [PATCH 16/18] apply -> nio1

---
 .../org/http4s/blaze/http/http1/server/Http1Server.scala      | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala b/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
index d0138261..59d58035 100644
--- a/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
+++ b/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
@@ -23,7 +23,7 @@ object Http1Server {
   case class GroupAndChannel(group: ServerChannelGroup, channel: ServerChannel)
 
   /** Create a new Http1Server */
-  @deprecated("Prefer NIO1 over NIO2. Use alternate apply method without useNio2 option.", "0.14.15")
+  @deprecated("Prefer NIO1 over NIO2. Use nio1 constructor method.", "0.14.15")
   def apply(
       service: SocketConnection => Future[HttpService],
       address: InetSocketAddress,
@@ -44,7 +44,7 @@ object Http1Server {
     channel.map(GroupAndChannel(group, _))
   }
 
-  def apply(
+  def nio1(
       service: SocketConnection => Future[HttpService],
       address: InetSocketAddress,
       config: HttpServerStageConfig,

From acba4a46904ad963c13c4dc45cbbc350adfe3451 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Tue, 2 Feb 2021 01:07:23 -0500
Subject: [PATCH 17/18] Fix MiMa: fixedGroup -> fixed, apply -> create

---
 build.sbt                                     |  6 ++++-
 .../blaze/channel/nio1/NIO1HeadStage.scala    | 11 ++++++++
 .../channel/nio1/NIO1SocketServerGroup.scala  | 25 ++++++++++++++++---
 .../http4s/blaze/channel/ChannelSpec.scala    |  2 +-
 .../blaze/examples/Http1ServerExample.scala   |  6 ++---
 .../examples/http2/Http2ServerExample.scala   |  2 +-
 .../blaze/http/http1/server/Http1Server.scala |  2 +-
 7 files changed, 43 insertions(+), 11 deletions(-)

diff --git a/build.sbt b/build.sbt
index 50a06344..e7c7fa06 100644
--- a/build.sbt
+++ b/build.sbt
@@ -79,7 +79,11 @@ lazy val core = Project("blaze-core", file("core"))
       scalaVersion,
       git.gitHeadCommit
     ),
-    buildInfoOptions += BuildInfoOption.BuildTime
+    buildInfoOptions += BuildInfoOption.BuildTime,
+    mimaBinaryIssueFilters ++= Seq(
+      // private constructor for which there are no sensible defaults
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.blaze.channel.nio1.NIO1SocketServerGroup.this")
+    )
   )
 
 lazy val http = Project("blaze-http", file("http"))
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
index 9cab01b3..cd372564 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
@@ -122,6 +122,17 @@ private[nio1] final class NIO1HeadStage(
     with Selectable {
   import NIO1HeadStage._
 
+  @deprecated("Binary compatibility shim. This one can leak connection acceptance permits.", "0.14.15")
+  private[NIO1HeadStage] def this(
+    ch: SocketChannel,
+    selectorLoop: SelectorLoop,
+    key: SelectionKey
+  ) = this(
+    new NIO1ClientChannel(ch, { () => () }),
+    selectorLoop: SelectorLoop,
+    key
+  )
+
   override def name: String = "NIO1 ByteBuffer Head Stage"
 
   // State of the HeadStage. These should only be accessed from the SelectorLoop thread
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index b813798a..b4f5a58e 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -55,7 +55,7 @@ object NIO1SocketServerGroup {
     * @note The worker pool is not owned by the group and therefore not
     *       shutdown when the group is shutdown.
     */
-  def apply(
+  def create(
       acceptorPool: SelectorLoopPool,
       workerPool: SelectorLoopPool,
       channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
@@ -63,12 +63,20 @@ object NIO1SocketServerGroup {
   ): ServerChannelGroup =
     new NIO1SocketServerGroup(acceptorPool, workerPool, channelOptions, maxConnections)
 
-  /** Create a new [[NIO1SocketServerGroup]] with a fresh [[FixedSelectorPool]]
+  @deprecated("Use `create` instead. This uses the same pool for both worker and acceptor", "0.14.15")
+  def apply(
+    workerPool: SelectorLoopPool,
+    channelOptions: ChannelOptions = ChannelOptions.DefaultOptions
+  ): ServerChannelGroup =
+    create(workerPool, workerPool, channelOptions, DefaultMaxConnections)
+
+  /** Create a new [[NIO1SocketServerGroup]] with a fresh [[FixedSelectorPool]
+]
     *
     * The resulting [[ServerChannelGroup]] takes ownership of the created pool,
     * shutting it down when the group is shutdown.
     */
-  def fixedGroup(
+  def fixed(
       workerThreads: Int = DefaultPoolSize,
       bufferSize: Int = DefaultBufferSize,
       channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
@@ -79,7 +87,7 @@ object NIO1SocketServerGroup {
   ): ServerChannelGroup = {
     val acceptorPool = new FixedSelectorPool(acceptorThreads, 1, acceptorThreadFactory)
     val workerPool = new FixedSelectorPool(workerThreads, bufferSize, selectorThreadFactory)
-    val underlying = apply(acceptorPool, workerPool, channelOptions, maxConnections)
+    val underlying = create(acceptorPool, workerPool, channelOptions, maxConnections)
 
     // Proxy to the underlying group. `close` calls also close
     // the worker pools since we were the ones that created it.
@@ -102,6 +110,15 @@ object NIO1SocketServerGroup {
         underlying.bind(address, service)
     }
   }
+
+  @deprecated("Use `fixed` instead", "0.14.15")
+  def fixedGroup(
+      workerThreads: Int = DefaultPoolSize,
+      bufferSize: Int = DefaultBufferSize,
+      channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
+      selectorThreadFactory: ThreadFactory = defaultWorkerThreadFactory,
+  ): ServerChannelGroup =
+    fixed(workerThreads, bufferSize, channelOptions, selectorThreadFactory, 1, defaultAcceptorThreadFactory, DefaultMaxConnections)
 }
 
 /** A thread resource group for NIO1 network operations
diff --git a/core/src/test/scala/org/http4s/blaze/channel/ChannelSpec.scala b/core/src/test/scala/org/http4s/blaze/channel/ChannelSpec.scala
index 4b54ee1a..eac2e556 100644
--- a/core/src/test/scala/org/http4s/blaze/channel/ChannelSpec.scala
+++ b/core/src/test/scala/org/http4s/blaze/channel/ChannelSpec.scala
@@ -29,7 +29,7 @@ import scala.concurrent.duration._
 
 class NIO1ChannelSpec extends BaseChannelSpec {
   override protected def bind(f: SocketPipelineBuilder): ServerPair = {
-    val factory = NIO1SocketServerGroup.fixedGroup(workerThreads = 2)
+    val factory = NIO1SocketServerGroup.fixed(workerThreads = 2)
 
     val channel = factory.bind(new InetSocketAddress(0), f).get // will throw if failed to bind
     ServerPair(factory, channel)
diff --git a/examples/src/main/scala/org/http4s/blaze/examples/Http1ServerExample.scala b/examples/src/main/scala/org/http4s/blaze/examples/Http1ServerExample.scala
index 9eecd452..7370ab38 100644
--- a/examples/src/main/scala/org/http4s/blaze/examples/Http1ServerExample.scala
+++ b/examples/src/main/scala/org/http4s/blaze/examples/Http1ServerExample.scala
@@ -59,7 +59,7 @@ class Http1ServerExample(factory: ServerChannelGroup, port: Int)(
 object NIO1HttpServer {
   def main(args: Array[String]): Unit = {
     val f =
-      NIO1SocketServerGroup.fixedGroup(workerThreads = channel.DefaultPoolSize)
+      NIO1SocketServerGroup.fixed(workerThreads = channel.DefaultPoolSize)
     new Http1ServerExample(f, 8080)()
       .run()
       .join()
@@ -83,7 +83,7 @@ object SSLHttpServer {
   def main(args: Array[String]): Unit = {
     val sslContext = ExampleKeystore.sslContext()
     val f =
-      NIO1SocketServerGroup.fixedGroup(workerThreads = channel.DefaultPoolSize)
+      NIO1SocketServerGroup.fixed(workerThreads = channel.DefaultPoolSize)
     new Http1ServerExample(f, 4430)({ builder =>
       val eng = sslContext.createSSLEngine()
       eng.setUseClientMode(false)
@@ -99,7 +99,7 @@ object ClientAuthSSLHttpServer {
   def main(args: Array[String]): Unit = {
     val sslContext = ExampleKeystore.clientAuthSslContext()
     val f =
-      NIO1SocketServerGroup.fixedGroup(workerThreads = channel.DefaultPoolSize)
+      NIO1SocketServerGroup.fixed(workerThreads = channel.DefaultPoolSize)
     new Http1ServerExample(f, 4430)({ builder =>
       val eng = sslContext.createSSLEngine()
       eng.setUseClientMode(false)
diff --git a/examples/src/main/scala/org/http4s/blaze/examples/http2/Http2ServerExample.scala b/examples/src/main/scala/org/http4s/blaze/examples/http2/Http2ServerExample.scala
index 0f345a2e..b7205110 100644
--- a/examples/src/main/scala/org/http4s/blaze/examples/http2/Http2ServerExample.scala
+++ b/examples/src/main/scala/org/http4s/blaze/examples/http2/Http2ServerExample.scala
@@ -51,7 +51,7 @@ class Http2ServerExample(port: Int) {
   }
 
   private val factory =
-    NIO1SocketServerGroup.fixedGroup(workerThreads = channel.DefaultPoolSize)
+    NIO1SocketServerGroup.fixed(workerThreads = channel.DefaultPoolSize)
 
   def run(): ServerChannel =
     factory
diff --git a/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala b/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
index dd66f8b7..283c2df2 100644
--- a/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
+++ b/http/src/main/scala/org/http4s/blaze/http/http1/server/Http1Server.scala
@@ -59,7 +59,7 @@ object Http1Server {
       address: InetSocketAddress,
       config: HttpServerStageConfig,
       workerThreads: Int = channel.DefaultPoolSize): Try[GroupAndChannel] = {
-    val group: ServerChannelGroup = NIO1SocketServerGroup.fixedGroup(workerThreads = workerThreads)
+    val group: ServerChannelGroup = NIO1SocketServerGroup.fixed(workerThreads = workerThreads)
 
     val builder = service(_: SocketConnection).map { service =>
       LeafBuilder(new Http1ServerStage(service, config))

From 626c4dd830975c90658f38e22ebda81b193c7b99 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Tue, 2 Feb 2021 01:08:29 -0500
Subject: [PATCH 18/18] scalafmt

---
 .../channel/nio1/NIO1ClientChannel.scala      | 14 ++---
 .../blaze/channel/nio1/NIO1HeadStage.scala    | 17 +++---
 .../channel/nio1/NIO1SocketServerGroup.scala  | 58 +++++++++++--------
 .../blaze/channel/nio1/SelectorLoop.scala     | 26 ++++-----
 4 files changed, 62 insertions(+), 53 deletions(-)

diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
index 068fe367..adaab34d 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1ClientChannel.scala
@@ -23,7 +23,10 @@ import java.nio.ByteBuffer
 import java.nio.channels.{SelectableChannel, SocketChannel}
 import java.util.concurrent.atomic.AtomicBoolean
 
-private[blaze] final class NIO1ClientChannel(private[this] val underlying: SocketChannel, private[this] val onClose: () => Unit) extends NIO1Channel {
+private[blaze] final class NIO1ClientChannel(
+    private[this] val underlying: SocketChannel,
+    private[this] val onClose: () => Unit)
+    extends NIO1Channel {
 
   private[this] val closed = new AtomicBoolean(false)
 
@@ -58,12 +61,9 @@ private[blaze] final class NIO1ClientChannel(private[this] val underlying: Socke
     underlying.isOpen
 
   override def close(): Unit =
-    try {
-      underlying.close()
-    } finally {
-      if (closed.compareAndSet(false, true)) {
-        onClose()
-      }
+    try underlying.close()
+    finally if (closed.compareAndSet(false, true)) {
+      onClose()
     }
 
 }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
index cd372564..30dbf999 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1HeadStage.scala
@@ -122,13 +122,15 @@ private[nio1] final class NIO1HeadStage(
     with Selectable {
   import NIO1HeadStage._
 
-  @deprecated("Binary compatibility shim. This one can leak connection acceptance permits.", "0.14.15")
+  @deprecated(
+    "Binary compatibility shim. This one can leak connection acceptance permits.",
+    "0.14.15")
   private[NIO1HeadStage] def this(
-    ch: SocketChannel,
-    selectorLoop: SelectorLoop,
-    key: SelectionKey
+      ch: SocketChannel,
+      selectorLoop: SelectorLoop,
+      key: SelectionKey
   ) = this(
-    new NIO1ClientChannel(ch, { () => () }),
+    new NIO1ClientChannel(ch, () => ()),
     selectorLoop: SelectorLoop,
     key
   )
@@ -319,9 +321,8 @@ private[nio1] final class NIO1HeadStage(
       }
 
       writeData = null
-      try {
-        ch.close()
-      } catch {
+      try ch.close()
+      catch {
         case ex: IOException =>
           logger.warn(ex)("Unexpected IOException during channel close")
       }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
index b4f5a58e..7f3de832 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/NIO1SocketServerGroup.scala
@@ -22,7 +22,14 @@ import java.net.InetSocketAddress
 import java.nio.ByteBuffer
 import java.util.concurrent.{RejectedExecutionException, ThreadFactory}
 import java.util.concurrent.atomic.{AtomicBoolean, AtomicInteger}
-import org.http4s.blaze.channel.{ChannelOptions, DefaultMaxConnections, DefaultPoolSize, ServerChannel, ServerChannelGroup, SocketPipelineBuilder}
+import org.http4s.blaze.channel.{
+  ChannelOptions,
+  DefaultMaxConnections,
+  DefaultPoolSize,
+  ServerChannel,
+  ServerChannelGroup,
+  SocketPipelineBuilder
+}
 import org.http4s.blaze.pipeline.Command
 import org.http4s.blaze.util.{BasicThreadFactory, Connections}
 import org.log4s._
@@ -63,15 +70,17 @@ object NIO1SocketServerGroup {
   ): ServerChannelGroup =
     new NIO1SocketServerGroup(acceptorPool, workerPool, channelOptions, maxConnections)
 
-  @deprecated("Use `create` instead. This uses the same pool for both worker and acceptor", "0.14.15")
+  @deprecated(
+    "Use `create` instead. This uses the same pool for both worker and acceptor",
+    "0.14.15")
   def apply(
-    workerPool: SelectorLoopPool,
-    channelOptions: ChannelOptions = ChannelOptions.DefaultOptions
+      workerPool: SelectorLoopPool,
+      channelOptions: ChannelOptions = ChannelOptions.DefaultOptions
   ): ServerChannelGroup =
     create(workerPool, workerPool, channelOptions, DefaultMaxConnections)
 
   /** Create a new [[NIO1SocketServerGroup]] with a fresh [[FixedSelectorPool]
-]
+    * ]
     *
     * The resulting [[ServerChannelGroup]] takes ownership of the created pool,
     * shutting it down when the group is shutdown.
@@ -116,9 +125,16 @@ object NIO1SocketServerGroup {
       workerThreads: Int = DefaultPoolSize,
       bufferSize: Int = DefaultBufferSize,
       channelOptions: ChannelOptions = ChannelOptions.DefaultOptions,
-      selectorThreadFactory: ThreadFactory = defaultWorkerThreadFactory,
+      selectorThreadFactory: ThreadFactory = defaultWorkerThreadFactory
   ): ServerChannelGroup =
-    fixed(workerThreads, bufferSize, channelOptions, selectorThreadFactory, 1, defaultAcceptorThreadFactory, DefaultMaxConnections)
+    fixed(
+      workerThreads,
+      bufferSize,
+      channelOptions,
+      selectorThreadFactory,
+      1,
+      defaultAcceptorThreadFactory,
+      DefaultMaxConnections)
 }
 
 /** A thread resource group for NIO1 network operations
@@ -222,22 +238,19 @@ private final class NIO1SocketServerGroup private (
         listeningSet.synchronized {
           listeningSet.remove(this)
         }
-        try {
-          selectableChannel.close()
-        } catch {
+        try selectableChannel.close()
+        catch {
           case NonFatal(t) => logger.warn(t)("Failure during channel close.")
-        } finally {
-          connections.close() // allow the acceptor thread through
-        }
+        } finally connections.close() // allow the acceptor thread through
       }
 
-      try {
-        // We use `enqueueTask` deliberately so as to not jump ahead
-        // of channel initialization.
-        selectorLoop.enqueueTask(new Runnable {
-          override def run(): Unit = doClose()
-        })
-      } catch {
+      try
+      // We use `enqueueTask` deliberately so as to not jump ahead
+      // of channel initialization.
+      selectorLoop.enqueueTask(new Runnable {
+        override def run(): Unit = doClose()
+      })
+      catch {
         case _: RejectedExecutionException =>
           logger.info("Selector loop closed. Closing in local thread.")
           doClose()
@@ -340,9 +353,8 @@ private final class NIO1SocketServerGroup private (
     } catch {
       case NonFatal(t) =>
         logger.error(t)("Error handling client channel. Closing.")
-        try {
-          clientChannel.close()
-        } catch {
+        try clientChannel.close()
+        catch {
           case NonFatal(t2) =>
             logger.error(t2)("Error closing client channel after error")
         }
diff --git a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
index c8ba5b9e..59ff099d 100644
--- a/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
+++ b/core/src/main/scala/org/http4s/blaze/channel/nio1/SelectorLoop.scala
@@ -127,7 +127,7 @@ final class SelectorLoop(
       mkStage: SelectionKey => Selectable
   ): Unit =
     enqueueTask(new Runnable {
-      override def run(): Unit = {
+      override def run(): Unit =
         if (!selector.isOpen) {
           ch.close()
         } else {
@@ -140,12 +140,11 @@ final class SelectorLoop(
             key.attach(head)
             logger.debug("Channel initialized.")
           } catch {
-            case t@(NonFatal(_) | _: ControlThrowable) =>
+            case t @ (NonFatal(_) | _: ControlThrowable) =>
               logger.error(t)("Caught error during channel init.")
               ch.close()
           }
         }
-      }
     })
 
   // Main thread method. The loop will break if the Selector loop is closed
@@ -191,19 +190,16 @@ final class SelectorLoop(
       it.remove()
 
       val selectable = getAttachment(k)
-      try {
-        if (k.isValid) {
-          if (selectable != null) {
-            selectable.opsReady(scratch)
-          } else {
-            k.cancel()
-            logger.error("Illegal state: selector key had null attachment.")
-          }
-        } else if (selectable != null) {
-          selectable.close(None)
+      try if (k.isValid) {
+        if (selectable != null) {
+          selectable.opsReady(scratch)
+        } else {
+          k.cancel()
+          logger.error("Illegal state: selector key had null attachment.")
         }
-      }
-      catch {
+      } else if (selectable != null) {
+        selectable.close(None)
+      } catch {
         case t @ (NonFatal(_) | _: ControlThrowable) =>
           logger.error(t)("Error performing channel operations. Closing channel.")
           try selectable.close(Some(t))
