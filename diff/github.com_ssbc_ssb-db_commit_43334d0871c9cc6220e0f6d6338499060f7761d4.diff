From 6f89f45609fabc0da17a7d2d756bc1b30038ec4b Mon Sep 17 00:00:00 2001
From: Christian Bundy <christianbundy@fraction.io>
Date: Mon, 8 Jun 2020 13:09:07 -0700
Subject: [PATCH 1/8] Add failing test

---
 test/box-unbox.js | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/test/box-unbox.js b/test/box-unbox.js
index 2459bff..bdda995 100644
--- a/test/box-unbox.js
+++ b/test/box-unbox.js
@@ -331,7 +331,16 @@ module.exports = function (opts) {
 
         t.true(initDone, 'unboxer completed initialisation before get')
         t.deepEqual(msg.value.content, content, 'auto unboxing works')
-        t.end()
+
+        // This tests the default behavior of `ssb.get()`, which should never
+        // decrypt messages by default.
+        ssb.get({ id: msg.key, meta: true }, (err, msg) => {
+          if (err) throw err
+
+          console.log(msg.value)
+          t.equal(typeof msg.value.content, 'string', 'unboxing is not done automatically by default')
+          t.end()
+        })
       })
     })
   })

From 8e60ae49ec0a382b6d0de8fa89af382e25a4931b Mon Sep 17 00:00:00 2001
From: Christian Bundy <christianbundy@fraction.io>
Date: Mon, 8 Jun 2020 13:16:30 -0700
Subject: [PATCH 2/8] Fix get() returning decrypted messages

Problem: The `get()` method isn't supposed to return decrypted messages,
but it is, which means that private messages that the database has
access to might be leaked accidentally by other code (e.g. SSB-OOO,
which exposes `SSB-DB#get()` over the network.

Solution: Re-box messages when `get()` is called without `{ private:
true }`.
---
 create.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/create.js b/create.js
index e223f6e..dd7a9a7 100644
--- a/create.js
+++ b/create.js
@@ -84,7 +84,7 @@ module.exports = function create (path, opts, keys) {
         if (err) return cb(err)
 
         if (!isPrivate) {
-          if (meta) cb(null, { key, value: data.value, timestamp: data.timestamp })
+          if (meta) cb(null, { key, value: u.originalValue(data.value), timestamp: data.timestamp })
           else cb(null, data.value)
         }
         else {

From 090fa86d2919ee7be6d631d4cb9667defe080790 Mon Sep 17 00:00:00 2001
From: Christian Bundy <christianbundy@fraction.io>
Date: Tue, 9 Jun 2020 12:02:47 -0700
Subject: [PATCH 3/8] Add tests to ensure other methods don't unbox

Problem: We don't have any test coverage for our methods to ensure that
they aren't decrypting values that they shouldn't. This is very
dangerous and has resulted in at least one security bug.

Solution: Add tests to all methods that return message data to ensure
that none of them return unboxed data by default. This solves two
problems where `createRawLogStream()` and `getLatest()` were returning
unboxed values that they shouldn't be, just like `get()` was doing. The
list of methods tested was created from `README.md`, `api.md`, and the
manifest found in `index.js`. This module has lots of surface area and
it's hard to know whether all of the holes are now plugged.
---
 README.md         |  8 +++---
 create.js         |  7 ++++-
 extras.js         |  2 +-
 test/box-unbox.js | 65 ++++++++++++++++++++++++++++++++++-------------
 4 files changed, 60 insertions(+), 22 deletions(-)

diff --git a/README.md b/README.md
index 7184d2b..2a0cf1a 100644
--- a/README.md
+++ b/README.md
@@ -278,10 +278,12 @@ you may receive a old message in real time - but for old messages, it makes sens
 
 all standard options are supported.
 
-### db.createUserStream ({id: feed_id, lt,lte,gt,gte: sequence, reverse,old,live,raw: boolean, limit: number})
+### db.createUserStream ({id: feed_id, lt,lte,gt,gte: sequence, reverse,old,live,raw: boolean, limit: number, private: boolean})
 
-`createUserStream` is like `createHistoryStream`, except all options are supported. Local access is allowed, but not
-remote anonymous access. `createUserStream` does decrypt private messages.
+`createUserStream` is like `createHistoryStream`, except all options are
+supported. Local access is allowed, but not remote anonymous access.
+`createUserStream` can decrypt private messages if you pass the option
+`{ private: true }`.
 
 ### db.links({source: feedId?, dest: feedId|msgId|blobId?, rel: string?, meta: true?, keys: true?, values: false?, live:false?, reverse: false?}) -> PullSource
 
diff --git a/create.js b/create.js
index dd7a9a7..96359b6 100644
--- a/create.js
+++ b/create.js
@@ -133,7 +133,12 @@ module.exports = function create (path, opts, keys) {
   }
 
   db.createRawLogStream = function (opts) {
-    return db.stream(opts)
+    return pull(
+      db.stream(opts),
+      pull.map(({ seq, value }) => {
+        return { seq, value: u.originalData(value)}
+      })
+    )
   }
 
   // pull in the features that are needed to pass the tests
diff --git a/extras.js b/extras.js
index 78f6cda..62164cc 100644
--- a/extras.js
+++ b/extras.js
@@ -48,7 +48,7 @@ module.exports = function (db, config, keys) {
       else {
         db.get(value[key].id, function (err, msg) {
         // will NOT expose private plaintext
-          cb(err, { key: value[key].id, value: msg })
+          cb(err, { key: value[key].id, value: u.originalValue(msg) })
         })
       }
     })
diff --git a/test/box-unbox.js b/test/box-unbox.js
index bdda995..bc39704 100644
--- a/test/box-unbox.js
+++ b/test/box-unbox.js
@@ -3,11 +3,12 @@ var tape = require('tape')
 var pull = require('pull-stream')
 var ssbKeys = require('ssb-keys')
 var box1 = require('ssb-private1/box1')
+const { promisify } = require('util')
 
 var createSSB = require('./create-ssb')
 var { originalValue } = require('../util')
 
-module.exports = function (opts) {
+module.exports = function () {
   var alice = ssbKeys.generate()
   var bob = ssbKeys.generate()
   var charles = ssbKeys.generate()
@@ -34,7 +35,6 @@ module.exports = function (opts) {
   tape('error when trying to encrypt without boxer', (t) => {
     t.plan(2);
     const darlene = ssbKeys.generate()
-    const darleneSSB = createSSB('test-ssb-darlene', { keys: darlene })
     const darleneFeed = ssb.createFeed(darlene)
     darleneFeed.add(
       { type: "error", recps: [alice, darlene] },
@@ -52,7 +52,7 @@ module.exports = function (opts) {
     var postObserved
     var listener = ssb.post(msg => { postObserved = msg })
 
-    feed.add(boxed, function (err, msg) {
+    feed.add(boxed, function (err) {
       if (err) throw err
       t.notOk(err)
 
@@ -145,7 +145,7 @@ module.exports = function (opts) {
     var listener = ssb.post(msg => { postObserved = msg })
 
     // secret message sent to self
-    feed.add({ type: 'secret2', secret: "it's a secret!", recps: feed.id }, function (err, msg) {
+    feed.add({ type: 'secret2', secret: "it's a secret!", recps: feed.id }, function (err) {
       if (err) throw err
       t.notOk(err)
 
@@ -264,7 +264,7 @@ module.exports = function (opts) {
   })
 
   tape('addUnboxer (simple)', function (t) {
-    const unboxer = function (ciphertext, value) {
+    const unboxer = function (ciphertext) {
       if (!ciphertext.endsWith('.box.hah')) return
 
       const base64 = ciphertext.replace('.box.hah', '')
@@ -301,12 +301,12 @@ module.exports = function (opts) {
           done()
         }, 500)
       },
-      key: function (ciphertext, value) {
+      key: function (ciphertext) {
         if (!ciphertext.endsWith('.box.hah')) return
 
         return '"the msgKey"'
       },
-      value: function (ciphertext, msgKey) {
+      value: function (ciphertext) {
         const base64 = ciphertext.replace('.box.hah', '')
         return JSON.parse(
           Buffer.from(base64, 'base64').toString('utf8')
@@ -319,28 +319,59 @@ module.exports = function (opts) {
     const content = {
       type: 'poke',
       reason: 'why not',
-      recps: [ '!test' ]
+      recps: [ '!test' ],
+      myFriend: alice.id// Necessary to test links()
     }
     const ciphertext = Buffer.from(JSON.stringify(content)).toString('base64') + '.box.hah'
 
     feed.publish(ciphertext, (_, msg) => {
       t.true(initDone, 'unboxer completed initialisation before publish')
 
-      ssb.get({ id: msg.key, private: true, meta: true }, (err, msg) => {
-        if (err) throw err
+      ssb.get({ id: msg.key, private: true, meta: true }, async (err, msg) => {
+        t.error(err)
 
         t.true(initDone, 'unboxer completed initialisation before get')
         t.deepEqual(msg.value.content, content, 'auto unboxing works')
 
-        // This tests the default behavior of `ssb.get()`, which should never
-        // decrypt messages by default.
-        ssb.get({ id: msg.key, meta: true }, (err, msg) => {
-          if (err) throw err
+        const assertBoxed = (methodName, message) => {
+          t.equal(message.key, msg.key, `${methodName}() returned correct message`)
+          t.equal(typeof message.value.content, 'string', `${methodName}() does not unbox by default`)
+        }
 
-          console.log(msg.value)
-          t.equal(typeof msg.value.content, 'string', 'unboxing is not done automatically by default')
-          t.end()
+        const assertBoxedAsync = async (methodName, options) => 
+          assertBoxed(methodName, await promisify(ssb[methodName])(options))
+
+        // This tests the default behavior of `ssb.get()`, which should never
+        // decrypt messages by default. This is **very important**.
+        await assertBoxedAsync('get', { id: msg.key, meta: true })
+        await assertBoxedAsync('getAtSequence', [msg.value.author, msg.value.sequence])
+        await assertBoxedAsync('getLatest', msg.value.author)
+
+        const assertBoxedSource = (methodName, options) => new Promise((resolve) => {
+          pull(
+            ssb[methodName](options),
+            pull.collect((err, val) => {
+              t.error(err, `${methodName}() does not error`)
+              if (methodName === 'createRawLogStream')  {
+                assertBoxed(methodName, val[0].value)
+              } else {
+                assertBoxed(methodName, val[0])
+              }
+              resolve()
+            })
+          )
         })
+
+        await assertBoxedSource('createLogStream', { limit: 1, reverse: true })
+        await assertBoxedSource('createHistoryStream', { id: msg.value.author, seq: msg.value.sequence, reverse: true})
+        await assertBoxedSource('messagesByType', { type: 'poke', limit: 1, reverse: true })
+        await assertBoxedSource('createFeedStream', { id: msg.value.author, seq: msg.value.sequence, reverse: true})
+        await assertBoxedSource('createUserStream', { id: msg.value.author, seq: msg.value.sequence, reverse: true})
+        await assertBoxedSource('links', { source: msg.value.author, limit: 1, values: true})
+        await assertBoxedSource('createRawLogStream', { source: msg.value.author, limit: 1, reverse: true, values: true})
+
+        t.end()
+
       })
     })
   })

From 307eff22d62f2033b4a09b6520154229a7baa6b6 Mon Sep 17 00:00:00 2001
From: Christian Bundy <christianbundy@fraction.io>
Date: Tue, 9 Jun 2020 12:35:57 -0700
Subject: [PATCH 4/8] Fix `get()` again and undo `getLatest()` changes

Problem: Even while plugging this exact hole and writing tests around
the behavior, I was **still** able to create a security problem because
of the number of options. The `meta` option has a different code path,
which doesn't have the `get()` problem fixed, and I didn't realize this
until I started trying to understand why `getLatest()` had a regression
even though it was only using `get()` under the hood.

Solution: Undo changes to `getLatest()` and fix another code path that
could leak private messages via `get()`.
---
 create.js | 2 +-
 extras.js | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/create.js b/create.js
index 96359b6..ecd4bef 100644
--- a/create.js
+++ b/create.js
@@ -85,7 +85,7 @@ module.exports = function create (path, opts, keys) {
 
         if (!isPrivate) {
           if (meta) cb(null, { key, value: u.originalValue(data.value), timestamp: data.timestamp })
-          else cb(null, data.value)
+          else cb(null, u.originalValue(data.value))
         }
         else {
           const result = db._unbox(data, unbox)
diff --git a/extras.js b/extras.js
index 62164cc..78f6cda 100644
--- a/extras.js
+++ b/extras.js
@@ -48,7 +48,7 @@ module.exports = function (db, config, keys) {
       else {
         db.get(value[key].id, function (err, msg) {
         // will NOT expose private plaintext
-          cb(err, { key: value[key].id, value: u.originalValue(msg) })
+          cb(err, { key: value[key].id, value: msg })
         })
       }
     })

From 788ffc1469a681363e2a7fddbc94131b599da0cf Mon Sep 17 00:00:00 2001
From: Christian Bundy <christianbundy@fraction.io>
Date: Tue, 9 Jun 2020 13:10:56 -0700
Subject: [PATCH 5/8] Add test for other `get()` types

Problem: The `get()` method has lots of options, which leads to lots of
surface area that we need to test. The current code doesn't test the
case where `{ meta: false }`.

Solution: Add two more `get()` calls, both of which test different
invocations of `{ meta: false }`.
---
 test/box-unbox.js | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/test/box-unbox.js b/test/box-unbox.js
index bc39704..116b115 100644
--- a/test/box-unbox.js
+++ b/test/box-unbox.js
@@ -334,8 +334,12 @@ module.exports = function () {
         t.deepEqual(msg.value.content, content, 'auto unboxing works')
 
         const assertBoxed = (methodName, message) => {
-          t.equal(message.key, msg.key, `${methodName}() returned correct message`)
-          t.equal(typeof message.value.content, 'string', `${methodName}() does not unbox by default`)
+          if (typeof message.key === 'string') {
+            t.equal(message.key, msg.key, `${methodName}() returned correct message`)
+            t.equal(typeof message.value.content, 'string', `${methodName}() does not unbox by default`)
+          } else {
+            t.equal(typeof message.content, 'string', `${methodName}() does not unbox by default`)
+          }
         }
 
         const assertBoxedAsync = async (methodName, options) => 
@@ -343,6 +347,8 @@ module.exports = function () {
 
         // This tests the default behavior of `ssb.get()`, which should never
         // decrypt messages by default. This is **very important**.
+        await assertBoxedAsync('get', msg.key)
+        await assertBoxedAsync('get', { id: msg.key })
         await assertBoxedAsync('get', { id: msg.key, meta: true })
         await assertBoxedAsync('getAtSequence', [msg.value.author, msg.value.sequence])
         await assertBoxedAsync('getLatest', msg.value.author)

From 935e48059f71fac0b0151686f91c6bf84a896755 Mon Sep 17 00:00:00 2001
From: Christian Bundy <christianbundy@fraction.io>
Date: Tue, 9 Jun 2020 13:23:06 -0700
Subject: [PATCH 6/8] Add { private: false } checks for all methods

Problem: These methods should all have the same behavior as when you
pass `{ private: false }`, but we aren't explicitly testing that.

Solution: Add an explicit test for `{ private: false }` for all of the
methods that don't have different semantics for that option. (Apparently
some methods don't return *anything* when you pass `{ private: false
}`.)
---
 test/box-unbox.js | 33 +++++++++++++++++++++++++++------
 1 file changed, 27 insertions(+), 6 deletions(-)

diff --git a/test/box-unbox.js b/test/box-unbox.js
index 116b115..08ace05 100644
--- a/test/box-unbox.js
+++ b/test/box-unbox.js
@@ -342,8 +342,12 @@ module.exports = function () {
           }
         }
 
-        const assertBoxedAsync = async (methodName, options) => 
+        const assertBoxedAsync = async (methodName, options) => {
           assertBoxed(methodName, await promisify(ssb[methodName])(options))
+          if (typeof options === 'object' && Array.isArray(options) === false) {
+            assertBoxed(methodName, await promisify(ssb[methodName])({ ...options, private: false } ))
+          }
+        }
 
         // This tests the default behavior of `ssb.get()`, which should never
         // decrypt messages by default. This is **very important**.
@@ -353,21 +357,38 @@ module.exports = function () {
         await assertBoxedAsync('getAtSequence', [msg.value.author, msg.value.sequence])
         await assertBoxedAsync('getLatest', msg.value.author)
 
-        const assertBoxedSource = (methodName, options) => new Promise((resolve) => {
+        const assertBoxedSourceOnce = (methodName, options) => new Promise((resolve) => {
           pull(
             ssb[methodName](options),
             pull.collect((err, val) => {
               t.error(err, `${methodName}() does not error`)
-              if (methodName === 'createRawLogStream')  {
-                assertBoxed(methodName, val[0].value)
-              } else {
-                assertBoxed(methodName, val[0])
+              switch (methodName) {
+                case 'createRawLogStream': 
+                  assertBoxed(methodName, val[0].value)
+                  break;
+                case 'createFeedStream':
+                case 'createUserStream':
+                case 'messagesByType':
+                  // Apparently some methods take `{ private: false }` to mean
+                  // "don't return any private messages". :/
+                  if (options.private === undefined) {
+                    assertBoxed(methodName, val[0].value)
+                  }
+                  break
+                default:
+                  assertBoxed(methodName, val[0])
               }
               resolve()
             })
           )
         })
 
+        // Test the default **and** `{ private: false }`.
+        const assertBoxedSource = async (methodName, options) => {
+          await assertBoxedSourceOnce(methodName, options)
+          await assertBoxedSourceOnce(methodName, { ...options, private: false })
+        }
+
         await assertBoxedSource('createLogStream', { limit: 1, reverse: true })
         await assertBoxedSource('createHistoryStream', { id: msg.value.author, seq: msg.value.sequence, reverse: true})
         await assertBoxedSource('messagesByType', { type: 'poke', limit: 1, reverse: true })

From 4547ae111476b374cf199364c51e11701b4cc664 Mon Sep 17 00:00:00 2001
From: mixmix <whimful@gmail.com>
Date: Thu, 11 Jun 2020 11:34:31 +1200
Subject: [PATCH 7/8] add simple manifest check

---
 index.js         |  2 +-
 test/manifest.js | 21 +++++++++++++++++++++
 2 files changed, 22 insertions(+), 1 deletion(-)
 create mode 100644 test/manifest.js

diff --git a/index.js b/index.js
index 4a77bf3..bb6041a 100644
--- a/index.js
+++ b/index.js
@@ -35,7 +35,7 @@ var manifest = {
   status: 'sync',
   getVectorClock: 'async',
   version: 'sync',
-  help: 'sync',
+  help: 'sync'
 }
 
 module.exports = {
diff --git a/test/manifest.js b/test/manifest.js
new file mode 100644
index 0000000..21c302d
--- /dev/null
+++ b/test/manifest.js
@@ -0,0 +1,21 @@
+'use strict'
+var tape = require('tape')
+var { manifest, init } = require('../')
+
+module.exports = function () {
+  tape('manifest', t => {
+    const _api = {}
+    const opts = {
+      path: `/tmp/ssb-manifest-test-${Date.now()}-${Math.random()}`
+    }
+    const api = init(_api, opts)
+
+    Object.keys(manifest).forEach(method => {
+      t.equal(typeof api[method], 'function', `api.${method}`)
+    })
+
+    t.end()
+  })
+}
+
+if (!module.parent) { module.exports({}) }

From ee983727fc78eea94564733693ccda18a1fffcf2 Mon Sep 17 00:00:00 2001
From: mixmix <whimful@gmail.com>
Date: Thu, 11 Jun 2020 14:19:47 +1200
Subject: [PATCH 8/8] DISABLE db.sublevel, other small tweaks for readability

---
 create.js         | 10 ++++++++-
 index.js          | 56 +++++++++++++++++++++--------------------------
 test/box-unbox.js |  9 ++++----
 test/manifest.js  |  2 ++
 4 files changed, 41 insertions(+), 36 deletions(-)

diff --git a/create.js b/create.js
index ecd4bef..13724d5 100644
--- a/create.js
+++ b/create.js
@@ -136,7 +136,7 @@ module.exports = function create (path, opts, keys) {
     return pull(
       db.stream(opts),
       pull.map(({ seq, value }) => {
-        return { seq, value: u.originalData(value)}
+        return { seq, value: u.originalData(value) }
       })
     )
   }
@@ -144,6 +144,14 @@ module.exports = function create (path, opts, keys) {
   // pull in the features that are needed to pass the tests
   // and that sbot, etc uses but are slow.
   extras(db, opts, keys)
+  // - adds indexes: links, feed, time
+  // - adds methods:
+  //   - db.createLogStream
+  //   - db.createFeedStream
+  //   - db.creareUserStream
+  //   - db.latest
+  //   - db.latestSequence
+  //   - db.getLatest
 
   // writeStream - used in (legacy) replication.
   db.createWriteStream = function (cb) {
diff --git a/index.js b/index.js
index bb6041a..5d85524 100644
--- a/index.js
+++ b/index.js
@@ -5,7 +5,9 @@ var osenv      = require('osenv')
 var mkdirp     = require('mkdirp')
 var rimraf     = require('rimraf')
 var valid      = require('./lib/validators')
-var pkg        = require('./package.json')
+var version    = require('./package.json').version
+var help       = require('./help')
+
 const pull = require('pull-stream')
 const pullNotify = require('pull-notify')
 const pullCat = require('pull-cat')
@@ -106,42 +108,23 @@ module.exports = {
     ssb.since(sequenceNotifier)
 
     return self = {
-      id                       : feed.id,
       keys                     : opts.keys,
+      id                       : feed.id,
 
-      ready                    : function () {
-        return ssb.ready.value
-      },
-
-      progress                 : function () {
-        return ssb.progress
+      whoami                   : () => {
+        return { id: feed.id }
       },
-
-      status                   : function () {
+      version                  : () => version,
+      ready                    : () => ssb.ready.value,
+      progress                 : () => ssb.progress,
+      status                   : () => {
         return {
-          progress: self.progress(),
+          progress: ssb.progress,
           db: ssb.status,
           sync: since()
         }
       },
 
-      version                  : function () {
-        return pkg.version
-      },
-
-      createSequenceStream: () => {
-        // If the initial value is `undefined` we want it to be `-1`.
-        // This is because `-1` is a magic sequence number for an empty log.
-        const initialValue = ssb.since.value !== undefined
-          ? ssb.since.value
-          : -1
-        
-        return pullCat([
-          pull.values([initialValue]),
-          sequenceNotifier.listen()
-        ])
-      },
-
       //temporary!
       _flumeUse                : function (name, flumeview) {
         ssb.use(name, flumeview)
@@ -164,20 +147,31 @@ module.exports = {
       getLatest                : valid.async(ssb.getLatest, 'feedId'),
       latestSequence           : valid.async(ssb.latestSequence, 'feedId'),
       createFeed               : ssb.createFeed,
-      whoami                   : function () { return { id: feed.id } },
       createFeedStream         : valid.source(ssb.createFeedStream, 'readStreamOpts?'),
       createHistoryStream      : valid.source(ssb.createHistoryStream, ['createHistoryStreamOpts'], ['feedId', 'number?', 'boolean?']),
       createLogStream          : valid.source(ssb.createLogStream, 'readStreamOpts?'),
       createUserStream         : valid.source(ssb.createUserStream, 'createUserStreamOpts'),
+      createSequenceStream     : () => {
+        // If the initial value is `undefined` we want it to be `-1`.
+        // This is because `-1` is a magic sequence number for an empty log.
+        const initialValue = ssb.since.value !== undefined
+          ? ssb.since.value
+          : -1
+
+        return pullCat([
+          pull.values([initialValue]),
+          sequenceNotifier.listen()
+        ])
+      },
       links                    : valid.source(ssb.links, 'linksOpts'),
-      sublevel                 : ssb.sublevel,
+      // sublevel                 : ssb.sublevel, // Disabled as does not appear to be used
       messagesByType           : valid.source(ssb.messagesByType, 'string|messagesByTypeOpts'),
       createWriteStream        : ssb.createWriteStream,
       getVectorClock           : ssb.getVectorClock,
       getAtSequence            : ssb.getAtSequence,
       addBoxer                 : ssb.addBoxer,
       addUnboxer               : ssb.addUnboxer,
-      help                     : function () { return require('./help') }
+      help                     : () => help
     }
   }
 }
diff --git a/test/box-unbox.js b/test/box-unbox.js
index 08ace05..08602a9 100644
--- a/test/box-unbox.js
+++ b/test/box-unbox.js
@@ -39,8 +39,8 @@ module.exports = function () {
     darleneFeed.add(
       { type: "error", recps: [alice, darlene] },
       (err, msg) => {
-	t.ok(err);
-	t.notOk(msg);
+        t.ok(err);
+        t.notOk(msg);
         t.end()
       })
   })
@@ -165,7 +165,7 @@ module.exports = function () {
           )
 
           listener()
-          t.true(typeof postObserved.value.content === 'string', 'post obs messages should not be decrypted')
+          t.true(typeof postObserved.value.content === 'string', 'db.post obs messages should not be decrypted')
 
           t.end()
         })
@@ -363,7 +363,7 @@ module.exports = function () {
             pull.collect((err, val) => {
               t.error(err, `${methodName}() does not error`)
               switch (methodName) {
-                case 'createRawLogStream': 
+                case 'createRawLogStream':
                   assertBoxed(methodName, val[0].value)
                   break;
                 case 'createFeedStream':
@@ -396,6 +396,7 @@ module.exports = function () {
         await assertBoxedSource('createUserStream', { id: msg.value.author, seq: msg.value.sequence, reverse: true})
         await assertBoxedSource('links', { source: msg.value.author, limit: 1, values: true})
         await assertBoxedSource('createRawLogStream', { source: msg.value.author, limit: 1, reverse: true, values: true})
+        // createRawLogStream currently not exported as a method
 
         t.end()
 
diff --git a/test/manifest.js b/test/manifest.js
index 21c302d..32ed4a1 100644
--- a/test/manifest.js
+++ b/test/manifest.js
@@ -10,6 +10,8 @@ module.exports = function () {
     }
     const api = init(_api, opts)
 
+    Object.keys(api).forEach(m => console.log(m))
+
     Object.keys(manifest).forEach(method => {
       t.equal(typeof api[method], 'function', `api.${method}`)
     })
