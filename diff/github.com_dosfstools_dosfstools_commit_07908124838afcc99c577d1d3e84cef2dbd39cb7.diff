From 07908124838afcc99c577d1d3e84cef2dbd39cb7 Mon Sep 17 00:00:00 2001
From: Andreas Bombe <aeb@debian.org>
Date: Fri, 11 Sep 2015 19:47:29 +0200
Subject: [PATCH] set_fat(): Fix off-by-2 error leading to corruption in FAT12
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

In FAT12 two 12 bit entries are combined to a 24 bit value (three
bytes). Therefore, when an even numbered FAT entry is set in FAT12, it
must be be combined with the following entry. To prevent accessing
beyond the end of the FAT array, it must be checked that the cluster is
not the last one.

Previously, the check tested that the requested cluster was equal to
fs->clusters - 1. However, fs->clusters is the number of data clusters
not including the two reserved FAT entries at the start so the test
triggered two clusters early.

If the third to last entry was written on a FAT12 filesystem with an
odd number of clusters, the second to last entry would be corrupted.
This corruption may also lead to invalid memory accesses when the
corrupted entry becomes out of bounds and is used later.

Change the test to fs->clusters + 1 to fix.

Reported-by: Hanno BÃ¶ck
Signed-off-by: Andreas Bombe <aeb@debian.org>
---
 src/fat.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/fat.c b/src/fat.c
index 0c19184..845b748 100644
--- a/src/fat.c
+++ b/src/fat.c
@@ -205,7 +205,7 @@ void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)
 	    data[1] = new >> 4;
 	} else {
 	    FAT_ENTRY subseqEntry;
-	    if (cluster != fs->clusters - 1)
+	    if (cluster != fs->clusters + 1)
 		get_fat(&subseqEntry, fs->fat, cluster + 1, fs);
 	    else
 		subseqEntry.value = 0;
