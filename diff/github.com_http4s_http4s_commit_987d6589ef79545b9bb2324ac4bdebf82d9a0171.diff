From e8d30d34753220cbd49f836cc49310463709170a Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 15 Jan 2021 21:47:49 -0500
Subject: [PATCH 01/35] Upgrade to Scala 2.13.4

---
 .github/workflows/ci.yml   | 4 ++--
 project/Http4sPlugin.scala | 4 +---
 project/plugins.sbt        | 2 +-
 3 files changed, 4 insertions(+), 6 deletions(-)

diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index e7b44215135..8184b18ee3e 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -26,7 +26,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.12, 2.13.3]
+        scala: [2.12.12, 2.13.4]
         java: [adopt@1.8, adopt@1.11, adopt@1.15]
     runs-on: ${{ matrix.os }}
     steps:
@@ -83,7 +83,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.13.3]
+        scala: [2.13.4]
         java: [adopt@1.8]
     runs-on: ${{ matrix.os }}
     steps:
diff --git a/project/Http4sPlugin.scala b/project/Http4sPlugin.scala
index fc14bdbb1e1..df1f3365962 100644
--- a/project/Http4sPlugin.scala
+++ b/project/Http4sPlugin.scala
@@ -22,7 +22,7 @@ object Http4sPlugin extends AutoPlugin {
 
   override def requires = Http4sOrgPlugin
 
-  val scala_213 = "2.13.3"
+  val scala_213 = "2.13.4"
   val scala_212 = "2.12.12"
 
   override lazy val globalSettings = Seq(
@@ -93,8 +93,6 @@ object Http4sPlugin extends AutoPlugin {
     // Incompatible with latest circe: https://github.com/circe/circe/pull/1591
     dependencyUpdatesFilter -= moduleFilter(name = "jawn*", revision = "1.0.2"),
     dependencyUpdatesFilter -= moduleFilter(name = "jawn*", revision = "1.0.3"),
-    // https://github.com/scalacenter/scalafix/issues/1299
-    dependencyUpdatesFilter -= moduleFilter(name = "scalafix-core", revision = "0.9.24"),
     // Unsure about binary compatibility
     dependencyUpdatesFilter -= moduleFilter(name = "okio", revision = "2.10.0"),
 
diff --git a/project/plugins.sbt b/project/plugins.sbt
index adcb13916d6..0581d1bf03b 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -3,7 +3,7 @@ libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
 // https://github.com/coursier/coursier/issues/450
 classpathTypes += "maven-plugin"
 
-addSbtPlugin("ch.epfl.scala"              %  "sbt-scalafix"              % "0.9.23")
+addSbtPlugin("ch.epfl.scala"              %  "sbt-scalafix"              % "0.9.25")
 addSbtPlugin("com.earldouglas"            %  "xsbt-web-plugin"           % "4.2.1")
 addSbtPlugin("com.eed3si9n"               %  "sbt-buildinfo"             % "0.10.0")
 addSbtPlugin("com.eed3si9n"               %  "sbt-unidoc"                % "0.4.3")

From a971a1e0c91fc5c28587e257607fc55fd8a8db56 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 15 Jan 2021 23:05:26 -0500
Subject: [PATCH 02/35] Scala 2.12.13, too

---
 .github/workflows/ci.yml   | 10 +++++-----
 project/Http4sPlugin.scala |  2 +-
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 8184b18ee3e..762b59a1624 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -26,7 +26,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.12, 2.13.4]
+        scala: [2.12.13, 2.13.4]
         java: [adopt@1.8, adopt@1.11, adopt@1.15]
     runs-on: ${{ matrix.os }}
     steps:
@@ -132,7 +132,7 @@ jobs:
           echo "$SSH_PRIVATE_KEY" | ssh-add -
           git config --global user.name "GitHub Actions CI"
           git config --global user.email "ghactions@invalid"
-          sbt ++2.12.12 website/makeSite website/ghpagesPushSite
+          sbt ++2.12.13 website/makeSite website/ghpagesPushSite
 
                 
 
@@ -145,7 +145,7 @@ jobs:
           echo "$SSH_PRIVATE_KEY" | ssh-add -
           git config --global user.name "GitHub Actions CI"
           git config --global user.email "ghactions@invalid"
-          sbt ++2.12.12 docs/makeSite docs/ghpagesPushSite
+          sbt ++2.12.13 docs/makeSite docs/ghpagesPushSite
 
                 
 
@@ -154,7 +154,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.12]
+        scala: [2.12.13]
         java: [adopt@1.8]
     runs-on: ${{ matrix.os }}
     steps:
@@ -183,7 +183,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.12]
+        scala: [2.12.13]
         java: [adopt@1.8]
     runs-on: ${{ matrix.os }}
     steps:
diff --git a/project/Http4sPlugin.scala b/project/Http4sPlugin.scala
index df1f3365962..554c239d0fd 100644
--- a/project/Http4sPlugin.scala
+++ b/project/Http4sPlugin.scala
@@ -23,7 +23,7 @@ object Http4sPlugin extends AutoPlugin {
   override def requires = Http4sOrgPlugin
 
   val scala_213 = "2.13.4"
-  val scala_212 = "2.12.12"
+  val scala_212 = "2.12.13"
 
   override lazy val globalSettings = Seq(
     isCi := sys.env.get("CI").isDefined

From 9987b0090a12e083513d3a50d73c271a057a17a2 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 15 Jan 2021 23:56:58 -0500
Subject: [PATCH 03/35] Fix client exhausitivity checks

---
 .../http4s/client/middleware/FollowRedirectSuite.scala | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala b/client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala
index 1e19dc204ec..b1937e788d3 100644
--- a/client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala
+++ b/client/src/test/scala/org/http4s/client/middleware/FollowRedirectSuite.scala
@@ -152,7 +152,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
     val req = Request[IO](PUT, uri"http://localhost/303").withEntity("foo")
     client
       .run(req)
-      .use { case Ok(resp) =>
+      .use { resp =>
         resp.headers.get("X-Original-Content-Length".ci).map(_.value).pure[IO]
       }
       .map(_.get)
@@ -206,7 +206,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
       uri"http://localhost/different-authority",
       Header("Authorization", "Bearer s3cr3t"))
     req
-      .flatMap(client.run(_).use { case Ok(resp) =>
+      .flatMap(client.run(_).use { resp =>
         resp.headers.get("X-Original-Authorization".ci).map(_.value).pure[IO]
       })
       .assertEquals(Some(""))
@@ -218,7 +218,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
       uri"http://localhost/307",
       Header("Authorization", "Bearer s3cr3t"))
     req
-      .flatMap(client.run(_).use { case Ok(resp) =>
+      .flatMap(client.run(_).use { case resp =>
         resp.headers.get("X-Original-Authorization".ci).map(_.value).pure[IO]
       })
       .assertEquals(Some("Bearer s3cr3t"))
@@ -227,7 +227,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
   test("FollowRedirect should ggRecord the intermediate URIs") {
     client
       .run(Request[IO](uri = uri"http://localhost/loop/0"))
-      .use { case Ok(resp) =>
+      .use { resp =>
         IO.pure(FollowRedirect.getRedirectUris(resp))
       }
       .assertEquals(
@@ -241,7 +241,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
   test("FollowRedirect should ggNot add any URIs when there are no redirects") {
     client
       .run(Request[IO](uri = uri"http://localhost/loop/100"))
-      .use { case Ok(resp) =>
+      .use { case resp =>
         IO.pure(FollowRedirect.getRedirectUris(resp))
       }
       .assertEquals(List.empty[Uri])

From a3446d243d72922989ba545370b57296fd451e92 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Fri, 29 Jan 2021 15:55:52 -0800
Subject: [PATCH 04/35] Better Timeouts, Valid Client Connections

---
 .../ember/client/EmberClientBuilder.scala     | 59 ++++++--------
 .../ember/client/internal/ClientHelpers.scala | 55 ++++++-------
 .../scala/org/http4s/ember/core/Parser.scala  | 23 +++---
 .../scala/org/http4s/ember/core/Util.scala    | 79 ------------------
 .../org/http4s/ember/core/ParsingSpec.scala   | 18 +++--
 .../ember/server/internal/ServerHelpers.scala | 80 +++++++++++--------
 6 files changed, 119 insertions(+), 195 deletions(-)
 delete mode 100644 ember-core/src/main/scala/org/http4s/ember/core/Util.scala

diff --git a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
index 6cc3338a7b6..24645162dc2 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
@@ -40,40 +40,12 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
     private val logger: Logger[F],
     val chunkSize: Int,
     val maxResponseHeaderSize: Int,
+    private val idleReadTime: Duration,
     val timeout: Duration,
     val additionalSocketOptions: List[SocketOptionMapping[_]],
     val userAgent: Option[`User-Agent`]
 ) { self =>
 
-  @deprecated("Preserved for binary compatibility", "0.21.7")
-  private[EmberClientBuilder] def this(
-      blockerOpt: Option[Blocker],
-      tlsContextOpt: Option[TLSContext],
-      sgOpt: Option[SocketGroup],
-      maxTotal: Int,
-      maxPerKey: RequestKey => Int,
-      idleTimeInPool: Duration,
-      logger: Logger[F],
-      chunkSize: Int,
-      maxResponseHeaderSize: Int,
-      timeout: Duration,
-      additionalSocketOptions: List[SocketOptionMapping[_]]
-  ) =
-    this(
-      blockerOpt = blockerOpt,
-      tlsContextOpt = tlsContextOpt,
-      sgOpt = sgOpt,
-      maxTotal = maxTotal,
-      maxPerKey = maxPerKey,
-      idleTimeInPool = idleTimeInPool,
-      logger = logger,
-      chunkSize = chunkSize,
-      maxResponseHeaderSize = maxResponseHeaderSize,
-      timeout = timeout,
-      additionalSocketOptions = additionalSocketOptions,
-      userAgent = EmberClientBuilder.Defaults.userAgent
-    )
-
   private def copy(
       blockerOpt: Option[Blocker] = self.blockerOpt,
       tlsContextOpt: Option[TLSContext] = self.tlsContextOpt,
@@ -84,6 +56,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
       logger: Logger[F] = self.logger,
       chunkSize: Int = self.chunkSize,
       maxResponseHeaderSize: Int = self.maxResponseHeaderSize,
+      idleReadTime: Duration = self.idleReadTime,
       timeout: Duration = self.timeout,
       additionalSocketOptions: List[SocketOptionMapping[_]] = self.additionalSocketOptions,
       userAgent: Option[`User-Agent`] = self.userAgent
@@ -98,6 +71,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
       logger = logger,
       chunkSize = chunkSize,
       maxResponseHeaderSize = maxResponseHeaderSize,
+      idleReadTime = idleReadTime,
       timeout = timeout,
       additionalSocketOptions = additionalSocketOptions,
       userAgent = userAgent
@@ -154,7 +128,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
                 socket.endOfInput.attempt.void >>
                 socket.endOfOutput.attempt.void >>
                 socket.close.attempt.void >>
-                shutdown
+                shutdown.attempt.void
             }
           )
           .withDefaultReuseState(Reusable.DontReuse)
@@ -164,9 +138,22 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
           .withOnReaperException(_ => Applicative[F].unit)
       pool <- builder.build
     } yield {
-      val client = Client[F](request =>
+      val client = Client[F] { request =>
+        def getValidManaged: Resource[F, Managed[F, (RequestKeySocket[F], F[Unit])]] =
+          pool.take(RequestKey.fromRequest(request)).flatMap { managed =>
+            Resource
+              .liftF(managed.value._1.socket.isOpen)
+              .ifM(
+                managed.pure[Resource[F, *]],
+                // Already Closed,
+                // The Resource Scopes Aren't doing us anything
+                // if we have max removed from pool we will need to revisit
+                Resource.liftF(managed.canBeReused.set(Reusable.DontReuse)) >>
+                  getValidManaged
+              )
+          }
         for {
-          managed <- pool.take(RequestKey.fromRequest(request))
+          managed <- getValidManaged
           _ <- Resource.liftF(
             pool.state.flatMap { poolState =>
               logger.trace(
@@ -182,6 +169,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
                 managed.canBeReused,
                 chunkSize,
                 maxResponseHeaderSize,
+                idleReadTime,
                 timeout,
                 userAgent
               )
@@ -199,7 +187,8 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
                   case ExitCase.Canceled => Sync[F].unit
                   case ExitCase.Error(_) => Sync[F].unit
                 }))
-        } yield responseResource)
+        } yield responseResource
+      }
       new EmberClient[F](client, pool)
     }
 }
@@ -217,6 +206,7 @@ object EmberClientBuilder {
       logger = Slf4jLogger.getLogger[F],
       chunkSize = Defaults.chunkSize,
       maxResponseHeaderSize = Defaults.maxResponseHeaderSize,
+      idleReadTime = Defaults.idleReadTime,
       timeout = Defaults.timeout,
       additionalSocketOptions = Defaults.additionalSocketOptions,
       userAgent = Defaults.userAgent
@@ -226,7 +216,8 @@ object EmberClientBuilder {
     val acgFixedThreadPoolSize: Int = 100
     val chunkSize: Int = 32 * 1024
     val maxResponseHeaderSize: Int = 4096
-    val timeout: Duration = 60.seconds
+    val idleReadTime = org.http4s.client.defaults.RequestTimeout
+    val timeout: Duration = org.http4s.client.defaults.RequestTimeout
 
     // Pool Settings
     val maxPerKey = { (_: RequestKey) =>
diff --git a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
index 3ed569f1899..523347521c6 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
@@ -17,7 +17,7 @@
 package org.http4s.ember.client.internal
 
 import org.http4s.ember.client._
-import fs2.concurrent._
+import fs2._
 import fs2.io.tcp._
 import cats._
 import cats.data.NonEmptyList
@@ -30,7 +30,6 @@ import org.http4s._
 import org.http4s.implicits._
 import org.http4s.client.RequestKey
 import _root_.org.http4s.ember.core.{Encoder, Parser}
-import _root_.org.http4s.ember.core.Util.readWithTimeout
 import _root_.fs2.io.tcp.SocketGroup
 import _root_.fs2.io.tls._
 import _root_.io.chrisdavenport.keypool.Reusable
@@ -85,10 +84,11 @@ private[client] object ClientHelpers {
       reuseable: Ref[F, Reusable],
       chunkSize: Int,
       maxResponseHeaderSize: Int,
+      idleReadTimeout: Duration,
       timeout: Duration,
       userAgent: Option[`User-Agent`]
   ): Resource[F, Response[F]] = {
-    val RT: Timer[Resource[F, *]] = Timer[F].mapK(Resource.liftK[F])
+    // val RT: Timer[Resource[F, *]] = Timer[F].mapK(Resource.liftK[F])
 
     def writeRequestToSocket(
         req: Request[F],
@@ -101,33 +101,30 @@ private[client] object ClientHelpers {
         .resource
         .drain
 
-    def onNoTimeout(req: Request[F], socket: Socket[F]): Resource[F, Response[F]] =
-      writeRequestToSocket(req, socket, None) >>
-        Parser.Response.parser(maxResponseHeaderSize)(
-          socket.reads(chunkSize, None)
-        )
-
-    def onTimeout(
-        req: Request[F],
-        socket: Socket[F],
-        fin: FiniteDuration): Resource[F, Response[F]] =
-      for {
-        start <- RT.clock.realTime(MILLISECONDS)
-        _ <- writeRequestToSocket(req, socket, Option(fin))
-        timeoutSignal <- Resource.liftF(SignallingRef[F, Boolean](true))
-        sent <- RT.clock.realTime(MILLISECONDS)
-        remains = fin - (sent - start).millis
-        resp <- Parser.Response.parser[F](maxResponseHeaderSize)(
-          readWithTimeout(socket, start, remains, timeoutSignal.get, chunkSize)
-        )
-        _ <- Resource.liftF(timeoutSignal.set(false).void)
-      } yield resp
-
-    def writeRead(req: Request[F]) =
-      timeout match {
-        case t: FiniteDuration => onTimeout(req, requestKeySocket.socket, t)
-        case _ => onNoTimeout(req, requestKeySocket.socket)
+    def writeRead(req: Request[F]) = writeRequestToSocket(req, requestKeySocket.socket, None) >> {
+      val idle: Option[FiniteDuration] = idleReadTimeout match {
+        case idle: FiniteDuration => Some(idle)
+        case _ => None
+      }
+      def errorIfEmpty(
+          socket: Socket[F],
+          maxBytes: Int,
+          timeout: Option[FiniteDuration]): Stream[F, Byte] =
+        Stream.eval(socket.read(maxBytes, timeout)).flatMap {
+          case Some(bytes) =>
+            Stream.chunk(bytes) ++ errorIfEmpty(socket, maxBytes, timeout)
+          case None => Stream.raiseError(new RuntimeException("Received Unexpected EOF"))
+        }
+      val action = timeout match {
+        case i: FiniteDuration =>
+          Parser.Response.parser(maxResponseHeaderSize, Some(i))(
+            errorIfEmpty(requestKeySocket.socket, chunkSize, idle))
+        case _ =>
+          Parser.Response.parser(maxResponseHeaderSize, None)(
+            errorIfEmpty(requestKeySocket.socket, chunkSize, idle))
       }
+      action
+    }
 
     for {
       processedReq <- Resource.liftF(preprocessRequest(request, userAgent))
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
index f6e881a8eb3..3fa70528765 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
@@ -24,6 +24,7 @@ import fs2._
 import org.http4s._
 import scala.annotation.switch
 import scala.collection.mutable
+import scala.concurrent.duration.FiniteDuration
 
 private[ember] object Parser {
 
@@ -334,9 +335,10 @@ private[ember] object Parser {
       }
     }
 
-    def parser[F[_]: Concurrent](maxHeaderLength: Int)(s: Stream[F, Byte]): F[Request[F]] =
+    def parser[F[_]: Concurrent: Timer](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
+        s: Stream[F, Byte]): F[Request[F]] =
       Deferred[F, Headers].flatMap { trailers =>
-        ReqPrelude
+        val base = ReqPrelude
           .parsePrelude[F](s, maxHeaderLength, None)
           .flatMap { case (method, uri, httpVersion, rest) =>
             HeaderP.parseHeaders(rest, maxHeaderLength, None).flatMap {
@@ -361,17 +363,17 @@ private[ember] object Parser {
           }
           .stream
           .take(1)
-          .compile
-          .lastOrError
-      }
 
+        timeout.fold(base)(duration => base.timeout(duration)).compile.lastOrError
+      }
   }
 
   object Response {
-    def parser[F[_]: Concurrent](maxHeaderLength: Int)(
-        s: Stream[F, Byte]): Resource[F, Response[F]] =
+    def parser[F[_]: Concurrent: Timer](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
+        s: Stream[F, Byte]
+    ): Resource[F, Response[F]] =
       Resource.liftF(Deferred[F, Headers]).flatMap { trailers =>
-        RespPrelude
+        val base = RespPrelude
           .parsePrelude(s, maxHeaderLength, None)
           .flatMap { case (httpVersion, status, s) =>
             HeaderP.parseHeaders(s, maxHeaderLength, None).flatMap {
@@ -394,9 +396,8 @@ private[ember] object Parser {
           }
           .stream
           .take(1)
-          .compile
-          .resource
-          .lastOrError
+
+        timeout.fold(base)(duration => base.timeout(duration)).compile.resource.lastOrError
       }
 
     object RespPrelude {
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Util.scala b/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
deleted file mode 100644
index 2522fc0f07a..00000000000
--- a/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright 2019 http4s.org
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.http4s.ember.core
-
-import cats._
-import cats.effect.{ApplicativeThrow => _, _}
-import cats.syntax.all._
-import fs2._
-import fs2.io.tcp.Socket
-import scala.concurrent.duration._
-import scala.concurrent.duration.MILLISECONDS
-import java.time.Instant
-
-private[ember] object Util {
-
-  /** The issue with a normal http body is that there is no termination character,
-    * thus unless you have content-length and the client still has their input side open,
-    * the server cannot know whether more data follows or not
-    * This means this Stream MUST be infinite and additional parsing is required.
-    * To know how much client input to consume
-    *
-    * Function if timeout reads via socket read and then incrementally lowers
-    * the remaining time after each read.
-    * By setting the timeout signal outside this after the
-    * headers have been read it triggers this function
-    * to then not timeout on the remaining body.
-    */
-  def readWithTimeout[F[_]](
-      socket: Socket[F],
-      started: Long,
-      timeout: FiniteDuration,
-      shallTimeout: F[Boolean],
-      chunkSize: Int
-  )(implicit F: ApplicativeThrow[F], C: Clock[F]): Stream[F, Byte] = {
-    def whenWontTimeout: Stream[F, Byte] =
-      socket.reads(chunkSize, None)
-    def whenMayTimeout(remains: FiniteDuration): Stream[F, Byte] =
-      if (remains <= 0.millis)
-        Stream
-          .eval(C.realTime(MILLISECONDS))
-          .flatMap(now =>
-            Stream.raiseError[F](
-              EmberException.Timeout(Instant.ofEpochMilli(started), Instant.ofEpochMilli(now))
-            ))
-      else
-        for {
-          start <- Stream.eval(C.realTime(MILLISECONDS))
-          read <- Stream.eval(socket.read(chunkSize, Some(remains))) //  Each Read Yields
-          end <- Stream.eval(C.realTime(MILLISECONDS))
-          out <- read.fold[Stream[F, Byte]](
-            Stream.empty
-          )(
-            Stream.chunk(_).covary[F] ++ go(remains - (end - start).millis)
-          )
-        } yield out
-    def go(remains: FiniteDuration): Stream[F, Byte] =
-      Stream
-        .eval(shallTimeout)
-        .ifM(
-          whenMayTimeout(remains),
-          whenWontTimeout
-        )
-    go(timeout)
-  }
-}
diff --git a/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala b/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
index 17aec001fcd..102247b094e 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
@@ -38,24 +38,24 @@ class ParsingSpec extends Specification with CatsIO {
     def httpifyString(s: String): String = s.replace("\n", "\r\n")
 
     // Only for Use with Text Requests
-    def parseRequestRig[F[_]: Concurrent](s: String): F[Request[F]] = {
+    def parseRequestRig[F[_]: Concurrent: Timer](s: String): F[Request[F]] = {
       val byteStream: Stream[F, Byte] = Stream
         .emit(s)
         .covary[F]
         .map(httpifyString)
         .through(fs2.text.utf8Encode[F])
 
-      Parser.Request.parser[F](Int.MaxValue)(byteStream)
+      Parser.Request.parser[F](Int.MaxValue, None)(byteStream)
     }
 
-    def parseResponseRig[F[_]: Concurrent](s: String): Resource[F, Response[F]] = {
+    def parseResponseRig[F[_]: Concurrent: Timer](s: String): Resource[F, Response[F]] = {
       val byteStream: Stream[F, Byte] = Stream
         .emit(s)
         .covary[F]
         .map(httpifyString)
         .through(fs2.text.utf8Encode[F])
 
-      Parser.Response.parser[F](Int.MaxValue)(byteStream) //(logger)
+      Parser.Response.parser[F](Int.MaxValue, None)(byteStream) //(logger)
     }
 
     def forceScopedParsing[F[_]: Sync](s: String): Stream[F, Byte] = {
@@ -168,7 +168,9 @@ class ParsingSpec extends Specification with CatsIO {
       (for {
         parsed <-
           Parser.Response
-            .parser[IO](defaultMaxHeaderLength)(Helpers.forceScopedParsing[IO](raw)) //(logger)
+            .parser[IO](defaultMaxHeaderLength, None)(
+              Helpers.forceScopedParsing[IO](raw)
+            ) //(logger)
             .use { resp =>
               resp.body.through(text.utf8Decode).compile.string
             }
@@ -185,7 +187,7 @@ class ParsingSpec extends Specification with CatsIO {
       val baseBv = ByteVector.fromBase64(base).get
 
       Parser.Response
-        .parser[IO](defaultMaxHeaderLength)(Stream.chunk(ByteVectorChunk(baseBv)))
+        .parser[IO](defaultMaxHeaderLength, None)(Stream.chunk(ByteVectorChunk(baseBv)))
         .use { resp =>
           resp.body.through(text.utf8Decode).compile.string
 
@@ -220,7 +222,7 @@ class ParsingSpec extends Specification with CatsIO {
           Stream.chunk(Chunk.array(s.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))))
 
       Parser.Response
-        .parser[IO](defaultMaxHeaderLength)(byteStream)
+        .parser[IO](defaultMaxHeaderLength, None)(byteStream)
         .use { resp =>
           resp.body.through(text.utf8Decode).compile.string.map { body =>
             body must beEqualTo("MozillaDeveloperNetwork")
@@ -252,7 +254,7 @@ class ParsingSpec extends Specification with CatsIO {
           Stream.chunk(Chunk.array(s.getBytes(java.nio.charset.StandardCharsets.US_ASCII))))
 
       Parser.Response
-        .parser[IO](defaultMaxHeaderLength)(byteStream)
+        .parser[IO](defaultMaxHeaderLength, None)(byteStream)
         .use { resp =>
           for {
             body <- resp.body.through(text.utf8Decode).compile.string
diff --git a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
index e4f25ab0854..79ddc5d7745 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
@@ -17,9 +17,9 @@
 package org.http4s.ember.server.internal
 
 import fs2._
-import fs2.concurrent._
 import fs2.io.tcp._
 import fs2.io.tls._
+import cats._
 import cats.effect._
 import cats.syntax.all._
 import scala.concurrent.duration._
@@ -28,9 +28,10 @@ import org.http4s._
 import org.http4s.implicits._
 import org.http4s.headers.{Connection, Date}
 import _root_.org.http4s.ember.core.{Encoder, Parser}
-import _root_.org.http4s.ember.core.Util.readWithTimeout
 import _root_.io.chrisdavenport.log4cats.Logger
 import cats.data.NonEmptyList
+import java.util.concurrent.TimeoutException
+import java.nio.channels.InterruptedByTimeoutException
 
 private[server] object ServerHelpers {
 
@@ -59,30 +60,33 @@ private[server] object ServerHelpers {
       idleTimeout: Duration = 60.seconds,
       additionalSocketOptions: List[SocketOptionMapping[_]] = List.empty,
       logger: Logger[F]
-  )(implicit F: Concurrent[F], C: Clock[F]): Stream[F, Nothing] = {
+  )(implicit F: Concurrent[F], T: Timer[F]): Stream[F, Nothing] = {
     def socketReadRequest(
         socket: Socket[F],
         requestHeaderReceiveTimeout: Duration,
-        receiveBufferSize: Int,
-        isReused: Boolean
+        receiveBufferSize: Int
     ): F[Request[F]] = {
-      val (initial, readDuration) = (requestHeaderReceiveTimeout, idleTimeout, isReused) match {
-        case (fin: FiniteDuration, idle: FiniteDuration, true) => (true, idle + fin)
-        case (fin: FiniteDuration, _, false) => (true, fin)
-        case _ => (false, Duration.Zero)
+      val idle: Option[FiniteDuration] = idleTimeout match {
+        case idle: FiniteDuration => Some(idle)
+        case _ => None
       }
-
-      SignallingRef[F, Boolean](initial).flatMap { timeoutSignal =>
-        C.realTime(MILLISECONDS)
-          .flatMap(now =>
-            Parser.Request
-              .parser(maxHeaderSize)(
-                readWithTimeout[F](socket, now, readDuration, timeoutSignal.get, receiveBufferSize)
-              )
-              .flatMap { req =>
-                timeoutSignal.set(false).as(req)
-              })
+      def errorIfEmpty(
+          socket: Socket[F],
+          maxBytes: Int,
+          timeout: Option[FiniteDuration]): Stream[F, Byte] =
+        Stream.eval(socket.read(maxBytes, timeout)).flatMap {
+          case Some(bytes) =>
+            Stream.chunk(bytes) ++ errorIfEmpty(socket, maxBytes, timeout)
+          case None => Stream.raiseError(new RuntimeException("Received Unexpected EOF"))
+        }
+      val action = requestHeaderReceiveTimeout match {
+        case i: FiniteDuration =>
+          Parser.Request.parser(maxHeaderSize, Some(i))(
+            errorIfEmpty(socket, receiveBufferSize, idle))
+        case _ =>
+          Parser.Request.parser(maxHeaderSize, None)(errorIfEmpty(socket, receiveBufferSize, idle))
       }
+      action
     }
 
     def upgradeSocket(
@@ -94,9 +98,9 @@ private[server] object ServerHelpers {
           .widen[Socket[F]]
       }
 
-    def runApp(socket: Socket[F], isReused: Boolean): F[(Request[F], Response[F])] =
+    def runApp(socket: Socket[F]): F[(Request[F], Response[F])] =
       for {
-        req <- socketReadRequest(socket, requestHeaderReceiveTimeout, receiveBufferSize, isReused)
+        req <- socketReadRequest(socket, requestHeaderReceiveTimeout, receiveBufferSize)
         resp <- httpApp
           .run(req)
           .handleErrorWith(errorHandler)
@@ -131,18 +135,26 @@ private[server] object ServerHelpers {
     }
 
     def withUpgradedSocket(socket: Socket[F]): Stream[F, Nothing] =
-      (Stream(false) ++ Stream(true).repeat)
-        .flatMap { isReused =>
-          Stream
-            .eval(runApp(socket, isReused).attempt)
-            .evalMap {
-              case Right((req, resp)) =>
-                postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])
-              case other => other.pure[F]
-            }
-            .evalTap {
-              case Right((request, response)) => send(socket)(Some(request), response)
-              case Left(err) =>
+      Stream
+        .eval(runApp(socket).attempt)
+        .repeat
+        .evalMap {
+          case Right((req, resp)) =>
+            postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])
+          case other => other.pure[F]
+        }
+        .evalTap {
+          case Right((request, response)) => send(socket)(Some(request), response)
+          case Left(err) =>
+            err match {
+              // Timeouts Do Not Get Responses
+              // Thrown by Stream.timeout or Concurrent.timeout
+              case _: TimeoutException =>
+                errorHandler(
+                  err).void // Lets users see responses, but cannot generate responses i don't like this
+              // Thrown by fs2.io.tcp.Socket read/write
+              case _: InterruptedByTimeoutException => errorHandler(err).void
+              case err =>
                 errorHandler(err)
                   .handleError(_ => serverFailure.covary[F])
                   .flatMap(send(socket)(None, _))

From 59ae341900a38c61d44bd08c58e24db6bc123a73 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Fri, 29 Jan 2021 15:57:32 -0800
Subject: [PATCH 05/35] Unused Import

---
 .../scala/org/http4s/ember/server/internal/ServerHelpers.scala   | 1 -
 1 file changed, 1 deletion(-)

diff --git a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
index 79ddc5d7745..8b0a896d891 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
@@ -19,7 +19,6 @@ package org.http4s.ember.server.internal
 import fs2._
 import fs2.io.tcp._
 import fs2.io.tls._
-import cats._
 import cats.effect._
 import cats.syntax.all._
 import scala.concurrent.duration._

From 507f8791a1fd4c0934231247722f6f522e476a3a Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Fri, 29 Jan 2021 16:07:10 -0800
Subject: [PATCH 06/35] Add MiMa Exceptions

---
 build.sbt | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/build.sbt b/build.sbt
index e737b1a1b77..be89a57b778 100644
--- a/build.sbt
+++ b/build.sbt
@@ -239,7 +239,9 @@ lazy val emberCore = libraryProject("ember-core")
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser.splitHeader"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser.generateHeaders"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser.httpHeaderAndBody"),
-      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Response.parser")
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Response.parser"),
+      ProblemFilters.exclude[MissingClassProblem]("org.http4s.ember.core.Util"),
+      ProblemFilters.exclude[MissingClassProblem]("org.http4s.ember.core.Util$"),
     )
   )
   .dependsOn(core, testing % "test->test")
@@ -278,6 +280,7 @@ lazy val emberClient = libraryProject("ember-client")
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.client.internal.ClientHelpers.request"),
       ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.client.internal.ClientHelpers.request"),
       ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.core.Parser#Response.parser"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.client.EmberClientBuilder.this"),
     )
   )
   .dependsOn(emberCore % "compile;test->test", client % "compile;test->test")

From 3d2b8cc27acfc5fc91181465cd2e879725d28f95 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Fri, 29 Jan 2021 16:16:41 -0800
Subject: [PATCH 07/35] Meth change as well

---
 build.sbt | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/build.sbt b/build.sbt
index be89a57b778..44d14115952 100644
--- a/build.sbt
+++ b/build.sbt
@@ -281,6 +281,8 @@ lazy val emberClient = libraryProject("ember-client")
       ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.client.internal.ClientHelpers.request"),
       ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.core.Parser#Response.parser"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.client.EmberClientBuilder.this"),
+      ProblemFilters.exclude[IncompatibleMethTypeProblem]("org.http4s.ember.client.internal.ClientHelpers.request"),
+      ProblemFilters.exclude[IncompatibleMethTypeProblem]("org.http4s.ember.client.internal.ClientHelpers.request"),
     )
   )
   .dependsOn(emberCore % "compile;test->test", client % "compile;test->test")

From 5599b528ac3cda381d6506e108d4a6a4bd92a245 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Fri, 29 Jan 2021 17:06:28 -0800
Subject: [PATCH 08/35] Add Support for Pipelining

---
 .../ember/client/internal/ClientHelpers.scala | 38 +++++--------
 .../scala/org/http4s/ember/core/Parser.scala  |  8 +--
 .../ember/server/internal/ServerHelpers.scala | 53 ++++++++-----------
 3 files changed, 38 insertions(+), 61 deletions(-)

diff --git a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
index 523347521c6..53dcb13e7f5 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
@@ -17,7 +17,6 @@
 package org.http4s.ember.client.internal
 
 import org.http4s.ember.client._
-import fs2._
 import fs2.io.tcp._
 import cats._
 import cats.data.NonEmptyList
@@ -37,6 +36,12 @@ import javax.net.ssl.SNIHostName
 import org.http4s.headers.{Connection, Date, `User-Agent`}
 
 private[client] object ClientHelpers {
+
+  private def durationToFinite(duration: Duration): Option[FiniteDuration] = duration match {
+    case f: FiniteDuration => Some(f)
+    case _ => None
+  }
+
   def requestToSocketWithKey[F[_]: Concurrent: Timer: ContextShift](
       request: Request[F],
       tlsContextOpt: Option[TLSContext],
@@ -88,7 +93,6 @@ private[client] object ClientHelpers {
       timeout: Duration,
       userAgent: Option[`User-Agent`]
   ): Resource[F, Response[F]] = {
-    // val RT: Timer[Resource[F, *]] = Timer[F].mapK(Resource.liftK[F])
 
     def writeRequestToSocket(
         req: Request[F],
@@ -101,30 +105,14 @@ private[client] object ClientHelpers {
         .resource
         .drain
 
-    def writeRead(req: Request[F]) = writeRequestToSocket(req, requestKeySocket.socket, None) >> {
-      val idle: Option[FiniteDuration] = idleReadTimeout match {
-        case idle: FiniteDuration => Some(idle)
-        case _ => None
+    def writeRead(req: Request[F]): Resource[F, Response[F]] =
+      writeRequestToSocket(req, requestKeySocket.socket, None) >> {
+        Parser.Response
+          .parser(maxResponseHeaderSize, durationToFinite(timeout))(
+            requestKeySocket.socket.reads(chunkSize, durationToFinite(idleReadTimeout))
+          )
+          .map(_._1)
       }
-      def errorIfEmpty(
-          socket: Socket[F],
-          maxBytes: Int,
-          timeout: Option[FiniteDuration]): Stream[F, Byte] =
-        Stream.eval(socket.read(maxBytes, timeout)).flatMap {
-          case Some(bytes) =>
-            Stream.chunk(bytes) ++ errorIfEmpty(socket, maxBytes, timeout)
-          case None => Stream.raiseError(new RuntimeException("Received Unexpected EOF"))
-        }
-      val action = timeout match {
-        case i: FiniteDuration =>
-          Parser.Response.parser(maxResponseHeaderSize, Some(i))(
-            errorIfEmpty(requestKeySocket.socket, chunkSize, idle))
-        case _ =>
-          Parser.Response.parser(maxResponseHeaderSize, None)(
-            errorIfEmpty(requestKeySocket.socket, chunkSize, idle))
-      }
-      action
-    }
 
     for {
       processedReq <- Resource.liftF(preprocessRequest(request, userAgent))
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
index 3fa70528765..93a97c86f09 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
@@ -336,7 +336,7 @@ private[ember] object Parser {
     }
 
     def parser[F[_]: Concurrent: Timer](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
-        s: Stream[F, Byte]): F[Request[F]] =
+        s: Stream[F, Byte]): F[(Request[F], Stream[F, Byte])] =
       Deferred[F, Headers].flatMap { trailers =>
         val base = ReqPrelude
           .parsePrelude[F](s, maxHeaderLength, None)
@@ -358,7 +358,7 @@ private[ember] object Parser {
                   else
                     baseReq.withBodyStream(rest.take(contentLength.getOrElse(0L)))
 
-                Pull.output1(req)
+                Pull.output1((req, rest))
             }
           }
           .stream
@@ -371,7 +371,7 @@ private[ember] object Parser {
   object Response {
     def parser[F[_]: Concurrent: Timer](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
         s: Stream[F, Byte]
-    ): Resource[F, Response[F]] =
+    ): Resource[F, (Response[F], Stream[F, Byte])] =
       Resource.liftF(Deferred[F, Headers]).flatMap { trailers =>
         val base = RespPrelude
           .parsePrelude(s, maxHeaderLength, None)
@@ -391,7 +391,7 @@ private[ember] object Parser {
                         rest.through(ChunkedEncoding.decode(maxHeaderLength, trailers)))
                   else
                     baseResp.withBodyStream(rest.take(contentLength.getOrElse(0L)))
-                Pull.output1(resp)
+                Pull.output1((resp, rest))
             }
           }
           .stream
diff --git a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
index 8b0a896d891..07b25df0772 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
@@ -43,6 +43,11 @@ private[server] object ServerHelpers {
   private val serverFailure =
     Response(Status.InternalServerError).putHeaders(org.http4s.headers.`Content-Length`.zero)
 
+  private def durationToFinite(duration: Duration): Option[FiniteDuration] = duration match {
+    case f: FiniteDuration => Some(f)
+    case _ => None
+  }
+
   def server[F[_]: ContextShift](
       bindAddress: InetSocketAddress,
       httpApp: HttpApp[F],
@@ -60,33 +65,12 @@ private[server] object ServerHelpers {
       additionalSocketOptions: List[SocketOptionMapping[_]] = List.empty,
       logger: Logger[F]
   )(implicit F: Concurrent[F], T: Timer[F]): Stream[F, Nothing] = {
-    def socketReadRequest(
-        socket: Socket[F],
-        requestHeaderReceiveTimeout: Duration,
-        receiveBufferSize: Int
-    ): F[Request[F]] = {
-      val idle: Option[FiniteDuration] = idleTimeout match {
-        case idle: FiniteDuration => Some(idle)
-        case _ => None
-      }
-      def errorIfEmpty(
-          socket: Socket[F],
-          maxBytes: Int,
-          timeout: Option[FiniteDuration]): Stream[F, Byte] =
-        Stream.eval(socket.read(maxBytes, timeout)).flatMap {
-          case Some(bytes) =>
-            Stream.chunk(bytes) ++ errorIfEmpty(socket, maxBytes, timeout)
-          case None => Stream.raiseError(new RuntimeException("Received Unexpected EOF"))
-        }
-      val action = requestHeaderReceiveTimeout match {
-        case i: FiniteDuration =>
-          Parser.Request.parser(maxHeaderSize, Some(i))(
-            errorIfEmpty(socket, receiveBufferSize, idle))
-        case _ =>
-          Parser.Request.parser(maxHeaderSize, None)(errorIfEmpty(socket, receiveBufferSize, idle))
+
+    def reachedEndError(socket: Socket[F]): Stream[F, Byte] =
+      Stream.eval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {
+        case None => Stream.raiseError(new RuntimeException("Unexpected EOF"))
+        case Some(value) => Stream.chunk(value)
       }
-      action
-    }
 
     def upgradeSocket(
         socketInit: Socket[F],
@@ -97,19 +81,21 @@ private[server] object ServerHelpers {
           .widen[Socket[F]]
       }
 
-    def runApp(socket: Socket[F]): F[(Request[F], Response[F])] =
+    def runApp(incoming: Stream[F, Byte]): F[(Request[F], Response[F], Stream[F, Byte])] =
       for {
-        req <- socketReadRequest(socket, requestHeaderReceiveTimeout, receiveBufferSize)
+        tup <- Parser.Request.parser(maxHeaderSize, durationToFinite(requestHeaderReceiveTimeout))(
+          incoming)
+        (req, rest) = tup
         resp <- httpApp
           .run(req)
           .handleErrorWith(errorHandler)
           .handleError(_ => serverFailure.covary[F])
-      } yield (req, resp)
+      } yield (req, resp, rest)
 
     def send(socket: Socket[F])(request: Option[Request[F]], resp: Response[F]): F[Unit] =
       Encoder
         .respToBytes[F](resp)
-        .through(socket.writes())
+        .through(socket.writes(durationToFinite(idleTimeout)))
         .compile
         .drain
         .attempt
@@ -135,8 +121,11 @@ private[server] object ServerHelpers {
 
     def withUpgradedSocket(socket: Socket[F]): Stream[F, Nothing] =
       Stream
-        .eval(runApp(socket).attempt)
-        .repeat
+        .unfoldLoopEval(reachedEndError(socket))(s =>
+          runApp(s).attempt.map {
+            case Right((req, resp, rest)) => (Right((req, resp)), Some(rest))
+            case Left(e) => (Left(e), None)
+          })
         .evalMap {
           case Right((req, resp)) =>
             postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])

From 893ff2b4f3769a358d6ece3bc6313d9fd9840cf6 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Fri, 29 Jan 2021 17:11:25 -0800
Subject: [PATCH 09/35] Fix Tests

---
 .../scala/org/http4s/ember/core/ParsingSpec.scala    | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala b/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
index 102247b094e..64de157f98c 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
@@ -45,7 +45,7 @@ class ParsingSpec extends Specification with CatsIO {
         .map(httpifyString)
         .through(fs2.text.utf8Encode[F])
 
-      Parser.Request.parser[F](Int.MaxValue, None)(byteStream)
+      Parser.Request.parser[F](Int.MaxValue, None)(byteStream).map(_._1)
     }
 
     def parseResponseRig[F[_]: Concurrent: Timer](s: String): Resource[F, Response[F]] = {
@@ -55,7 +55,7 @@ class ParsingSpec extends Specification with CatsIO {
         .map(httpifyString)
         .through(fs2.text.utf8Encode[F])
 
-      Parser.Response.parser[F](Int.MaxValue, None)(byteStream) //(logger)
+      Parser.Response.parser[F](Int.MaxValue, None)(byteStream).map(_._1) //(logger)
     }
 
     def forceScopedParsing[F[_]: Sync](s: String): Stream[F, Byte] = {
@@ -171,7 +171,7 @@ class ParsingSpec extends Specification with CatsIO {
             .parser[IO](defaultMaxHeaderLength, None)(
               Helpers.forceScopedParsing[IO](raw)
             ) //(logger)
-            .use { resp =>
+            .use { case (resp, _) =>
               resp.body.through(text.utf8Decode).compile.string
             }
       } yield parsed must_== "{}").unsafeRunSync()
@@ -188,7 +188,7 @@ class ParsingSpec extends Specification with CatsIO {
 
       Parser.Response
         .parser[IO](defaultMaxHeaderLength, None)(Stream.chunk(ByteVectorChunk(baseBv)))
-        .use { resp =>
+        .use { case (resp, _) =>
           resp.body.through(text.utf8Decode).compile.string
 
         }
@@ -223,7 +223,7 @@ class ParsingSpec extends Specification with CatsIO {
 
       Parser.Response
         .parser[IO](defaultMaxHeaderLength, None)(byteStream)
-        .use { resp =>
+        .use { case (resp, _) =>
           resp.body.through(text.utf8Decode).compile.string.map { body =>
             body must beEqualTo("MozillaDeveloperNetwork")
           }
@@ -255,7 +255,7 @@ class ParsingSpec extends Specification with CatsIO {
 
       Parser.Response
         .parser[IO](defaultMaxHeaderLength, None)(byteStream)
-        .use { resp =>
+        .use { case (resp, _) =>
           for {
             body <- resp.body.through(text.utf8Decode).compile.string
             trailers <- resp.trailerHeaders

From 393329d412d8a35297eb0f2828f5faeb4dd7a77e Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Fri, 29 Jan 2021 21:42:34 -0500
Subject: [PATCH 10/35] Upgrade to play-json-2.10.0-RC1

---
 project/Http4sPlugin.scala | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/project/Http4sPlugin.scala b/project/Http4sPlugin.scala
index 7fb3857047e..684ccc25bd8 100644
--- a/project/Http4sPlugin.scala
+++ b/project/Http4sPlugin.scala
@@ -314,7 +314,7 @@ object Http4sPlugin extends AutoPlugin {
     val netty = "4.1.58.Final"
     val okio = "2.10.0"
     val okhttp = "4.9.0"
-    val playJson = "2.9.2"
+    val playJson = "2.10.0-RC1"
     val prometheusClient = "0.10.0"
     val reactiveStreams = "1.0.3"
     val quasiquotes = "2.1.0"

From 8299308e9a1e4b77b76baa9db7e950ffdacbf26a Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@gmail.com>
Date: Sun, 31 Jan 2021 00:13:18 -0600
Subject: [PATCH 11/35] Add max connections to Blaze and Ember

---
 .../org/http4s/server/blaze/BlazeServerBuilder.scala      | 8 ++++++++
 .../org/http4s/ember/server/EmberServerBuilder.scala      | 2 +-
 project/Http4sPlugin.scala                                | 2 +-
 server/src/main/scala/org/http4s/server/package.scala     | 3 +++
 4 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
index 80eb9fb6a55..ad7f4c76060 100644
--- a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
+++ b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
@@ -86,6 +86,7 @@ import scodec.bits.ByteVector
   *    this is necessary to recover totality from the error condition.
   * @param banner: Pretty log to display on server start. An empty sequence
   *    such as Nil disables this
+  * @param maxConnections: The maximum number of client connections that may be active at any time.
   */
 class BlazeServerBuilder[F[_]](
     socketAddress: InetSocketAddress,
@@ -105,6 +106,7 @@ class BlazeServerBuilder[F[_]](
     httpApp: HttpApp[F],
     serviceErrorHandler: ServiceErrorHandler[F],
     banner: immutable.Seq[String],
+    maxConnections: Int,
     val channelOptions: ChannelOptions
 )(implicit protected val F: ConcurrentEffect[F], timer: Timer[F])
     extends ServerBuilder[F]
@@ -131,6 +133,7 @@ class BlazeServerBuilder[F[_]](
       httpApp: HttpApp[F] = httpApp,
       serviceErrorHandler: ServiceErrorHandler[F] = serviceErrorHandler,
       banner: immutable.Seq[String] = banner,
+      maxConnections: Int = maxConnections,
       channelOptions: ChannelOptions = channelOptions
   ): Self =
     new BlazeServerBuilder(
@@ -151,6 +154,7 @@ class BlazeServerBuilder[F[_]](
       httpApp,
       serviceErrorHandler,
       banner,
+      maxConnections,
       channelOptions
     )
 
@@ -247,6 +251,9 @@ class BlazeServerBuilder[F[_]](
   def withChunkBufferMaxSize(chunkBufferMaxSize: Int): BlazeServerBuilder[F] =
     copy(chunkBufferMaxSize = chunkBufferMaxSize)
 
+  def withMaxConnections(maxConnections: Int): BlazeServerBuilder[F] =
+    copy(maxConnections = maxConnections)
+
   private def pipelineFactory(
       scheduler: TickWheelExecutor,
       engineConfig: Option[(SSLContext, SSLEngine => Unit)]
@@ -422,6 +429,7 @@ object BlazeServerBuilder {
       httpApp = defaultApp[F],
       serviceErrorHandler = DefaultServiceErrorHandler[F],
       banner = defaults.Banner,
+      maxConnections = defaults.MaxConnections,
       channelOptions = ChannelOptions(Vector.empty)
     )
 
diff --git a/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala b/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
index fab724af5d4..420895d8cfe 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
@@ -224,7 +224,7 @@ object EmberServerBuilder {
         : (Option[Request[F]], Response[F], Throwable) => F[Unit] = {
       case _: (Option[Request[F]], Response[F], Throwable) => Applicative[F].unit
     }
-    val maxConcurrency: Int = Int.MaxValue
+    val maxConcurrency: Int = server.defaults.MaxConnections
     val receiveBufferSize: Int = 256 * 1024
     val maxHeaderSize: Int = server.defaults.MaxHeadersSize
     val requestHeaderReceiveTimeout: Duration = 5.seconds
diff --git a/project/Http4sPlugin.scala b/project/Http4sPlugin.scala
index e7a247bc736..7759791d9c3 100644
--- a/project/Http4sPlugin.scala
+++ b/project/Http4sPlugin.scala
@@ -299,7 +299,7 @@ object Http4sPlugin extends AutoPlugin {
     // error-prone merge conflicts in the dependencies below.
     val argonaut = "6.2.5"
     val asyncHttpClient = "2.10.5"
-    val blaze = "0.14.14"
+    val blaze = "0.14.15-SNAPSHOT"
     val boopickle = "1.3.3"
     val cats = "2.3.1"
     val catsEffect = "2.3.1"
diff --git a/server/src/main/scala/org/http4s/server/package.scala b/server/src/main/scala/org/http4s/server/package.scala
index 4b3a598a03a..8b8944e08d3 100644
--- a/server/src/main/scala/org/http4s/server/package.scala
+++ b/server/src/main/scala/org/http4s/server/package.scala
@@ -51,6 +51,9 @@ package object server {
 
     /** Default max size of all headers. */
     val MaxHeadersSize: Int = 40 * 1024
+
+    /** Default max connections */
+    val MaxConnections: Int = 1024
   }
 
   object ServerRequestKeys {

From 899343d62661ff34a9c6a887ddacce91a4572a85 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Sun, 31 Jan 2021 10:16:30 -0500
Subject: [PATCH 12/35] Deprecate NIO2 in BlazeServerBuilder

---
 .../server/blaze/BlazeServerBuilder.scala     | 74 ++++++++++++++++---
 1 file changed, 62 insertions(+), 12 deletions(-)

diff --git a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
index ad7f4c76060..76ad1cc37e5 100644
--- a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
+++ b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
@@ -88,12 +88,12 @@ import scodec.bits.ByteVector
   *    such as Nil disables this
   * @param maxConnections: The maximum number of client connections that may be active at any time.
   */
-class BlazeServerBuilder[F[_]](
+class BlazeServerBuilder[F[_]] private (
     socketAddress: InetSocketAddress,
     executionContext: ExecutionContext,
     responseHeaderTimeout: Duration,
     idleTimeout: Duration,
-    isNio2: Boolean,
+    nioVersion: NioVersion,
     connectorPoolSize: Int,
     bufferSize: Int,
     selectorThreadFactory: ThreadFactory,
@@ -115,12 +115,55 @@ class BlazeServerBuilder[F[_]](
 
   private[this] val logger = getLogger
 
+  @deprecated("Use `BlazeServerBuilder.apply` and configure with `with` methods", "0.21.17")
+  def this(
+      socketAddress: InetSocketAddress,
+      executionContext: ExecutionContext,
+      responseHeaderTimeout: Duration,
+      idleTimeout: Duration,
+      isNio2: Boolean,
+      connectorPoolSize: Int,
+      bufferSize: Int,
+      selectorThreadFactory: ThreadFactory,
+      enableWebSockets: Boolean,
+      sslConfig: SslConfig[F],
+      isHttp2Enabled: Boolean,
+      maxRequestLineLen: Int,
+      maxHeadersLen: Int,
+      chunkBufferMaxSize: Int,
+      httpApp: HttpApp[F],
+      serviceErrorHandler: ServiceErrorHandler[F],
+      banner: immutable.Seq[String],
+      maxConnections: Int,
+      channelOptions: ChannelOptions
+  )(implicit F: ConcurrentEffect[F], timer: Timer[F]) = this(
+    socketAddress = socketAddress,
+    executionContext = executionContext,
+    idleTimeout = idleTimeout,
+    responseHeaderTimeout = responseHeaderTimeout,
+    nioVersion = if (isNio2) Nio2 else Nio1,
+    connectorPoolSize = connectorPoolSize,
+    bufferSize = bufferSize,
+    selectorThreadFactory = selectorThreadFactory,
+    enableWebSockets = enableWebSockets,
+    sslConfig = sslConfig,
+    isHttp2Enabled = isHttp2Enabled,
+    maxRequestLineLen = maxRequestLineLen,
+    maxHeadersLen = maxHeadersLen,
+    chunkBufferMaxSize = chunkBufferMaxSize,
+    httpApp = httpApp,
+    serviceErrorHandler = serviceErrorHandler,
+    banner = banner,
+    maxConnections = maxConnections,    
+    channelOptions = channelOptions
+  )
+
   private def copy(
       socketAddress: InetSocketAddress = socketAddress,
       executionContext: ExecutionContext = executionContext,
       idleTimeout: Duration = idleTimeout,
       responseHeaderTimeout: Duration = responseHeaderTimeout,
-      isNio2: Boolean = isNio2,
+      nioVersion: NioVersion = nioVersion,
       connectorPoolSize: Int = connectorPoolSize,
       bufferSize: Int = bufferSize,
       selectorThreadFactory: ThreadFactory = selectorThreadFactory,
@@ -141,7 +184,7 @@ class BlazeServerBuilder[F[_]](
       executionContext,
       responseHeaderTimeout,
       idleTimeout,
-      isNio2,
+      nioVersion,
       connectorPoolSize,
       bufferSize,
       selectorThreadFactory,
@@ -223,7 +266,8 @@ class BlazeServerBuilder[F[_]](
   def withSelectorThreadFactory(selectorThreadFactory: ThreadFactory): Self =
     copy(selectorThreadFactory = selectorThreadFactory)
 
-  def withNio2(isNio2: Boolean): Self = copy(isNio2 = isNio2)
+  @deprecated("NIO2 support in http4s-blaze-server will be removed in 0.22.", "0.21.17")
+  def withNio2(isNio2: Boolean): Self = copy(nioVersion = if (isNio2) Nio2 else Nio1)
 
   def withWebSockets(enableWebsockets: Boolean): Self =
     copy(enableWebSockets = enableWebsockets)
@@ -348,12 +392,14 @@ class BlazeServerBuilder[F[_]](
         else address
 
       val mkFactory: Resource[F, ServerChannelGroup] = Resource.make(F.delay {
-        if (isNio2)
-          NIO2SocketServerGroup
-            .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
-        else
-          NIO1SocketServerGroup
-            .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
+        nioVersion match {
+          case Nio2 =>
+            NIO2SocketServerGroup
+              .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
+          case Nio1 =>
+            NIO1SocketServerGroup
+              .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
+        }
       })(factory => F.delay(factory.closeGroup()))
 
       def mkServerChannel(factory: ServerChannelGroup): Resource[F, ServerChannel] =
@@ -416,7 +462,7 @@ object BlazeServerBuilder {
       executionContext = executionContext,
       responseHeaderTimeout = defaults.ResponseTimeout,
       idleTimeout = defaults.IdleTimeout,
-      isNio2 = false,
+      nioVersion = Nio1,
       connectorPoolSize = DefaultPoolSize,
       bufferSize = 64 * 1024,
       selectorThreadFactory = defaultThreadSelectorFactory,
@@ -531,4 +577,8 @@ object BlazeServerBuilder {
       case SSLClientAuthMode.Requested => engine.setWantClientAuth(true)
       case SSLClientAuthMode.NotRequested => ()
     }
+
+  private sealed trait NioVersion extends Product with Serializable
+  private case object Nio1 extends NioVersion
+  private case object Nio2 extends NioVersion
 }

From 4bb5f3d654298167678ea6a06c5da34f5ccdb14b Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Mon, 1 Feb 2021 08:53:15 -0800
Subject: [PATCH 13/35] Do Away with unnecessary resource

---
 .../ember/client/EmberClientBuilder.scala     | 54 ++++++++-------
 .../ember/client/internal/ClientHelpers.scala | 16 ++---
 .../client/internal/ClientHelpersSpec.scala   | 69 +++++++++----------
 .../scala/org/http4s/ember/core/Encoder.scala |  1 +
 .../scala/org/http4s/ember/core/Parser.scala  | 16 +++--
 .../org/http4s/ember/core/ParsingSpec.scala   | 25 ++++---
 6 files changed, 95 insertions(+), 86 deletions(-)

diff --git a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
index 24645162dc2..3069f18a4b2 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
@@ -161,32 +161,34 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
               )
             }
           )
-          responseResource <-
-            org.http4s.ember.client.internal.ClientHelpers
-              .request[F](
-                request,
-                managed.value._1,
-                managed.canBeReused,
-                chunkSize,
-                maxResponseHeaderSize,
-                idleReadTime,
-                timeout,
-                userAgent
-              )
-              .map(response =>
-                // TODO If Response Body has a take(1).compile.drain - would leave rest of bytes in root stream for next caller
-                response.copy(body = response.body.onFinalizeCaseWeak {
-                  case ExitCase.Completed =>
-                    val requestClose = request.headers.get(Connection).exists(_.hasClose)
-                    val responseClose = response.isChunked || response.headers
-                      .get(Connection)
-                      .exists(_.hasClose)
-
-                    if (requestClose || responseClose) Sync[F].unit
-                    else managed.canBeReused.set(Reusable.Reuse)
-                  case ExitCase.Canceled => Sync[F].unit
-                  case ExitCase.Error(_) => Sync[F].unit
-                }))
+          responseResource <- Resource
+            .liftF(
+              org.http4s.ember.client.internal.ClientHelpers
+                .request[F](
+                  request,
+                  managed.value._1,
+                  managed.canBeReused,
+                  chunkSize,
+                  maxResponseHeaderSize,
+                  idleReadTime,
+                  timeout,
+                  userAgent
+                )
+            )
+            .map(response =>
+              // TODO If Response Body has a take(1).compile.drain - would leave rest of bytes in root stream for next caller
+              response.copy(body = response.body.onFinalizeCaseWeak {
+                case ExitCase.Completed =>
+                  val requestClose = request.headers.get(Connection).exists(_.hasClose)
+                  val responseClose = response.isChunked || response.headers
+                    .get(Connection)
+                    .exists(_.hasClose)
+
+                  if (requestClose || responseClose) Sync[F].unit
+                  else managed.canBeReused.set(Reusable.Reuse)
+                case ExitCase.Canceled => Sync[F].unit
+                case ExitCase.Error(_) => Sync[F].unit
+              }))
         } yield responseResource
       }
       new EmberClient[F](client, pool)
diff --git a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
index 53dcb13e7f5..e224a7af6f7 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
@@ -92,20 +92,19 @@ private[client] object ClientHelpers {
       idleReadTimeout: Duration,
       timeout: Duration,
       userAgent: Option[`User-Agent`]
-  ): Resource[F, Response[F]] = {
+  ): F[Response[F]] = {
 
     def writeRequestToSocket(
         req: Request[F],
         socket: Socket[F],
-        timeout: Option[FiniteDuration]): Resource[F, Unit] =
+        timeout: Option[FiniteDuration]): F[Unit] =
       Encoder
         .reqToBytes(req)
         .through(socket.writes(timeout))
         .compile
-        .resource
         .drain
 
-    def writeRead(req: Request[F]): Resource[F, Response[F]] =
+    def writeRead(req: Request[F]): F[Response[F]] =
       writeRequestToSocket(req, requestKeySocket.socket, None) >> {
         Parser.Response
           .parser(maxResponseHeaderSize, durationToFinite(timeout))(
@@ -115,10 +114,9 @@ private[client] object ClientHelpers {
       }
 
     for {
-      processedReq <- Resource.liftF(preprocessRequest(request, userAgent))
+      processedReq <- preprocessRequest(request, userAgent)
       resp <- writeRead(processedReq)
-      processedResp <- postProcessResponse(processedReq, resp, reuseable)
-    } yield processedResp
+    } yield postProcessResponse(processedReq, resp, reuseable)
   }
 
   private[internal] def preprocessRequest[F[_]: Monad: Clock](
@@ -138,7 +136,7 @@ private[client] object ClientHelpers {
   private[internal] def postProcessResponse[F[_]: Concurrent](
       req: Request[F],
       resp: Response[F],
-      canBeReused: Ref[F, Reusable]): Resource[F, Response[F]] = {
+      canBeReused: Ref[F, Reusable]): Response[F] = {
     val out = resp.copy(
       body = resp.body.onFinalizeCaseWeak {
         case ExitCase.Completed =>
@@ -151,7 +149,7 @@ private[client] object ClientHelpers {
         case ExitCase.Error(_) => Applicative[F].unit
       }
     )
-    Resource.pure[F, Response[F]](out)
+    out
   }
 
   // https://github.com/http4s/http4s/blob/main/blaze-client/src/main/scala/org/http4s/client/blaze/Http1Support.scala#L86
diff --git a/ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala b/ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala
index 920877254a7..70491f08c71 100644
--- a/ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala
+++ b/ember-client/src/test/scala/org/http4s/ember/client/internal/ClientHelpersSpec.scala
@@ -105,18 +105,17 @@ class ClientHelpersSpec extends Specification with CatsIO {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
               Response[IO](),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.Reuse)
-                }
+        testResult <-
+          resp.body.compile.drain >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.Reuse)
             }
       } yield testResult
     }
@@ -125,18 +124,18 @@ class ClientHelpersSpec extends Specification with CatsIO {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        _ =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
               Response[IO](),
               reuse
             )
-            .use { _ =>
-              reuse.get.map { case r =>
-                r must beEqualTo(Reusable.DontReuse)
-              }
-            }
+
+        testResult <-
+          reuse.get.map { case r =>
+            r must beEqualTo(Reusable.DontReuse)
+          }
       } yield testResult
     }
 
@@ -144,18 +143,17 @@ class ClientHelpersSpec extends Specification with CatsIO {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
               Response[IO](body = fs2.Stream.raiseError[IO](new Throwable("Boo!"))),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain.attempt >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.DontReuse)
-                }
+        testResult <-
+          resp.body.compile.drain.attempt >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.DontReuse)
             }
       } yield testResult
     }
@@ -164,7 +162,7 @@ class ClientHelpersSpec extends Specification with CatsIO {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
@@ -177,11 +175,10 @@ class ClientHelpersSpec extends Specification with CatsIO {
                 .interruptAfter(2.seconds)),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain.attempt >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.DontReuse)
-                }
+        testResult <-
+          resp.body.compile.drain.attempt >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.DontReuse)
             }
       } yield testResult
     }.pendingUntilFixed
@@ -190,18 +187,17 @@ class ClientHelpersSpec extends Specification with CatsIO {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
-            .postProcessResponse(
+            .postProcessResponse[IO](
               Request[IO](headers = Headers.of(Connection(NonEmptyList.of("close".ci)))),
               Response[IO](),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.DontReuse)
-                }
+        testResult <-
+          resp.body.compile.drain >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.DontReuse)
             }
       } yield testResult
     }
@@ -210,18 +206,17 @@ class ClientHelpersSpec extends Specification with CatsIO {
       for {
         reuse <- Ref[IO].of(Reusable.DontReuse: Reusable)
 
-        testResult <-
+        resp =
           ClientHelpers
             .postProcessResponse(
               Request[IO](),
               Response[IO](headers = Headers.of(Connection(NonEmptyList.of("close".ci)))),
               reuse
             )
-            .use { resp =>
-              resp.body.compile.drain >>
-                reuse.get.map { case r =>
-                  r must beEqualTo(Reusable.DontReuse)
-                }
+        testResult <-
+          resp.body.compile.drain >>
+            reuse.get.map { case r =>
+              r must beEqualTo(Reusable.DontReuse)
             }
       } yield testResult
     }
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
index c46a7da7597..2b5aa6e8fc7 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
@@ -32,6 +32,7 @@ private[ember] object Encoder {
       resp: Response[F],
       writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {
     var chunked = resp.isChunked
+    // resp.status.isEntityAllowed TODO
     val initSection = {
       var appliedContentLength = false
       val stringBuilder = new StringBuilder()
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
index 93a97c86f09..85949d2ede0 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
@@ -338,7 +338,7 @@ private[ember] object Parser {
     def parser[F[_]: Concurrent: Timer](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
         s: Stream[F, Byte]): F[(Request[F], Stream[F, Byte])] =
       Deferred[F, Headers].flatMap { trailers =>
-        val base = ReqPrelude
+        val baseStream = ReqPrelude
           .parsePrelude[F](s, maxHeaderLength, None)
           .flatMap { case (method, uri, httpVersion, rest) =>
             HeaderP.parseHeaders(rest, maxHeaderLength, None).flatMap {
@@ -364,15 +364,19 @@ private[ember] object Parser {
           .stream
           .take(1)
 
-        timeout.fold(base)(duration => base.timeout(duration)).compile.lastOrError
+        val action = baseStream.compile.lastOrError
+        timeout match {
+          case None => action
+          case Some(timeout) => Concurrent.timeout(action, timeout)
+        }
       }
   }
 
   object Response {
     def parser[F[_]: Concurrent: Timer](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
         s: Stream[F, Byte]
-    ): Resource[F, (Response[F], Stream[F, Byte])] =
-      Resource.liftF(Deferred[F, Headers]).flatMap { trailers =>
+    ): F[(Response[F], Stream[F, Byte])] =
+      Deferred[F, Headers].flatMap { trailers =>
         val base = RespPrelude
           .parsePrelude(s, maxHeaderLength, None)
           .flatMap { case (httpVersion, status, s) =>
@@ -395,9 +399,9 @@ private[ember] object Parser {
             }
           }
           .stream
-          .take(1)
 
-        timeout.fold(base)(duration => base.timeout(duration)).compile.resource.lastOrError
+        val action = base.compile.lastOrError
+        timeout.fold(action)(duration => Concurrent.timeout(action, duration))
       }
 
     object RespPrelude {
diff --git a/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala b/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
index 64de157f98c..4befe60ea11 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/ParsingSpec.scala
@@ -55,7 +55,8 @@ class ParsingSpec extends Specification with CatsIO {
         .map(httpifyString)
         .through(fs2.text.utf8Encode[F])
 
-      Parser.Response.parser[F](Int.MaxValue, None)(byteStream).map(_._1) //(logger)
+      val action = Parser.Response.parser[F](Int.MaxValue, None)(byteStream).map(_._1) //(logger)
+      Resource.liftF(action)
     }
 
     def forceScopedParsing[F[_]: Sync](s: String): Stream[F, Byte] = {
@@ -157,21 +158,29 @@ class ParsingSpec extends Specification with CatsIO {
     "handle a response that requires multiple chunks to be read" in {
       // val logger = TestingLogger.impl[IO]()
       val defaultMaxHeaderLength = 4096
-      val raw =
+      val raw1 =
         """HTTP/1.1 200 OK
           |Content-type: application/json
           |Content-Length: 2
           |
-          |{}
+          |{""".stripMargin
+
+      val raw2 = """}
           |""".stripMargin
+      val http1 = Helpers.httpifyString(raw1)
+
+      val http2 = Helpers.httpifyString(raw2)
+      val encoded = (Stream(http1) ++ Stream(http2)).through(fs2.text.utf8Encode)
 
       (for {
         parsed <-
           Parser.Response
             .parser[IO](defaultMaxHeaderLength, None)(
-              Helpers.forceScopedParsing[IO](raw)
+              encoded
+              //Helpers.forceScopedParsing[IO](raw) // Cuts off `}` in current test. Why?
+              // I don't follow what the rig is testing vs this.
             ) //(logger)
-            .use { case (resp, _) =>
+            .flatMap { case (resp, _) =>
               resp.body.through(text.utf8Decode).compile.string
             }
       } yield parsed must_== "{}").unsafeRunSync()
@@ -188,7 +197,7 @@ class ParsingSpec extends Specification with CatsIO {
 
       Parser.Response
         .parser[IO](defaultMaxHeaderLength, None)(Stream.chunk(ByteVectorChunk(baseBv)))
-        .use { case (resp, _) =>
+        .flatMap { case (resp, _) =>
           resp.body.through(text.utf8Decode).compile.string
 
         }
@@ -223,7 +232,7 @@ class ParsingSpec extends Specification with CatsIO {
 
       Parser.Response
         .parser[IO](defaultMaxHeaderLength, None)(byteStream)
-        .use { case (resp, _) =>
+        .flatMap { case (resp, _) =>
           resp.body.through(text.utf8Decode).compile.string.map { body =>
             body must beEqualTo("MozillaDeveloperNetwork")
           }
@@ -255,7 +264,7 @@ class ParsingSpec extends Specification with CatsIO {
 
       Parser.Response
         .parser[IO](defaultMaxHeaderLength, None)(byteStream)
-        .use { case (resp, _) =>
+        .flatMap { case (resp, _) =>
           for {
             body <- resp.body.through(text.utf8Decode).compile.string
             trailers <- resp.trailerHeaders

From c0d4ab4496fd6bf422120845f1e59680e2ccf8d8 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Mon, 1 Feb 2021 10:06:52 -0800
Subject: [PATCH 14/35] Share toFiniteDuration, Mima

---
 build.sbt                                     |  5 ++--
 .../ember/client/internal/ClientHelpers.scala |  6 +---
 .../scala/org/http4s/ember/core/Util.scala    | 28 +++++++++++++++++++
 .../ember/server/internal/ServerHelpers.scala |  8 ++----
 4 files changed, 34 insertions(+), 13 deletions(-)
 create mode 100644 ember-core/src/main/scala/org/http4s/ember/core/Util.scala

diff --git a/build.sbt b/build.sbt
index 44d14115952..48c00afe7b7 100644
--- a/build.sbt
+++ b/build.sbt
@@ -240,8 +240,8 @@ lazy val emberCore = libraryProject("ember-core")
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser.generateHeaders"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser.httpHeaderAndBody"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Response.parser"),
-      ProblemFilters.exclude[MissingClassProblem]("org.http4s.ember.core.Util"),
-      ProblemFilters.exclude[MissingClassProblem]("org.http4s.ember.core.Util$"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Util.readWithTimeout"),
+      
     )
   )
   .dependsOn(core, testing % "test->test")
@@ -283,6 +283,7 @@ lazy val emberClient = libraryProject("ember-client")
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.client.EmberClientBuilder.this"),
       ProblemFilters.exclude[IncompatibleMethTypeProblem]("org.http4s.ember.client.internal.ClientHelpers.request"),
       ProblemFilters.exclude[IncompatibleMethTypeProblem]("org.http4s.ember.client.internal.ClientHelpers.request"),
+      ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.client.internal.ClientHelpers.postProcessResponse"),
     )
   )
   .dependsOn(emberCore % "compile;test->test", client % "compile;test->test")
diff --git a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
index e224a7af6f7..6015c1f2a96 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
@@ -34,14 +34,10 @@ import _root_.fs2.io.tls._
 import _root_.io.chrisdavenport.keypool.Reusable
 import javax.net.ssl.SNIHostName
 import org.http4s.headers.{Connection, Date, `User-Agent`}
+import _root_.org.http4s.ember.core.Util.durationToFinite
 
 private[client] object ClientHelpers {
 
-  private def durationToFinite(duration: Duration): Option[FiniteDuration] = duration match {
-    case f: FiniteDuration => Some(f)
-    case _ => None
-  }
-
   def requestToSocketWithKey[F[_]: Concurrent: Timer: ContextShift](
       request: Request[F],
       tlsContextOpt: Option[TLSContext],
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Util.scala b/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
new file mode 100644
index 00000000000..f17d5825d84
--- /dev/null
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2019 http4s.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.http4s.ember.core
+
+import scala.concurrent.duration._
+
+private[ember] object Util {
+
+  def durationToFinite(duration: Duration): Option[FiniteDuration] = duration match {
+    case f: FiniteDuration => Some(f)
+    case _ => None
+  }
+
+}
\ No newline at end of file
diff --git a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
index 07b25df0772..1a058137abf 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
@@ -31,6 +31,7 @@ import _root_.io.chrisdavenport.log4cats.Logger
 import cats.data.NonEmptyList
 import java.util.concurrent.TimeoutException
 import java.nio.channels.InterruptedByTimeoutException
+import _root_.org.http4s.ember.core.Util.durationToFinite
 
 private[server] object ServerHelpers {
 
@@ -43,11 +44,6 @@ private[server] object ServerHelpers {
   private val serverFailure =
     Response(Status.InternalServerError).putHeaders(org.http4s.headers.`Content-Length`.zero)
 
-  private def durationToFinite(duration: Duration): Option[FiniteDuration] = duration match {
-    case f: FiniteDuration => Some(f)
-    case _ => None
-  }
-
   def server[F[_]: ContextShift](
       bindAddress: InetSocketAddress,
       httpApp: HttpApp[F],
@@ -68,7 +64,7 @@ private[server] object ServerHelpers {
 
     def reachedEndError(socket: Socket[F]): Stream[F, Byte] =
       Stream.eval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {
-        case None => Stream.raiseError(new RuntimeException("Unexpected EOF"))
+        case None => Stream.raiseError(new java.io.EOFException("Unexpected EOF - socket.read returned None"))
         case Some(value) => Stream.chunk(value)
       }
 

From 6bc2eef0e249f9163401850bd1df4c1213568fab Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Mon, 1 Feb 2021 10:15:57 -0800
Subject: [PATCH 15/35] Use Idle Connection time for Both Reading and Writing
 in Client

---
 .../http4s/ember/client/EmberClientBuilder.scala  | 15 +++++++++------
 .../ember/client/internal/ClientHelpers.scala     |  6 +++---
 .../main/scala/org/http4s/ember/core/Util.scala   |  2 +-
 .../ember/server/internal/ServerHelpers.scala     |  3 ++-
 4 files changed, 15 insertions(+), 11 deletions(-)

diff --git a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
index 3069f18a4b2..7db01f44a1b 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
@@ -40,7 +40,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
     private val logger: Logger[F],
     val chunkSize: Int,
     val maxResponseHeaderSize: Int,
-    private val idleReadTime: Duration,
+    private val idleConnectionTime: Duration,
     val timeout: Duration,
     val additionalSocketOptions: List[SocketOptionMapping[_]],
     val userAgent: Option[`User-Agent`]
@@ -56,7 +56,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
       logger: Logger[F] = self.logger,
       chunkSize: Int = self.chunkSize,
       maxResponseHeaderSize: Int = self.maxResponseHeaderSize,
-      idleReadTime: Duration = self.idleReadTime,
+      idleConnectionTime: Duration = self.idleConnectionTime,
       timeout: Duration = self.timeout,
       additionalSocketOptions: List[SocketOptionMapping[_]] = self.additionalSocketOptions,
       userAgent: Option[`User-Agent`] = self.userAgent
@@ -71,7 +71,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
       logger = logger,
       chunkSize = chunkSize,
       maxResponseHeaderSize = maxResponseHeaderSize,
-      idleReadTime = idleReadTime,
+      idleConnectionTime = idleConnectionTime,
       timeout = timeout,
       additionalSocketOptions = additionalSocketOptions,
       userAgent = userAgent
@@ -89,11 +89,14 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
   def withMaxTotal(maxTotal: Int) = copy(maxTotal = maxTotal)
   def withMaxPerKey(maxPerKey: RequestKey => Int) = copy(maxPerKey = maxPerKey)
   def withIdleTimeInPool(idleTimeInPool: Duration) = copy(idleTimeInPool = idleTimeInPool)
+  def withIdleConnectionTime(idleConnectionTime: Duration) =
+    copy(idleConnectionTime = idleConnectionTime)
 
   def withLogger(logger: Logger[F]) = copy(logger = logger)
   def withChunkSize(chunkSize: Int) = copy(chunkSize = chunkSize)
   def withMaxResponseHeaderSize(maxResponseHeaderSize: Int) =
     copy(maxResponseHeaderSize = maxResponseHeaderSize)
+
   def withTimeout(timeout: Duration) = copy(timeout = timeout)
   def withAdditionalSocketOptions(additionalSocketOptions: List[SocketOptionMapping[_]]) =
     copy(additionalSocketOptions = additionalSocketOptions)
@@ -170,7 +173,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
                   managed.canBeReused,
                   chunkSize,
                   maxResponseHeaderSize,
-                  idleReadTime,
+                  idleConnectionTime,
                   timeout,
                   userAgent
                 )
@@ -208,7 +211,7 @@ object EmberClientBuilder {
       logger = Slf4jLogger.getLogger[F],
       chunkSize = Defaults.chunkSize,
       maxResponseHeaderSize = Defaults.maxResponseHeaderSize,
-      idleReadTime = Defaults.idleReadTime,
+      idleConnectionTime = Defaults.idleConnectionTime,
       timeout = Defaults.timeout,
       additionalSocketOptions = Defaults.additionalSocketOptions,
       userAgent = Defaults.userAgent
@@ -218,7 +221,7 @@ object EmberClientBuilder {
     val acgFixedThreadPoolSize: Int = 100
     val chunkSize: Int = 32 * 1024
     val maxResponseHeaderSize: Int = 4096
-    val idleReadTime = org.http4s.client.defaults.RequestTimeout
+    val idleConnectionTime = org.http4s.client.defaults.RequestTimeout
     val timeout: Duration = org.http4s.client.defaults.RequestTimeout
 
     // Pool Settings
diff --git a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
index 6015c1f2a96..fc5518219e8 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
@@ -85,7 +85,7 @@ private[client] object ClientHelpers {
       reuseable: Ref[F, Reusable],
       chunkSize: Int,
       maxResponseHeaderSize: Int,
-      idleReadTimeout: Duration,
+      idleTimeout: Duration,
       timeout: Duration,
       userAgent: Option[`User-Agent`]
   ): F[Response[F]] = {
@@ -101,10 +101,10 @@ private[client] object ClientHelpers {
         .drain
 
     def writeRead(req: Request[F]): F[Response[F]] =
-      writeRequestToSocket(req, requestKeySocket.socket, None) >> {
+      writeRequestToSocket(req, requestKeySocket.socket, durationToFinite(idleTimeout)) >> {
         Parser.Response
           .parser(maxResponseHeaderSize, durationToFinite(timeout))(
-            requestKeySocket.socket.reads(chunkSize, durationToFinite(idleReadTimeout))
+            requestKeySocket.socket.reads(chunkSize, durationToFinite(idleTimeout))
           )
           .map(_._1)
       }
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Util.scala b/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
index f17d5825d84..8ed1c98624b 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Util.scala
@@ -25,4 +25,4 @@ private[ember] object Util {
     case _ => None
   }
 
-}
\ No newline at end of file
+}
diff --git a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
index 1a058137abf..04ec32b006a 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
@@ -64,7 +64,8 @@ private[server] object ServerHelpers {
 
     def reachedEndError(socket: Socket[F]): Stream[F, Byte] =
       Stream.eval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {
-        case None => Stream.raiseError(new java.io.EOFException("Unexpected EOF - socket.read returned None"))
+        case None =>
+          Stream.raiseError(new java.io.EOFException("Unexpected EOF - socket.read returned None"))
         case Some(value) => Stream.chunk(value)
       }
 

From 865f5ac2d07a868fe4e3df574cc997ad821cd699 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Mon, 1 Feb 2021 11:22:54 -0800
Subject: [PATCH 16/35] Split Functions For Easier Testability

---
 .../ember/server/internal/ServerHelpers.scala | 243 ++++++++++--------
 1 file changed, 141 insertions(+), 102 deletions(-)

diff --git a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
index 04ec32b006a..f332e1f0dd8 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
@@ -16,6 +16,7 @@
 
 package org.http4s.ember.server.internal
 
+import cats._
 import fs2._
 import fs2.io.tcp._
 import fs2.io.tls._
@@ -32,6 +33,7 @@ import cats.data.NonEmptyList
 import java.util.concurrent.TimeoutException
 import java.nio.channels.InterruptedByTimeoutException
 import _root_.org.http4s.ember.core.Util.durationToFinite
+import java.io.EOFException
 
 private[server] object ServerHelpers {
 
@@ -53,108 +55,14 @@ private[server] object ServerHelpers {
       // Defaults
       errorHandler: Throwable => F[Response[F]],
       onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit],
-      maxConcurrency: Int = Int.MaxValue,
-      receiveBufferSize: Int = 256 * 1024,
-      maxHeaderSize: Int = 10 * 1024,
-      requestHeaderReceiveTimeout: Duration = 5.seconds,
-      idleTimeout: Duration = 60.seconds,
+      maxConcurrency: Int,
+      receiveBufferSize: Int,
+      maxHeaderSize: Int,
+      requestHeaderReceiveTimeout: Duration,
+      idleTimeout: Duration,
       additionalSocketOptions: List[SocketOptionMapping[_]] = List.empty,
       logger: Logger[F]
-  )(implicit F: Concurrent[F], T: Timer[F]): Stream[F, Nothing] = {
-
-    def reachedEndError(socket: Socket[F]): Stream[F, Byte] =
-      Stream.eval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {
-        case None =>
-          Stream.raiseError(new java.io.EOFException("Unexpected EOF - socket.read returned None"))
-        case Some(value) => Stream.chunk(value)
-      }
-
-    def upgradeSocket(
-        socketInit: Socket[F],
-        tlsInfoOpt: Option[(TLSContext, TLSParameters)]): Resource[F, Socket[F]] =
-      tlsInfoOpt.fold(socketInit.pure[Resource[F, *]]) { case (context, params) =>
-        context
-          .server(socketInit, params, { (s: String) => logger.trace(s) }.some)
-          .widen[Socket[F]]
-      }
-
-    def runApp(incoming: Stream[F, Byte]): F[(Request[F], Response[F], Stream[F, Byte])] =
-      for {
-        tup <- Parser.Request.parser(maxHeaderSize, durationToFinite(requestHeaderReceiveTimeout))(
-          incoming)
-        (req, rest) = tup
-        resp <- httpApp
-          .run(req)
-          .handleErrorWith(errorHandler)
-          .handleError(_ => serverFailure.covary[F])
-      } yield (req, resp, rest)
-
-    def send(socket: Socket[F])(request: Option[Request[F]], resp: Response[F]): F[Unit] =
-      Encoder
-        .respToBytes[F](resp)
-        .through(socket.writes(durationToFinite(idleTimeout)))
-        .compile
-        .drain
-        .attempt
-        .flatMap {
-          case Left(err) => onWriteFailure(request, resp, err)
-          case Right(()) => Sync[F].pure(())
-        }
-
-    def postProcessResponse(req: Request[F], resp: Response[F]): F[Response[F]] = {
-      val reqHasClose = req.headers.exists {
-        // We know this is raw because we have not parsed any headers in the underlying alg.
-        // If Headers are being parsed into processed for in ParseHeaders this is incorrect.
-        case Header.Raw(name, values) => name == connectionCi && values.contains(closeCi.value)
-        case _ => false
-      }
-      val connection: Connection =
-        if (reqHasClose) close
-        else keepAlive
-      for {
-        date <- HttpDate.current[F].map(Date(_))
-      } yield resp.withHeaders(Headers.of(date, connection) ++ resp.headers)
-    }
-
-    def withUpgradedSocket(socket: Socket[F]): Stream[F, Nothing] =
-      Stream
-        .unfoldLoopEval(reachedEndError(socket))(s =>
-          runApp(s).attempt.map {
-            case Right((req, resp, rest)) => (Right((req, resp)), Some(rest))
-            case Left(e) => (Left(e), None)
-          })
-        .evalMap {
-          case Right((req, resp)) =>
-            postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])
-          case other => other.pure[F]
-        }
-        .evalTap {
-          case Right((request, response)) => send(socket)(Some(request), response)
-          case Left(err) =>
-            err match {
-              // Timeouts Do Not Get Responses
-              // Thrown by Stream.timeout or Concurrent.timeout
-              case _: TimeoutException =>
-                errorHandler(
-                  err).void // Lets users see responses, but cannot generate responses i don't like this
-              // Thrown by fs2.io.tcp.Socket read/write
-              case _: InterruptedByTimeoutException => errorHandler(err).void
-              case err =>
-                errorHandler(err)
-                  .handleError(_ => serverFailure.covary[F])
-                  .flatMap(send(socket)(None, _))
-            }
-        }
-        .takeWhile {
-          case Left(_) => false
-          case Right((req, resp)) =>
-            !(
-              req.headers.get(Connection).exists(_.hasClose) ||
-                resp.headers.get(Connection).exists(_.hasClose)
-            )
-        }
-        .drain
-
+  )(implicit F: Concurrent[F], T: Timer[F]): Stream[F, Nothing] =
     sg.server[F](bindAddress, additionalSocketOptions = additionalSocketOptions)
       .interruptWhen(shutdown.signal.attempt)
       // Divorce the scopes of the server stream and handler streams so the
@@ -163,10 +71,141 @@ private[server] object ServerHelpers {
       .map { connect =>
         shutdown.trackConnection >>
           Stream
-            .resource(connect.flatMap(upgradeSocket(_, tlsInfoOpt)))
-            .flatMap(withUpgradedSocket(_))
+            .resource(connect.flatMap(upgradeSocket(_, tlsInfoOpt, logger)))
+            .flatMap(
+              runConnection(
+                _,
+                logger,
+                idleTimeout,
+                receiveBufferSize,
+                maxHeaderSize,
+                requestHeaderReceiveTimeout,
+                httpApp,
+                errorHandler,
+                onWriteFailure))
       }
       .parJoin(maxConcurrency)
       .drain
+
+  private[internal] def reachedEndError[F[_]: Sync](
+      socket: Socket[F],
+      idleTimeout: Duration,
+      receiveBufferSize: Int): Stream[F, Byte] =
+    Stream.eval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {
+      case None =>
+        Stream.raiseError(new EOFException("Unexpected EOF - socket.read returned None"))
+      case Some(value) => Stream.chunk(value)
+    }
+
+  private[internal] def upgradeSocket[F[_]: Concurrent: ContextShift](
+      socketInit: Socket[F],
+      tlsInfoOpt: Option[(TLSContext, TLSParameters)],
+      logger: Logger[F]
+  ): Resource[F, Socket[F]] =
+    tlsInfoOpt.fold(socketInit.pure[Resource[F, *]]) { case (context, params) =>
+      context
+        .server(socketInit, params, { (s: String) => logger.trace(s) }.some)
+        .widen[Socket[F]]
+    }
+
+  private[internal] def runApp[F[_]: Concurrent: Timer](
+      incoming: Stream[F, Byte],
+      maxHeaderSize: Int,
+      requestHeaderReceiveTimeout: Duration,
+      httpApp: HttpApp[F],
+      errorHandler: Throwable => F[Response[F]]): F[(Request[F], Response[F], Stream[F, Byte])] =
+    for {
+      tup <- Parser.Request.parser(maxHeaderSize, durationToFinite(requestHeaderReceiveTimeout))(
+        incoming)
+      (req, rest) = tup
+      resp <- httpApp
+        .run(req)
+        .handleErrorWith(errorHandler)
+        .handleError(_ => serverFailure.covary[F])
+    } yield (req, resp, rest)
+
+  private[internal] def send[F[_]: Sync](socket: Socket[F])(
+      request: Option[Request[F]],
+      resp: Response[F],
+      idleTimeout: Duration,
+      onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit]): F[Unit] =
+    Encoder
+      .respToBytes[F](resp)
+      .through(socket.writes(durationToFinite(idleTimeout)))
+      .compile
+      .drain
+      .attempt
+      .flatMap {
+        case Left(err) => onWriteFailure(request, resp, err)
+        case Right(()) => Sync[F].pure(())
+      }
+
+  private[internal] def postProcessResponse[F[_]: Timer: Monad](
+      req: Request[F],
+      resp: Response[F]): F[Response[F]] = {
+    val reqHasClose = req.headers.exists {
+      // We know this is raw because we have not parsed any headers in the underlying alg.
+      // If Headers are being parsed into processed for in ParseHeaders this is incorrect.
+      case Header.Raw(name, values) => name == connectionCi && values.contains(closeCi.value)
+      case _ => false
+    }
+    val connection: Connection =
+      if (reqHasClose) close
+      else keepAlive
+    for {
+      date <- HttpDate.current[F].map(Date(_))
+    } yield resp.withHeaders(Headers.of(date, connection) ++ resp.headers)
   }
+
+  private[internal] def runConnection[F[_]: Concurrent: Timer](
+      socket: Socket[F],
+      logger: Logger[F],
+      idleTimeout: Duration,
+      receiveBufferSize: Int,
+      maxHeaderSize: Int,
+      requestHeaderReceiveTimeout: Duration,
+      httpApp: HttpApp[F],
+      errorHandler: Throwable => F[org.http4s.Response[F]],
+      onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit]
+  ): Stream[F, Nothing] =
+    Stream
+      .unfoldLoopEval(reachedEndError(socket, idleTimeout, receiveBufferSize))(s =>
+        runApp(s, maxHeaderSize, requestHeaderReceiveTimeout, httpApp, errorHandler).attempt.map {
+          case Right((req, resp, rest)) => (Right((req, resp)), Some(rest))
+          case Left(e) => (Left(e), None)
+        })
+      .evalMap {
+        case Right((req, resp)) =>
+          postProcessResponse(req, resp).map(resp => (req, resp).asRight[Throwable])
+        case other => other.pure[F]
+      }
+      .evalTap {
+        case Right((request, response)) =>
+          send(socket)(Some(request), response, idleTimeout, onWriteFailure)
+        case Left(err) =>
+          err match {
+            // Timeouts Do Not Get Responses
+            // Thrown by Stream.timeout or Concurrent.timeout
+            case _: TimeoutException =>
+              errorHandler(
+                err).void // Lets users see responses, but cannot generate responses i don't like this
+            // Thrown by fs2.io.tcp.Socket read/write
+            case _: InterruptedByTimeoutException => errorHandler(err).void
+            case e: EOFException => logger.warn(e)("Unexpected EOF Encountered")
+            case err =>
+              errorHandler(err)
+                .handleError(_ => serverFailure.covary[F])
+                .flatMap(send(socket)(None, _, idleTimeout, onWriteFailure))
+          }
+      }
+      .takeWhile {
+        case Left(_) => false
+        case Right((req, resp)) =>
+          !(
+            req.headers.get(Connection).exists(_.hasClose) ||
+              resp.headers.get(Connection).exists(_.hasClose)
+          )
+      }
+      .drain
+
 }

From f044e2b0e119b7e492be0aee4153059ab310a48f Mon Sep 17 00:00:00 2001
From: Raas Ahsan <raas.ahsan@bamtechmedia.com>
Date: Mon, 1 Feb 2021 14:30:02 -0600
Subject: [PATCH 17/35] Apparently you have to pass in maxConnections for it to
 be used

---
 .../org/http4s/server/blaze/BlazeServerBuilder.scala     | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
index 76ad1cc37e5..75a262b9b4a 100644
--- a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
+++ b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
@@ -154,7 +154,7 @@ class BlazeServerBuilder[F[_]] private (
     httpApp = httpApp,
     serviceErrorHandler = serviceErrorHandler,
     banner = banner,
-    maxConnections = maxConnections,    
+    maxConnections = maxConnections,
     channelOptions = channelOptions
   )
 
@@ -398,7 +398,12 @@ class BlazeServerBuilder[F[_]] private (
               .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
           case Nio1 =>
             NIO1SocketServerGroup
-              .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
+              .fixedGroup(
+                connectorPoolSize,
+                bufferSize,
+                channelOptions,
+                selectorThreadFactory,
+                maxConnections = maxConnections)
         }
       })(factory => F.delay(factory.closeGroup()))
 

From 06fabd40c13bfa0e4aa083251520d9d9cb08f687 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris.davenport@banno.com>
Date: Mon, 1 Feb 2021 12:54:55 -0800
Subject: [PATCH 18/35] Add Default Args Binary Fixes

---
 build.sbt | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/build.sbt b/build.sbt
index e8f7d7a0404..139e5509559 100644
--- a/build.sbt
+++ b/build.sbt
@@ -241,7 +241,7 @@ lazy val emberCore = libraryProject("ember-core")
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser.httpHeaderAndBody"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Response.parser"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Util.readWithTimeout"),
-      
+
     )
   )
   .dependsOn(core, testing % "test->test")
@@ -265,7 +265,16 @@ lazy val emberServer = libraryProject("ember-server")
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$8"),
       ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$11"),
       ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$13"),
-      ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$7")
+      ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$7"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$9"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$10"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$11"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$12"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$13"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$12"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$11"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.server.internal.ServerHelpers.server$default$9")
+
     )
   )
   .dependsOn(emberCore % "compile;test->test", server % "compile;test->test", emberClient % "test->compile")

From ecfa426a428f0f257b3058cb455bb8ed427ab017 Mon Sep 17 00:00:00 2001
From: Matthias Sperl <sperl.matthias0@gmail.com>
Date: Mon, 1 Feb 2021 22:32:28 +0100
Subject: [PATCH 19/35] try to fix parser cylces once and for all

---
 core/src/main/scala/org/http4s/Uri.scala      | 687 +++++++++---------
 .../org/http4s/headers/Content-Location.scala |   4 +-
 .../scala/org/http4s/headers/Forwarded.scala  |   9 +-
 .../main/scala/org/http4s/headers/Host.scala  |   3 +-
 .../main/scala/org/http4s/headers/Link.scala  |   6 +-
 .../scala/org/http4s/headers/Location.scala   |   4 +-
 .../scala/org/http4s/headers/Origin.scala     |   4 +-
 .../scala/org/http4s/headers/Referer.scala    |   4 +-
 .../org/http4s/headers/X-Forwarded-For.scala  |   2 +-
 .../org/http4s/parser/UriParserSpec.scala     |   2 +-
 10 files changed, 351 insertions(+), 374 deletions(-)

diff --git a/core/src/main/scala/org/http4s/Uri.scala b/core/src/main/scala/org/http4s/Uri.scala
index 8438f1b2b77..416211c850b 100644
--- a/core/src/main/scala/org/http4s/Uri.scala
+++ b/core/src/main/scala/org/http4s/Uri.scala
@@ -170,7 +170,7 @@ object Uri extends UriPlatform {
 
   /** Decodes the String to a [[Uri]] using the RFC 3986 uri decoding specification */
   def fromString(s: String): ParseResult[Uri] =
-    ParseResult.fromParser(uriReferenceUtf8, "Invalid URI")(s)
+    ParseResult.fromParser(Parser.uriReferenceUtf8, "Invalid URI")(s)
 
   /** Parses a String to a [[Uri]] according to RFC 3986.  If decoding
     *  fails, throws a [[ParseFailure]].
@@ -181,118 +181,9 @@ object Uri extends UriPlatform {
   def unsafeFromString(s: String): Uri =
     fromString(s).valueOr(throw _)
 
-  /* hier-part   = "//" authority path-abempty
-   *             / path-absolute
-   *             / path-rootless
-   *             / path-empty
-   */
-  def hierPart(cs: JCharset): Parser0[(Option[Authority], Path)] = {
-    import P.string
-    import Authority.{parser => authority}
-    import Path.{pathAbempty, pathAbsolute, pathEmpty, pathRootless}
-    val rel: P[(Option[Authority], Path)] = (string("//") *> authority(cs) ~ pathAbempty).map {
-      case (a, p) => (Some(a), p)
-    }
-    P.oneOf0(
-      rel :: pathAbsolute.map((None, _)) :: pathRootless.map((None, _)) :: pathEmpty.map(
-        (None, _)) :: Nil)
-  }
-
-  /* absolute-URI  = scheme ":" hier-part [ "?" query ] */
-  private[http4s] def absoluteUri(cs: JCharset): P[Uri] = {
-    import cats.parse.Parser.char
-    import Uri.Scheme.{parser => scheme}
-    import Query.{parser => query}
-
-    (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).?).map { case ((s, (a, p)), q) =>
-      Uri(scheme = Some(s), authority = a, path = p, query = q.getOrElse(Query.empty))
-    }
-  }
-
-  private[http4s] def parser(cs: JCharset): P[Uri] = {
-    import cats.parse.Parser.char
-    import Uri.Scheme.{parser => scheme}
-    import Query.{parser => query}
-    import Fragment.{parser => fragment}
-
-    (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).? ~ (char('#') *> fragment).?)
-      .map { case (((s, (a, p)), q), f) =>
-        Uri(
-          scheme = Some(s),
-          authority = a,
-          path = p,
-          query = q.getOrElse(Query.empty),
-          fragment = f)
-      }
-  }
-
-  /* relative-part = "//" authority path-abempty
-                   / path-absolute
-                   / path-noscheme
-                   / path-empty
-   */
-  private[http4s] def relativePart(cs: JCharset): Parser0[(Option[Authority], Path)] = {
-    import cats.parse.Parser.string
-    import Authority.{parser => authority}
-    import Path.{pathAbempty, pathAbsolute, pathEmpty, pathNoscheme}
-
-    P.oneOf0(
-      ((string("//") *> authority(cs) ~ pathAbempty).map { case (a, p) =>
-        (Some(a), p)
-      }) :: (pathAbsolute.map((None, _))) :: (pathNoscheme.map((None, _))) :: (pathEmpty.map(
-        (None, _))) :: Nil)
-  }
-
-  /* relative-ref  = relative-part [ "?" query ] [ "#" fragment ] */
-  private[http4s] def relativeRef(cs: JCharset): Parser0[Uri] = {
-    import cats.parse.Parser.char
-    import Query.{parser => query}
-    import Fragment.{parser => fragment}
-
-    (relativePart(cs) ~ (char('?') *> query).? ~ (char('#') *> fragment).?).map {
-      case (((a, p), q), f) =>
-        Uri(scheme = None, authority = a, path = p, query = q.getOrElse(Query.empty), fragment = f)
-    }
-  }
-
-  private[http4s] lazy val uriReferenceUtf8: Parser0[Uri] = uriReference(StandardCharsets.UTF_8)
-  private[http4s] def uriReference(cs: JCharset): Parser0[Uri] =
-    parser(cs).backtrack.orElse(relativeRef(cs))
-
   /** Decodes the String to a [[Uri]] using the RFC 7230 section 5.3 uri decoding specification */
   def requestTarget(s: String): ParseResult[Uri] =
-    ParseResult.fromParser(requestTargetParser, "Invalid request target")(s)
-
-  /* request-target = origin-form
-                    / absolute-form
-                    / authority-form
-                    / asterisk-form
-   */
-  private lazy val requestTargetParser: Parser0[Uri] = {
-    import cats.parse.Parser.{char, oneOf0}
-    import Authority.{parser => authority}
-    import Path.absolutePath
-    import Query.{parser => query}
-
-    /* origin-form    = absolute-path [ "?" query ] */
-    val originForm: P[Uri] =
-      (absolutePath ~ (char('?') *> query).?).map { case (p, q) =>
-        Uri(scheme = None, authority = None, path = p, query = q.getOrElse(Query.empty))
-      }
-
-    /* absolute-form = absolute-URI */
-    def absoluteForm: P[Uri] = absoluteUri(StandardCharsets.UTF_8)
-
-    /* authority-form = authority */
-    val authorityForm: Parser0[Uri] =
-      authority(StandardCharsets.UTF_8).map(a => Uri(authority = Some(a)))
-
-    /* asterisk-form = "*" */
-    val asteriskForm: P[Uri] =
-      char('*').as(Uri(path = Path.Asterisk))
-
-    oneOf0(originForm :: absoluteForm :: authorityForm :: asteriskForm :: Nil)
-  }
+    ParseResult.fromParser(Parser.requestTargetParser, "Invalid request target")(s)
 
   /** A [[org.http4s.Uri]] may begin with a scheme name that refers to a
     * specification for assigning identifiers within that scheme.
@@ -302,7 +193,7 @@ object Uri extends UriPlatform {
     *
     * @see [[https://tools.ietf.org/html/rfc3986#section-3.1 RFC 3986, Section 3.1, Scheme]]
     */
-  final class Scheme private (val value: String) extends Ordered[Scheme] {
+  final class Scheme private[http4s] (val value: String) extends Ordered[Scheme] {
     override def equals(o: Any) =
       o match {
         case that: Scheme => this.value.equalsIgnoreCase(that.value)
@@ -330,27 +221,12 @@ object Uri extends UriPlatform {
     def parse(s: String): ParseResult[Scheme] = fromString(s)
 
     def fromString(s: String): ParseResult[Scheme] =
-      ParseResult.fromParser(parser, "Invalid scheme")(s)
+      ParseResult.fromParser(Parser.scheme, "Invalid scheme")(s)
 
     /** Like `fromString`, but throws on invalid input */
     def unsafeFromString(s: String): Scheme =
       fromString(s).fold(throw _, identity)
 
-    /* scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) */
-    private[http4s] val parser: P[Scheme] = {
-      import cats.parse.Parser.{charIn, not, string}
-      import Rfc3986.{alpha, digit}
-
-      val unary = alpha.orElse(digit).orElse(charIn("+-."))
-
-      (string("https") <* not(unary))
-        .as(https)
-        .backtrack
-        .orElse((string("http") <* not(unary)).as(http))
-        .backtrack
-        .orElse((alpha *> unary.rep0).string.map(new Scheme(_)))
-    }
-
     implicit val http4sOrderForScheme: Order[Scheme] =
       Order.fromComparable
     implicit val http4sShowForScheme: Show[Scheme] =
@@ -367,18 +243,6 @@ object Uri extends UriPlatform {
 
   type Fragment = String
 
-  object Fragment {
-    import cats.parse.Parser.charIn
-    import Rfc3986.pchar
-
-    /* fragment    = *( pchar / "/" / "?" )
-     *
-     * Not URL decoded.
-     */
-    private[http4s] val parser: Parser0[Fragment] =
-      pchar.orElse(charIn("/?")).rep0.string
-  }
-
   final case class Authority(
       userInfo: Option[UserInfo] = None,
       host: Host = RegName("localhost"),
@@ -395,16 +259,6 @@ object Uri extends UriPlatform {
   }
 
   object Authority {
-    import cats.parse.Parser.{char}
-    import UserInfo.{parser => userinfo}
-    import Host.{parser => host}
-    import Port.{parser => port}
-
-    /* authority   = [ userinfo "@" ] host [ ":" port ] */
-    def parser(cs: JCharset): Parser0[Authority] =
-      ((userinfo(cs) <* char('@')).backtrack.? ~ host ~ (char(':') *> port).?).map {
-        case ((ui, h), p) => Authority(userInfo = ui, host = h, port = p.flatten)
-      }
 
     implicit val catsInstancesForHttp4sAuthority
         : Hash[Authority] with Order[Authority] with Show[Authority] =
@@ -544,28 +398,6 @@ object Uri extends UriPlatform {
 
       val empty: Segment = Segment("")
 
-      import cats.parse.Parser.char
-      import Rfc3986.{pchar, pctEncoded, subDelims, unreserved}
-
-      /* segment       = *pchar */
-      lazy val segment: Parser0[Segment] =
-        pchar.rep0.string.map(new Segment(_))
-
-      /* segment-nz    = 1*pchar */
-      lazy val segmentNz: P[Segment] =
-        pchar.rep.string.map(new Segment(_))
-
-      /* segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
-                     ; non-zero-length segment without any colon ":" */
-      lazy val segmentNzNc: P[Segment] =
-        unreserved
-          .orElse(pctEncoded)
-          .orElse(subDelims)
-          .orElse(char('@'))
-          .rep
-          .string
-          .map(new Segment(_))
-
       implicit val http4sInstancesForSegment: Order[Segment] =
         new Order[Segment] {
           def compare(x: Segment, y: Segment): Int =
@@ -621,70 +453,6 @@ object Uri extends UriPlatform {
         def combine(x: Path, y: Path): Path = x.concat(y)
       }
 
-    import cats.parse.Parser.{char, pure}
-    import Segment.{segment, segmentNz, segmentNzNc}
-
-    /* path-abempty  = *( "/" segment ) */
-    lazy val pathAbempty: cats.parse.Parser0[Path] =
-      (char('/') *> segment).rep0.map {
-        case Nil => Path.empty
-        case List(Segment.empty) => Path.Root
-        case segments =>
-          val segmentsV = segments.toVector
-          if (segmentsV.last.isEmpty)
-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
-          else
-            Path(segmentsV, absolute = true, endsWithSlash = false)
-      }
-
-    /* path-absolute = "/" [ segment-nz *( "/" segment ) ] */
-    lazy val pathAbsolute: P[Path] =
-      (char('/') *> (segmentNz ~ (char('/') *> segment).rep0).?).map {
-        case Some((head, tail)) =>
-          val segmentsV = head +: tail.toVector
-          if (segmentsV.last.isEmpty)
-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
-          else
-            Path(segmentsV, absolute = true, endsWithSlash = false)
-        case None =>
-          Path.Root
-      }
-
-    /* path-rootless = segment-nz *( "/" segment ) */
-    lazy val pathRootless: P[Path] =
-      (segmentNz ~ (char('/') *> segment).rep0).map { case (head, tail) =>
-        val segmentsV = head +: tail.toVector
-        if (segmentsV.last.isEmpty)
-          Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)
-        else
-          Path(segmentsV, absolute = false, endsWithSlash = false)
-      }
-
-    /* path-empty    = 0<pchar> */
-    lazy val pathEmpty: Parser0[Path] =
-      pure(Path.empty)
-
-    /* path-noscheme = segment-nz-nc *( "/" segment ) */
-    lazy val pathNoscheme: P[Path] =
-      (segmentNzNc ~ (char('/') *> segment).rep0).map { case (head, tail) =>
-        val segmentsV = head +: tail.toVector
-        if (segmentsV.last.isEmpty)
-          Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)
-        else
-          Path(segmentsV, absolute = false, endsWithSlash = false)
-      }
-
-    /* absolute-path = 1*( "/" segment ) */
-    lazy val absolutePath: P[Path] =
-      (char('/') *> segment).rep.map {
-        case NonEmptyList(Segment.empty, Nil) => Path.Root
-        case segments =>
-          val segmentsV = segments.toList.toVector
-          if (segmentsV.last.isEmpty)
-            Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
-          else
-            Path(segmentsV, absolute = true, endsWithSlash = false)
-      }
   }
 
   /** The userinfo subcomponent may consist of a user name and,
@@ -718,19 +486,7 @@ object Uri extends UriPlatform {
 
     /** Parses a userInfo from a string percent-encoded in a specific charset. */
     def fromStringWithCharset(s: String, cs: JCharset): ParseResult[UserInfo] =
-      ParseResult.fromParser(parser(cs), "Invalid userinfo")(s)
-
-    /* userinfo    = *( unreserved / pct-encoded / sub-delims / ":" ) */
-    private[http4s] def parser(cs: JCharset): cats.parse.Parser0[UserInfo] = {
-      import cats.parse.Parser.{char, charIn, oneOf}
-      import Rfc3986.{pctEncoded, subDelims, unreserved}
-
-      val username = oneOf(unreserved :: pctEncoded :: subDelims :: Nil).rep0.string
-      val password = oneOf(unreserved :: pctEncoded :: subDelims :: charIn(':') :: Nil).rep0.string
-      (username ~ (char(':') *> password).?).map { case (u, p) =>
-        UserInfo(decode(u, cs), p.map(decode(_, cs)))
-      }
-    }
+      ParseResult.fromParser(Parser.userinfo(cs), "Invalid userinfo")(s)
 
     implicit val http4sInstancesForUserInfo
         : HttpCodec[UserInfo] with Order[UserInfo] with Hash[UserInfo] with Show[UserInfo] =
@@ -776,22 +532,6 @@ object Uri extends UriPlatform {
   }
 
   object Host {
-    /* host          = IP-literal / IPv4address / reg-name */
-    val parser: Parser0[Host] = {
-      import cats.parse.Parser.char
-      import Ipv4Address.{parser => ipv4Address}
-      import Ipv6Address.{parser => ipv6Address}
-      import RegName.{parser => regName}
-
-      // TODO This isn't in the 0.21 model.
-      /* IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" ) */
-      val ipVFuture: P[Nothing] = P.fail
-
-      /* IP-literal    = "[" ( IPv6address / IPvFuture  ) "]" */
-      val ipLiteral = char('[') *> ipv6Address.orElse(ipVFuture) <* char(']')
-
-      ipLiteral.orElse(ipv4Address.backtrack).orElse(regName)
-    }
 
     implicit val catsInstancesForHttp4sUriHost: Hash[Host] with Order[Host] with Show[Host] =
       new Hash[Host] with Order[Host] with Show[Host] {
@@ -877,7 +617,7 @@ object Uri extends UriPlatform {
 
   object Ipv4Address {
     def fromString(s: String): ParseResult[Ipv4Address] =
-      ParseResult.fromParser(parser, "Invalid IPv4 Address")(s)
+      ParseResult.fromParser(Parser.ipv4Address, "Invalid IPv4 Address")(s)
 
     /** Like `fromString`, but throws on invalid input */
     def unsafeFromString(s: String): Ipv4Address =
@@ -899,9 +639,6 @@ object Uri extends UriPlatform {
           throw bug(s"Inet4Address.getAddress not exactly four bytes: ${array}")
       }
 
-    private[http4s] val parser: P[Ipv4Address] =
-      Rfc3986.ipv4Bytes.map { case (a, b, c, d) => Ipv4Address(a, b, c, d) }
-
     implicit val http4sInstancesForIpv4Address: HttpCodec[Ipv4Address]
       with Order[Ipv4Address]
       with Hash[Ipv4Address]
@@ -1016,7 +753,7 @@ object Uri extends UriPlatform {
 
   object Ipv6Address {
     def fromString(s: String): ParseResult[Ipv6Address] =
-      ParseResult.fromParser(parser, "Invalid IPv6 address")(s)
+      ParseResult.fromParser(Parser.ipv6Address, "Invalid IPv6 address")(s)
 
     /** Like `fromString`, but throws on invalid input */
     def unsafeFromString(s: String): Ipv6Address =
@@ -1058,60 +795,6 @@ object Uri extends UriPlatform {
       }
     }
 
-    private[http4s] val parser: P[Ipv6Address] = {
-      import cats.parse.Parser.{char, string}
-      import cats.parse.Parser
-      import Rfc3986.{hexdig, ipv4Bytes}
-
-      def toIpv6(lefts: collection.Seq[Short], rights: collection.Seq[Short]): Ipv6Address =
-        lefts ++ collection.Seq.fill(8 - lefts.size - rights.size)(0.toShort) ++ rights match {
-          case collection.Seq(a, b, c, d, e, f, g, h) =>
-            Ipv6Address(a, b, c, d, e, f, g, h)
-        }
-
-      val h16: P[Short] =
-        (hexdig ~ hexdig.? ~ hexdig.? ~ hexdig.?).string.map { (s: String) =>
-          java.lang.Integer.parseInt(s, 16).toShort
-        }
-
-      val colon = char(':')
-      val doubleColon = string("::").void
-      val h16Colon = h16 <* colon
-
-      val parsedIpv4Bytes = ipv4Bytes.map { case (a: Byte, b: Byte, c: Byte, d: Byte) =>
-        List(((a << 8) | b).toShort, ((c << 8) | d).toShort)
-      }
-
-      def rightsWithIpv4(n: Int) = (1 to n)
-        .map { i =>
-          (h16Colon.repExactlyAs[List[Short]](i) ~ parsedIpv4Bytes).backtrack.map { case (l, r) =>
-            l ++ r
-          }
-        }
-        .foldLeft(parsedIpv4Bytes.backtrack)(_ | _)
-
-      val ls32: P[List[Short]] = {
-        val option1 = ((h16 <* colon.void) ~ h16).map(t => List(t._1, t._2))
-        option1.backtrack.orElse(parsedIpv4Bytes)
-      }
-
-      val fullIpv6WihtOptionalIpv4 = (h16Colon.repExactlyAs[List[Short]](6) ~ ls32)
-        .map { case (ls: List[Short], rs) => toIpv6(ls.toList, rs) }
-
-      val shortIpv6WithIpv4 = for {
-        lefts <- h16.repSep0(0, 5, colon).with1 <* doubleColon
-        rights <- rightsWithIpv4(4 - lefts.size)
-      } yield toIpv6(lefts, rights)
-
-      val shortIpv6 = for {
-        lefts <- h16.repSep0(0, 7, colon).with1 <* doubleColon
-        rights <-
-          if (6 - lefts.size > 0)(h16.repSep0(0, 6 - lefts.size, colon)) else Parser.pure(Nil)
-      } yield toIpv6(lefts, rights)
-
-      fullIpv6WihtOptionalIpv4.backtrack.orElse(shortIpv6WithIpv4.backtrack).orElse(shortIpv6)
-    }
-
     implicit val http4sInstancesForIpv6Address: HttpCodec[Ipv6Address]
       with Order[Ipv6Address]
       with Hash[Ipv6Address]
@@ -1140,18 +823,6 @@ object Uri extends UriPlatform {
   object RegName {
     def apply(name: String): RegName = new RegName(CIString(name))
 
-    /* reg-name    = *( unreserved / pct-encoded / sub-delims) */
-    val parser: Parser0[RegName] = {
-      import Rfc3986.{pctEncoded, subDelims, unreserved}
-
-      unreserved
-        .orElse(pctEncoded)
-        .orElse(subDelims)
-        .rep0
-        .string
-        .map(s => RegName(CIString(decode(s))))
-    }
-
     implicit val catsInstancesForHttp4sUriRegName
         : Hash[RegName] with Order[RegName] with Show[RegName] =
       new Hash[RegName] with Order[RegName] with Show[RegName] {
@@ -1166,23 +837,6 @@ object Uri extends UriPlatform {
       }
   }
 
-  object Port {
-    /* port        = *DIGIT
-     *
-     * Limitation: we only parse up to Int. The spec allows bigint!
-     */
-    private[http4s] val parser: Parser0[Option[Int]] = {
-      import Rfc3986.digit
-
-      digit.rep0.string.mapFilter {
-        case "" => Some(None)
-        case s =>
-          try Some(Some(s.toInt))
-          catch { case _: NumberFormatException => None }
-      }
-    }
-  }
-
   /** Resolve a relative Uri reference, per RFC 3986 sec 5.2
     */
   def resolve(base: Uri, reference: Uri): Uri = {
@@ -1398,4 +1052,331 @@ object Uri extends UriPlatform {
       override def show(t: Uri): String =
         t.renderString
     }
+
+  private[http4s] object Parser {
+    /* port        = *DIGIT
+     *
+     * Limitation: we only parse up to Int. The spec allows bigint!
+     */
+    private[http4s] val port: Parser0[Option[Int]] = {
+      import Rfc3986.digit
+
+      digit.rep0.string.mapFilter {
+        case "" => Some(None)
+        case s =>
+          try Some(Some(s.toInt))
+          catch { case _: NumberFormatException => None }
+      }
+    }
+
+    /* reg-name    = *( unreserved / pct-encoded / sub-delims) */
+    private[http4s] val regName: Parser0[Uri.RegName] = {
+      import Rfc3986.{pctEncoded, subDelims, unreserved}
+
+      unreserved
+        .orElse(pctEncoded)
+        .orElse(subDelims)
+        .rep0
+        .string
+        .map(s => Uri.RegName(CIString(Uri.decode(s))))
+    }
+
+    private[http4s] val ipv6Address: P[Uri.Ipv6Address] = {
+      import cats.parse.Parser.{char, string}
+      import Rfc3986.{hexdig, ipv4Bytes}
+
+      def toIpv6(lefts: collection.Seq[Short], rights: collection.Seq[Short]): Uri.Ipv6Address =
+        lefts ++ collection.Seq.fill(8 - lefts.size - rights.size)(0.toShort) ++ rights match {
+          case collection.Seq(a, b, c, d, e, f, g, h) =>
+            Uri.Ipv6Address(a, b, c, d, e, f, g, h)
+        }
+
+      val h16: P[Short] =
+        (hexdig ~ hexdig.? ~ hexdig.? ~ hexdig.?).string.map { (s: String) =>
+          java.lang.Integer.parseInt(s, 16).toShort
+        }
+
+      val colon = char(':')
+      val doubleColon = string("::").void
+      val h16Colon = h16 <* colon
+
+      val parsedIpv4Bytes = ipv4Bytes.map { case (a: Byte, b: Byte, c: Byte, d: Byte) =>
+        List(((a << 8) | b).toShort, ((c << 8) | d).toShort)
+      }
+
+      def rightsWithIpv4(n: Int) = (1 to n)
+        .map { i =>
+          (h16Colon.repExactlyAs[List[Short]](i) ~ parsedIpv4Bytes).backtrack.map { case (l, r) =>
+            l ++ r
+          }
+        }
+        .foldLeft(parsedIpv4Bytes.backtrack)(_ | _)
+
+      val ls32: P[List[Short]] = {
+        val option1 = ((h16 <* colon.void) ~ h16).map(t => List(t._1, t._2))
+        option1.backtrack.orElse(parsedIpv4Bytes)
+      }
+
+      val fullIpv6WihtOptionalIpv4 = (h16Colon.repExactlyAs[List[Short]](6) ~ ls32)
+        .map { case (ls: List[Short], rs) => toIpv6(ls.toList, rs) }
+
+      val shortIpv6WithIpv4 = for {
+        lefts <- h16.repSep0(0, 5, colon).with1 <* doubleColon
+        rights <- rightsWithIpv4(4 - lefts.size)
+      } yield toIpv6(lefts, rights)
+
+      val shortIpv6 = for {
+        lefts <- h16.repSep0(0, 7, colon).with1 <* doubleColon
+        rights <-
+          if (6 - lefts.size > 0)(h16.repSep0(0, 6 - lefts.size, colon)) else P.pure(Nil)
+      } yield toIpv6(lefts, rights)
+
+      fullIpv6WihtOptionalIpv4.backtrack.orElse(shortIpv6WithIpv4.backtrack).orElse(shortIpv6)
+    }
+
+    private[http4s] val ipv4Address: P[Uri.Ipv4Address] =
+      Rfc3986.ipv4Bytes.map { case (a, b, c, d) => Uri.Ipv4Address(a, b, c, d) }
+
+    /* host          = IP-literal / IPv4address / reg-name */
+    private[http4s] val host: Parser0[Uri.Host] = {
+      import cats.parse.Parser.char
+
+      // TODO This isn't in the 0.21 model.
+      /* IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" ) */
+      val ipVFuture: P[Nothing] = P.fail
+
+      /* IP-literal    = "[" ( IPv6address / IPvFuture  ) "]" */
+      val ipLiteral = char('[') *> ipv6Address.orElse(ipVFuture) <* char(']')
+
+      ipLiteral.orElse(ipv4Address.backtrack).orElse(regName)
+    }
+
+    /* userinfo    = *( unreserved / pct-encoded / sub-delims / ":" ) */
+    private[http4s] def userinfo(cs: JCharset): Parser0[Uri.UserInfo] = {
+      import cats.parse.Parser.{char, charIn, oneOf}
+      import Rfc3986.{pctEncoded, subDelims, unreserved}
+
+      val username = oneOf(unreserved :: pctEncoded :: subDelims :: Nil).rep0.string
+      val password = oneOf(unreserved :: pctEncoded :: subDelims :: charIn(':') :: Nil).rep0.string
+      (username ~ (char(':') *> password).?).map { case (u, p) =>
+        Uri.UserInfo(Uri.decode(u, cs), p.map(Uri.decode(_, cs)))
+      }
+    }
+
+    /* segment       = *pchar */
+    private[http4s] val segment: Parser0[Uri.Path.Segment] =
+      Rfc3986.pchar.rep0.string.map(Uri.Path.Segment.encoded)
+
+    /* segment-nz    = 1*pchar */
+    private[http4s] val segmentNz: P[Uri.Path.Segment] =
+      Rfc3986.pchar.rep.string.map(Uri.Path.Segment.encoded)
+
+    /* segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
+                   ; non-zero-length segment without any colon ":" */
+    private[http4s] val segmentNzNc: P[Uri.Path.Segment] =
+      Rfc3986.unreserved
+        .orElse(Rfc3986.pctEncoded)
+        .orElse(Rfc3986.subDelims)
+        .orElse(P.char('@'))
+        .rep
+        .string
+        .map(Uri.Path.Segment.encoded(_))
+
+    import cats.parse.Parser.{char, pure}
+
+    /* path-abempty  = *( "/" segment ) */
+    private[http4s] val pathAbempty: Parser0[Uri.Path] =
+      (char('/') *> segment).rep0.map {
+        case Nil => Uri.Path.empty
+        case List(Uri.Path.Segment.empty) => Uri.Path.Root
+        case segments =>
+          val segmentsV = segments.toVector
+          if (segmentsV.last.isEmpty)
+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
+          else
+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)
+      }
+
+    /* path-absolute = "/" [ segment-nz *( "/" segment ) ] */
+    private[http4s] val pathAbsolute: P[Uri.Path] =
+      (char('/') *> (segmentNz ~ (char('/') *> segment).rep0).?).map {
+        case Some((head, tail)) =>
+          val segmentsV = head +: tail.toVector
+          if (segmentsV.last.isEmpty)
+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
+          else
+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)
+        case None =>
+          Uri.Path.Root
+      }
+
+    /* path-rootless = segment-nz *( "/" segment ) */
+    private[http4s] val pathRootless: P[Uri.Path] =
+      (segmentNz ~ (char('/') *> segment).rep0).map { case (head, tail) =>
+        val segmentsV = head +: tail.toVector
+        if (segmentsV.last.isEmpty)
+          Uri.Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)
+        else
+          Uri.Path(segmentsV, absolute = false, endsWithSlash = false)
+      }
+
+    /* path-empty    = 0<pchar> */
+    private[http4s] val pathEmpty: Parser0[Uri.Path] =
+      pure(Uri.Path.empty)
+
+    /* path-noscheme = segment-nz-nc *( "/" segment ) */
+    private[http4s] val pathNoscheme: P[Uri.Path] =
+      (segmentNzNc ~ (char('/') *> segment).rep0).map { case (head, tail) =>
+        val segmentsV = head +: tail.toVector
+        if (segmentsV.last.isEmpty)
+          Uri.Path(segmentsV.dropRight(1), absolute = false, endsWithSlash = true)
+        else
+          Uri.Path(segmentsV, absolute = false, endsWithSlash = false)
+      }
+
+    /* absolute-path = 1*( "/" segment ) */
+    private[http4s] val absolutePath: P[Uri.Path] =
+      (char('/') *> segment).rep.map {
+        case NonEmptyList(Uri.Path.Segment.empty, Nil) => Uri.Path.Root
+        case segments =>
+          val segmentsV = segments.toList.toVector
+          if (segmentsV.last.isEmpty)
+            Uri.Path(segmentsV.dropRight(1), absolute = true, endsWithSlash = true)
+          else
+            Uri.Path(segmentsV, absolute = true, endsWithSlash = false)
+      }
+
+    /* authority   = [ userinfo "@" ] host [ ":" port ] */
+    private[http4s] def authority(cs: JCharset): Parser0[Uri.Authority] =
+      ((userinfo(cs) <* char('@')).backtrack.? ~ host ~ (char(':') *> port).?).map {
+        case ((ui, h), p) => Uri.Authority(userInfo = ui, host = h, port = p.flatten)
+      }
+
+    /* fragment    = *( pchar / "/" / "?" )
+     *
+     * Not URL decoded.
+     */
+    private[http4s] val fragment: Parser0[Uri.Fragment] =
+      Rfc3986.pchar.orElse(P.charIn("/?")).rep0.string
+
+    /* scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) */
+    private[http4s] val scheme: P[Uri.Scheme] = {
+      import cats.parse.Parser.{charIn, not, string}
+      import Rfc3986.{alpha, digit}
+
+      val unary = alpha.orElse(digit).orElse(charIn("+-."))
+
+      (string("https") <* not(unary))
+        .as(Uri.Scheme.https)
+        .backtrack
+        .orElse((string("http") <* not(unary)).as(Uri.Scheme.http))
+        .backtrack
+        .orElse((alpha *> unary.rep0).string.map(new Uri.Scheme(_)))
+    }
+
+    /* request-target = origin-form
+                      / absolute-form
+                      / authority-form
+                      / asterisk-form
+     */
+    private[http4s] val requestTargetParser: Parser0[Uri] = {
+      import cats.parse.Parser.{char, oneOf0}
+      import Query.{parser => query}
+
+      /* origin-form    = absolute-path [ "?" query ] */
+      val originForm: P[Uri] =
+        (absolutePath ~ (char('?') *> query).?).map { case (p, q) =>
+          Uri(scheme = None, authority = None, path = p, query = q.getOrElse(Query.empty))
+        }
+
+      /* absolute-form = absolute-URI */
+      def absoluteForm: P[Uri] = absoluteUri(StandardCharsets.UTF_8)
+
+      /* authority-form = authority */
+      val authorityForm: Parser0[Uri] =
+        authority(StandardCharsets.UTF_8).map(a => Uri(authority = Some(a)))
+
+      /* asterisk-form = "*" */
+      val asteriskForm: P[Uri] =
+        char('*').as(Uri(path = Uri.Path.Asterisk))
+
+      oneOf0(originForm :: absoluteForm :: authorityForm :: asteriskForm :: Nil)
+    }
+
+    /* hier-part   = "//" authority path-abempty
+     *             / path-absolute
+     *             / path-rootless
+     *             / path-empty
+     */
+    def hierPart(cs: JCharset): Parser0[(Option[Uri.Authority], Uri.Path)] = {
+      import P.string
+      val rel: P[(Option[Uri.Authority], Uri.Path)] =
+        (string("//") *> authority(cs) ~ pathAbempty).map { case (a, p) =>
+          (Some(a), p)
+        }
+      P.oneOf0(
+        rel :: pathAbsolute.map((None, _)) :: pathRootless.map((None, _)) :: pathEmpty.map(
+          (None, _)) :: Nil)
+    }
+
+    /* absolute-URI  = scheme ":" hier-part [ "?" query ] */
+    private[http4s] def absoluteUri(cs: JCharset): P[Uri] = {
+      import cats.parse.Parser.char
+      import Query.{parser => query}
+
+      (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).?).map { case ((s, (a, p)), q) =>
+        Uri(scheme = Some(s), authority = a, path = p, query = q.getOrElse(Query.empty))
+      }
+    }
+
+    private[http4s] def uri(cs: JCharset): P[Uri] = {
+      import cats.parse.Parser.char
+      import Query.{parser => query}
+
+      (scheme ~ (char(':') *> hierPart(cs)) ~ (char('?') *> query).? ~ (char('#') *> fragment).?)
+        .map { case (((s, (a, p)), q), f) =>
+          Uri(
+            scheme = Some(s),
+            authority = a,
+            path = p,
+            query = q.getOrElse(Query.empty),
+            fragment = f)
+        }
+    }
+
+    /* relative-part = "//" authority path-abempty
+                     / path-absolute
+                     / path-noscheme
+                     / path-empty
+     */
+    private[http4s] def relativePart(cs: JCharset): Parser0[(Option[Uri.Authority], Uri.Path)] = {
+      import cats.parse.Parser.string
+
+      P.oneOf0(
+        ((string("//") *> authority(cs) ~ pathAbempty).map { case (a, p) =>
+          (Some(a), p)
+        }) :: (pathAbsolute.map((None, _))) :: (pathNoscheme.map((None, _))) :: (pathEmpty.map(
+          (None, _))) :: Nil)
+    }
+
+    /* relative-ref  = relative-part [ "?" query ] [ "#" fragment ] */
+    private[http4s] def relativeRef(cs: JCharset): Parser0[Uri] = {
+      import cats.parse.Parser.char
+      import Query.{parser => query}
+
+      (relativePart(cs) ~ (char('?') *> query).? ~ (char('#') *> fragment).?).map {
+        case (((a, p), q), f) =>
+          Uri(
+            scheme = None,
+            authority = a,
+            path = p,
+            query = q.getOrElse(Query.empty),
+            fragment = f)
+      }
+    }
+
+    private[http4s] val uriReferenceUtf8: Parser0[Uri] = uriReference(StandardCharsets.UTF_8)
+    private[http4s] def uriReference(cs: JCharset): Parser0[Uri] =
+      uri(cs).backtrack.orElse(relativeRef(cs))
+  }
 }
diff --git a/core/src/main/scala/org/http4s/headers/Content-Location.scala b/core/src/main/scala/org/http4s/headers/Content-Location.scala
index 06f6ed4517a..55cf5421068 100644
--- a/core/src/main/scala/org/http4s/headers/Content-Location.scala
+++ b/core/src/main/scala/org/http4s/headers/Content-Location.scala
@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets
 object `Content-Location` extends HeaderKey.Internal[`Content-Location`] with HeaderKey.Singleton {
   override def parse(s: String): ParseResult[`Content-Location`] =
     ParseResult.fromParser(parser, "Invalid Content-Location")(s)
-  private[http4s] val parser = Uri
+  private[http4s] val parser = Uri.Parser
     .absoluteUri(StandardCharsets.ISO_8859_1)
-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))
+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))
     .map(`Content-Location`(_))
 }
 
diff --git a/core/src/main/scala/org/http4s/headers/Forwarded.scala b/core/src/main/scala/org/http4s/headers/Forwarded.scala
index c56fed85d67..cdafabf75ca 100644
--- a/core/src/main/scala/org/http4s/headers/Forwarded.scala
+++ b/core/src/main/scala/org/http4s/headers/Forwarded.scala
@@ -22,7 +22,6 @@ import cats.syntax.either._
 import org.http4s._
 import org.http4s.util.{Renderable, Writer}
 import cats.parse.{Numbers, Parser0, Rfc5234, Parser => P}
-import org.http4s.Uri.{Ipv4Address, Ipv6Address}
 import org.http4s.internal.parsing.Rfc7230
 
 import java.util.Locale
@@ -122,8 +121,8 @@ object Forwarded
       val nodeName: P[Node.Name] =
         P.oneOf[Node.Name](
           List(
-            Ipv4Address.parser.map(Node.Name.Ipv4),
-            Ipv6Address.parser
+            Uri.Parser.ipv4Address.map(Node.Name.Ipv4),
+            Uri.Parser.ipv6Address
               .between(P.char('['), P.char(']'))
               .map(Node.Name.Ipv6),
             P.string("unknown").as(Node.Name.Unknown),
@@ -193,7 +192,7 @@ object Forwarded
 
       // ** RFC3986 **
       // port = *DIGIT
-      (Uri.Host.parser ~ (P.char(':') *> port).?)
+      (Uri.Parser.host ~ (P.char(':') *> port).?)
         .map { case (h, p) => apply(h, p.flatten) }
     }
   }
@@ -308,7 +307,7 @@ object Forwarded
     // [RFC3986]
 
     val host = Host.parser
-    val proto = Uri.Scheme.parser
+    val proto = Uri.Parser.scheme
     val node = Node.parser
 
     val forwardedPair = P.oneOf(
diff --git a/core/src/main/scala/org/http4s/headers/Host.scala b/core/src/main/scala/org/http4s/headers/Host.scala
index 1ae30edfab5..b8771c0095b 100644
--- a/core/src/main/scala/org/http4s/headers/Host.scala
+++ b/core/src/main/scala/org/http4s/headers/Host.scala
@@ -29,12 +29,11 @@ object Host extends HeaderKey.Internal[Host] with HeaderKey.Singleton {
     ParseResult.fromParser(parser, "Invalid Host")(s)
 
   private[http4s] val parser = {
-    import Uri.Host.{parser => host}
     val port = Parser.string(":") *> Rfc3986.digit.rep.string.mapFilter { s =>
       Try(s.toInt).toOption
     }
 
-    (host ~ port.?).map { case (host, port) =>
+    (Uri.Parser.host ~ port.?).map { case (host, port) =>
       Host(host.value, port)
     }
   }
diff --git a/core/src/main/scala/org/http4s/headers/Link.scala b/core/src/main/scala/org/http4s/headers/Link.scala
index 654494b123e..9b36fa94be2 100644
--- a/core/src/main/scala/org/http4s/headers/Link.scala
+++ b/core/src/main/scala/org/http4s/headers/Link.scala
@@ -38,12 +38,10 @@ object Link extends HeaderKey.Internal[Link] with HeaderKey.Recurring {
     final case class Type(value: MediaRange) extends LinkParam
 
     // https://tools.ietf.org/html/rfc3986#section-4.1
-    val linkValue: Parser0[LinkValue] = {
-      import Uri._
-      uriReference(StandardCharsets.UTF_8).map { uri =>
+    val linkValue: Parser0[LinkValue] =
+      Uri.Parser.uriReference(StandardCharsets.UTF_8).map { uri =>
         headers.LinkValue(uri)
       }
-    }
 
     val linkParam: Parser0[LinkParam] = {
       val relParser = (string("rel=") *> token.orElse(quotedString))
diff --git a/core/src/main/scala/org/http4s/headers/Location.scala b/core/src/main/scala/org/http4s/headers/Location.scala
index 11401ed79bd..f7a1234ceea 100644
--- a/core/src/main/scala/org/http4s/headers/Location.scala
+++ b/core/src/main/scala/org/http4s/headers/Location.scala
@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets
 object Location extends HeaderKey.Internal[Location] with HeaderKey.Singleton {
   override def parse(s: String): ParseResult[Location] =
     ParseResult.fromParser(parser, "Invalid Location")(s)
-  private[http4s] val parser = Uri
+  private[http4s] val parser = Uri.Parser
     .absoluteUri(StandardCharsets.ISO_8859_1)
-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))
+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))
     .map(Location(_))
 }
 
diff --git a/core/src/main/scala/org/http4s/headers/Origin.scala b/core/src/main/scala/org/http4s/headers/Origin.scala
index 312e9486162..05108b9efdb 100644
--- a/core/src/main/scala/org/http4s/headers/Origin.scala
+++ b/core/src/main/scala/org/http4s/headers/Origin.scala
@@ -75,8 +75,8 @@ object Origin extends HeaderKey.Internal[Origin] with HeaderKey.Singleton {
       .string
       .map(Uri.Scheme.unsafeFromString)
     val stringHost = until(char(':').orElse(`end`)).map(RegName.apply)
-    val bracketedIpv6 = char('[') *> Uri.Ipv6Address.parser <* char(']')
-    val host = List(bracketedIpv6, Uri.Ipv4Address.parser, stringHost).reduceLeft(_ orElse _)
+    val bracketedIpv6 = char('[') *> Uri.Parser.ipv6Address <* char(']')
+    val host = List(bracketedIpv6, Uri.Parser.ipv4Address, stringHost).reduceLeft(_ orElse _)
     val port = char(':') *> digit.rep.string.map(_.toInt)
     val nullHost = (string("null") *> `end`).orElse(`end`).as(Origin.Null)
 
diff --git a/core/src/main/scala/org/http4s/headers/Referer.scala b/core/src/main/scala/org/http4s/headers/Referer.scala
index 3090fe45368..3fb2e636de6 100644
--- a/core/src/main/scala/org/http4s/headers/Referer.scala
+++ b/core/src/main/scala/org/http4s/headers/Referer.scala
@@ -23,9 +23,9 @@ import java.nio.charset.StandardCharsets
 object Referer extends HeaderKey.Internal[Referer] with HeaderKey.Singleton {
   override def parse(s: String): ParseResult[Referer] =
     ParseResult.fromParser(parser, "Invalid Referer")(s)
-  private[http4s] val parser = Uri
+  private[http4s] val parser = Uri.Parser
     .absoluteUri(StandardCharsets.ISO_8859_1)
-    .orElse(Uri.relativeRef(StandardCharsets.ISO_8859_1))
+    .orElse(Uri.Parser.relativeRef(StandardCharsets.ISO_8859_1))
     .map(Referer(_))
 }
 
diff --git a/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala b/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
index a2719bdc176..8e3b0ae38db 100644
--- a/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
+++ b/core/src/main/scala/org/http4s/headers/X-Forwarded-For.scala
@@ -29,7 +29,7 @@ object `X-Forwarded-For` extends HeaderKey.Internal[`X-Forwarded-For`] with Head
   private[http4s] val parser: Parser[`X-Forwarded-For`] =
     Rfc7230
       .headerRep1(
-        (Uri.Ipv4Address.parser.map(_.toInet4Address).backtrack | Uri.Ipv6Address.parser.map(
+        (Uri.Parser.ipv4Address.map(_.toInet4Address).backtrack | Uri.Parser.ipv6Address.map(
           _.toInet6Address)).map(s => Some(s)) | (Parser.string("unknown").as(None)))
       .map(`X-Forwarded-For`.apply)
 }
diff --git a/tests/src/test/scala/org/http4s/parser/UriParserSpec.scala b/tests/src/test/scala/org/http4s/parser/UriParserSpec.scala
index 03b7a570f3c..4f53650cf12 100644
--- a/tests/src/test/scala/org/http4s/parser/UriParserSpec.scala
+++ b/tests/src/test/scala/org/http4s/parser/UriParserSpec.scala
@@ -43,7 +43,7 @@ class UriParserSpec extends Http4sSpec {
       } yield f + "::" + b)
 
       foreach(v) { s =>
-        Ipv6Address.parser.string.parseAll(s) must beRight(s)
+        Uri.Parser.ipv6Address.string.parseAll(s) must beRight(s)
       }
     }
 

From 60dcb8044013be306281d37910ed745654cf1f4c Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 1 Feb 2021 18:38:27 -0500
Subject: [PATCH 20/35] Remove bincompat constructor

---
 .../server/blaze/BlazeServerBuilder.scala     | 43 -------------------
 1 file changed, 43 deletions(-)

diff --git a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
index 0bfd80e3788..3c85b61fed2 100644
--- a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
+++ b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
@@ -115,49 +115,6 @@ class BlazeServerBuilder[F[_]] private (
 
   private[this] val logger = getLogger
 
-  @deprecated("Use `BlazeServerBuilder.apply` and configure with `with` methods", "0.21.17")
-  def this(
-      socketAddress: InetSocketAddress,
-      executionContext: ExecutionContext,
-      responseHeaderTimeout: Duration,
-      idleTimeout: Duration,
-      isNio2: Boolean,
-      connectorPoolSize: Int,
-      bufferSize: Int,
-      selectorThreadFactory: ThreadFactory,
-      enableWebSockets: Boolean,
-      sslConfig: SslConfig[F],
-      isHttp2Enabled: Boolean,
-      maxRequestLineLen: Int,
-      maxHeadersLen: Int,
-      chunkBufferMaxSize: Int,
-      httpApp: HttpApp[F],
-      serviceErrorHandler: ServiceErrorHandler[F],
-      banner: immutable.Seq[String],
-      maxConnections: Int,
-      channelOptions: ChannelOptions
-  )(implicit F: ConcurrentEffect[F], timer: Timer[F]) = this(
-    socketAddress = socketAddress,
-    executionContext = executionContext,
-    idleTimeout = idleTimeout,
-    responseHeaderTimeout = responseHeaderTimeout,
-    nioVersion = if (isNio2) Nio2 else Nio1,
-    connectorPoolSize = connectorPoolSize,
-    bufferSize = bufferSize,
-    selectorThreadFactory = selectorThreadFactory,
-    enableWebSockets = enableWebSockets,
-    sslConfig = sslConfig,
-    isHttp2Enabled = isHttp2Enabled,
-    maxRequestLineLen = maxRequestLineLen,
-    maxHeadersLen = maxHeadersLen,
-    chunkBufferMaxSize = chunkBufferMaxSize,
-    httpApp = httpApp,
-    serviceErrorHandler = serviceErrorHandler,
-    banner = banner,
-    maxConnections = maxConnections,
-    channelOptions = channelOptions
-  )
-
   private def copy(
       socketAddress: InetSocketAddress = socketAddress,
       executionContext: ExecutionContext = executionContext,

From b8d1738d2efe00a1cf95baf5356d08909ec49c4e Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris@christopherdavenport.tech>
Date: Mon, 1 Feb 2021 16:04:08 -0800
Subject: [PATCH 21/35] Minimize Error to Empty Initial Read for a req/resp

---
 build.sbt                                     | 13 +++-
 .../scala/org/http4s/ember/core/Parser.scala  | 72 +++++++++++++------
 .../ember/server/internal/ServerHelpers.scala | 41 +++++------
 3 files changed, 79 insertions(+), 47 deletions(-)

diff --git a/build.sbt b/build.sbt
index 139e5509559..92ed4b5ea49 100644
--- a/build.sbt
+++ b/build.sbt
@@ -241,7 +241,18 @@ lazy val emberCore = libraryProject("ember-core")
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser.httpHeaderAndBody"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Response.parser"),
       ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Util.readWithTimeout"),
-
+      ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.core.Parser#Response#RespPrelude#RespPreludeError.cause"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Response#RespPrelude#RespPreludeError.copy"),
+      ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.core.Parser#Response#RespPrelude#RespPreludeError.copy$default$1"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Response#RespPrelude#RespPreludeError.this"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Request#ReqPrelude#ParsePreludeError.throwable"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Request#ReqPrelude#ParsePreludeError.copy"),
+      ProblemFilters.exclude[IncompatibleResultTypeProblem]("org.http4s.ember.core.Parser#Request#ReqPrelude#ParsePreludeError.copy$default$1"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Request#ReqPrelude#ParsePreludeError.this"),
+      ProblemFilters.exclude[MissingTypesProblem]("org.http4s.ember.core.Parser$Request$ReqPrelude$ParsePreludeError$"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Request#ReqPrelude#ParsePreludeError.apply"),
+      ProblemFilters.exclude[MissingTypesProblem]("org.http4s.ember.core.Parser$Response$RespPrelude$RespPreludeError$"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.ember.core.Parser#Response#RespPrelude#RespPreludeError.apply")
     )
   )
   .dependsOn(core, testing % "test->test")
diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
index 85949d2ede0..8d3f20b3b4b 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
@@ -193,6 +193,8 @@ private[ember] object Parser {
 
     object ReqPrelude {
 
+      val emptyStreamError = ParsePreludeError("Cannot Parse Empty Stream", None, None, None, None)
+
       def parsePrelude[F[_]: MonadThrow](
           s: Stream[F, Byte],
           maxHeaderLength: Int,
@@ -206,26 +208,34 @@ private[ember] object Parser {
             }
             ReqPrelude.preludeInSection(next) match {
               case ParsePreludeComplete(m, u, h, rest) =>
-                Pull.pure((m, u, h, Stream.chunk(Chunk.Bytes(rest)) ++ tl))
-              case t @ ParsePreludeError(_, _, _, _) => Pull.raiseError[F](t)
+                val out = if (rest.isEmpty) tl else Stream.chunk(Chunk.Bytes(rest)) ++ tl
+                Pull.pure((m, u, h, out))
+              case t @ ParsePreludeError(_, _, _, _, _) => Pull.raiseError[F](t)
               case p @ ParsePreludeIncomlete(_, _, method, uri, httpVersion) =>
                 if (next.size <= maxHeaderLength)
                   parsePrelude(tl, maxHeaderLength, p.some)
                 else
                   Pull.raiseError[F](
                     ParsePreludeError(
-                      new Throwable("Reached Max Header Length Looking for Request Prelude"),
+                      "Reached Max Header Length Looking for Request Prelude",
+                      None,
                       method,
                       uri,
                       httpVersion))
             }
           case None =>
-            Pull.raiseError[F](
-              ParsePreludeError(
-                new Throwable("Reached Ended of Stream Looking for Request Prelude"),
-                acc.flatMap(_.method),
-                acc.flatMap(_.uri),
-                acc.flatMap(_.httpVersion)))
+            acc match {
+              case None => Pull.raiseError(emptyStreamError)
+              case Some(incomplete) if incomplete.bv.isEmpty => Pull.raiseError(emptyStreamError)
+              case Some(incomplete) =>
+                Pull.raiseError(
+                  ParsePreludeError(
+                    s"Unexpected EOF - $incomplete",
+                    None,
+                    incomplete.method,
+                    incomplete.uri,
+                    incomplete.httpVersion))
+            }
         }
 
       // sealed trait ParsePreludeState
@@ -237,14 +247,16 @@ private[ember] object Parser {
       private val lf: Byte = '\n'.toByte
 
       sealed trait ParsePreludeResult
-      final case class ParsePreludeError(
-          throwable: Throwable,
+      case class ParsePreludeError(
+          message: String,
+          caused: Option[Throwable],
           method: Option[Method],
           uri: Option[Uri],
           httpVersion: Option[HttpVersion]
-      ) extends Throwable(
+      ) extends Exception(
             s"Parse Prelude Error Encountered - Partially Decoded: $method $uri $httpVersion",
-            throwable)
+            caused.orNull
+          )
           with ParsePreludeResult
       final case class ParsePreludeIncomlete(
           idx: Int,
@@ -323,7 +335,8 @@ private[ember] object Parser {
 
         if (throwable != null)
           ParsePreludeError(
-            throwable,
+            throwable.getMessage(),
+            Option(throwable),
             Option(method),
             Option(uri),
             Option(httpVersion)
@@ -373,6 +386,7 @@ private[ember] object Parser {
   }
 
   object Response {
+
     def parser[F[_]: Concurrent: Timer](maxHeaderLength: Int, timeout: Option[FiniteDuration])(
         s: Stream[F, Byte]
     ): F[(Response[F], Stream[F, Byte])] =
@@ -399,6 +413,7 @@ private[ember] object Parser {
             }
           }
           .stream
+          .take(1)
 
         val action = base.compile.lastOrError
         timeout.fold(action)(duration => Concurrent.timeout(action, duration))
@@ -406,6 +421,8 @@ private[ember] object Parser {
 
     object RespPrelude {
 
+      val emptyStreamError = RespPreludeError("Cannot Parse Empty Stream", None)
+
       def parsePrelude[F[_]: MonadThrow](
           s: Stream[F, Byte],
           maxHeaderLength: Int,
@@ -420,19 +437,28 @@ private[ember] object Parser {
             preludeInSection(next) match {
               case RespPreludeComplete(httpVersion, status, rest) =>
                 Pull.pure((httpVersion, status, Stream.chunk(Chunk.Bytes(rest)) ++ tl))
-              case t @ RespPreludeError(_) => Pull.raiseError[F](t)
+              case t @ RespPreludeError(_, _) => Pull.raiseError[F](t)
               case RespPreludeIncomplete =>
                 if (next.size <= maxHeaderLength)
                   parsePrelude(tl, maxHeaderLength, next.some)
                 else
                   Pull.raiseError[F](
                     RespPreludeError(
-                      new Throwable("Reached Max Header Length Looking for Response Prelude")))
+                      "Reached Max Header Length Looking for Response Prelude",
+                      None))
             }
           case None =>
-            Pull.raiseError[F](
-              RespPreludeError(
-                new Throwable("Reached Ended of Stream Looking for Response Prelude")))
+            acc match {
+              case None => Pull.raiseError(emptyStreamError)
+              case Some(incomplete) if incomplete.isEmpty => Pull.raiseError(emptyStreamError)
+              case Some(_) =>
+                Pull.raiseError[F](
+                  RespPreludeError(
+                    "Unexpectedly Reached Ended of Stream Looking for Response Prelude",
+                    None)
+                )
+            }
+
         }
 
       private val space = ' '.toByte
@@ -443,8 +469,10 @@ private[ember] object Parser {
       case class RespPreludeComplete(httpVersion: HttpVersion, status: Status, rest: Array[Byte])
           extends RespPreludeResult
       case object RespPreludeIncomplete extends RespPreludeResult
-      case class RespPreludeError(cause: Throwable)
-          extends Throwable(s"Received Error while parsing prelude - ${cause.getMessage}", cause)
+      case class RespPreludeError(message: String, cause: Option[Throwable])
+          extends Throwable(
+            s"Received Error while parsing prelude - ${cause.map(_.getMessage)}",
+            cause.orNull)
           with RespPreludeResult
 
       // HTTP/1.1 200 OK
@@ -506,7 +534,7 @@ private[ember] object Parser {
           idx += 1
         }
 
-        if (throwable != null) RespPreludeError(throwable)
+        if (throwable != null) RespPreludeError("Encounterd Error parsing", Option(throwable))
         if (httpVersion != null && status != null)
           RespPreludeComplete(httpVersion, status, bv.drop(idx))
         else RespPreludeIncomplete
diff --git a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
index 4d6285c02fa..b1469468248 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/internal/ServerHelpers.scala
@@ -31,11 +31,7 @@ import org.http4s.headers.{Connection, Date}
 import _root_.org.http4s.ember.core.{Encoder, Parser}
 import _root_.io.chrisdavenport.log4cats.Logger
 import cats.data.NonEmptyList
-import java.util.concurrent.TimeoutException
-import java.nio.channels.InterruptedByTimeoutException
 import _root_.org.http4s.ember.core.Util.durationToFinite
-import java.io.EOFException
-
 private[server] object ServerHelpers {
 
   private val closeCi = "close".ci
@@ -97,15 +93,15 @@ private[server] object ServerHelpers {
     StreamForking.forking(streams, maxConcurrency)
   }
 
-  private[internal] def reachedEndError[F[_]: Sync](
-      socket: Socket[F],
-      idleTimeout: Duration,
-      receiveBufferSize: Int): Stream[F, Byte] =
-    Stream.eval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {
-      case None =>
-        Stream.raiseError(new EOFException("Unexpected EOF - socket.read returned None"))
-      case Some(value) => Stream.chunk(value)
-    }
+  // private[internal] def reachedEndError[F[_]: Sync](
+  //     socket: Socket[F],
+  //     idleTimeout: Duration,
+  //     receiveBufferSize: Int): Stream[F, Byte] =
+  //   Stream.repeatEval(socket.read(receiveBufferSize, durationToFinite(idleTimeout))).flatMap {
+  //     case None =>
+  //       Stream.raiseError(new EOFException("Unexpected EOF - socket.read returned None") with NoStackTrace)
+  //     case Some(value) => Stream.chunk(value)
+  //   }
 
   private[internal] def upgradeSocket[F[_]: Concurrent: ContextShift](
       socketInit: Socket[F],
@@ -177,9 +173,10 @@ private[server] object ServerHelpers {
       httpApp: HttpApp[F],
       errorHandler: Throwable => F[org.http4s.Response[F]],
       onWriteFailure: (Option[Request[F]], Response[F], Throwable) => F[Unit]
-  ): Stream[F, Nothing] =
+  ): Stream[F, Nothing] = {
+    val _ = logger
     Stream
-      .unfoldLoopEval(reachedEndError(socket, idleTimeout, receiveBufferSize))(s =>
+      .unfoldLoopEval(socket.reads(receiveBufferSize, durationToFinite(idleTimeout)))(s =>
         runApp(s, maxHeaderSize, requestHeaderReceiveTimeout, httpApp, errorHandler).attempt.map {
           case Right((req, resp, rest)) => (Right((req, resp)), Some(rest))
           case Left(e) => (Left(e), None)
@@ -194,14 +191,9 @@ private[server] object ServerHelpers {
           send(socket)(Some(request), response, idleTimeout, onWriteFailure)
         case Left(err) =>
           err match {
-            // Timeouts Do Not Get Responses
-            // Thrown by Stream.timeout or Concurrent.timeout
-            case _: TimeoutException =>
-              errorHandler(
-                err).void // Lets users see responses, but cannot generate responses i don't like this
-            // Thrown by fs2.io.tcp.Socket read/write
-            case _: InterruptedByTimeoutException => errorHandler(err).void
-            case e: EOFException => logger.warn(e)("Unexpected EOF Encountered")
+            case req: Parser.Request.ReqPrelude.ParsePreludeError
+                if req == Parser.Request.ReqPrelude.emptyStreamError =>
+              Applicative[F].unit
             case err =>
               errorHandler(err)
                 .handleError(_ => serverFailure.covary[F])
@@ -216,6 +208,7 @@ private[server] object ServerHelpers {
               resp.headers.get(Connection).exists(_.hasClose)
           )
       }
-      .drain
+      .drain ++ Stream.eval_(socket.close)
+  }
 
 }

From 230295c355d1d48f7b080a725241be443176480d Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris@christopherdavenport.tech>
Date: Mon, 1 Feb 2021 16:24:03 -0800
Subject: [PATCH 22/35] Add Log Line for Server Startup

---
 .../main/scala/org/http4s/ember/server/EmberServerBuilder.scala  | 1 +
 1 file changed, 1 insertion(+)

diff --git a/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala b/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
index ee65a6b8e42..29a0287c820 100644
--- a/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
+++ b/ember-server/src/main/scala/org/http4s/ember/server/EmberServerBuilder.scala
@@ -156,6 +156,7 @@ final class EmberServerBuilder[F[_]: Concurrent: Timer: ContextShift] private (
       )
       _ <- Resource.make(Applicative[F].unit)(_ => shutdown.await)
       _ <- Resource.liftF(ready.get.rethrow)
+      _ <- Resource.liftF(logger.info(s"Ember-Server service bound to address: $bindAddress"))
     } yield new Server[F] {
       def address: InetSocketAddress = bindAddress
       def isSecure: Boolean = tlsInfoOpt.isDefined

From 684334e25babee70ebc3660fec60c0553d02b895 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 1 Feb 2021 20:55:32 -0500
Subject: [PATCH 23/35] Drop NIO2 support in blaze-server

---
 .../server/blaze/BlazeServerBuilder.scala     | 32 ++++---------------
 1 file changed, 7 insertions(+), 25 deletions(-)

diff --git a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
index 3c85b61fed2..9fb23e99858 100644
--- a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
+++ b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
@@ -38,7 +38,6 @@ import org.http4s.blaze.channel.{
   SocketConnection
 }
 import org.http4s.blaze.channel.nio1.NIO1SocketServerGroup
-import org.http4s.blaze.channel.nio2.NIO2SocketServerGroup
 import org.http4s.blaze.http.http2.server.ALPNServerSelector
 import org.http4s.blaze.pipeline.LeafBuilder
 import org.http4s.blaze.pipeline.stages.SSLStage
@@ -93,7 +92,6 @@ class BlazeServerBuilder[F[_]] private (
     executionContext: ExecutionContext,
     responseHeaderTimeout: Duration,
     idleTimeout: Duration,
-    nioVersion: NioVersion,
     connectorPoolSize: Int,
     bufferSize: Int,
     selectorThreadFactory: ThreadFactory,
@@ -120,7 +118,6 @@ class BlazeServerBuilder[F[_]] private (
       executionContext: ExecutionContext = executionContext,
       idleTimeout: Duration = idleTimeout,
       responseHeaderTimeout: Duration = responseHeaderTimeout,
-      nioVersion: NioVersion = nioVersion,
       connectorPoolSize: Int = connectorPoolSize,
       bufferSize: Int = bufferSize,
       selectorThreadFactory: ThreadFactory = selectorThreadFactory,
@@ -141,7 +138,6 @@ class BlazeServerBuilder[F[_]] private (
       executionContext,
       responseHeaderTimeout,
       idleTimeout,
-      nioVersion,
       connectorPoolSize,
       bufferSize,
       selectorThreadFactory,
@@ -223,9 +219,6 @@ class BlazeServerBuilder[F[_]] private (
   def withSelectorThreadFactory(selectorThreadFactory: ThreadFactory): Self =
     copy(selectorThreadFactory = selectorThreadFactory)
 
-  @deprecated("NIO2 support in http4s-blaze-server will be removed in 0.22.", "0.21.17")
-  def withNio2(isNio2: Boolean): Self = copy(nioVersion = if (isNio2) Nio2 else Nio1)
-
   def withWebSockets(enableWebsockets: Boolean): Self =
     copy(enableWebSockets = enableWebsockets)
 
@@ -349,19 +342,13 @@ class BlazeServerBuilder[F[_]] private (
         else address
 
       val mkFactory: Resource[F, ServerChannelGroup] = Resource.make(F.delay {
-        nioVersion match {
-          case Nio2 =>
-            NIO2SocketServerGroup
-              .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
-          case Nio1 =>
-            NIO1SocketServerGroup
-              .fixedGroup(
-                connectorPoolSize,
-                bufferSize,
-                channelOptions,
-                selectorThreadFactory,
-                maxConnections = maxConnections)
-        }
+        NIO1SocketServerGroup
+          .fixedGroup(
+            connectorPoolSize,
+            bufferSize,
+            channelOptions,
+            selectorThreadFactory,
+            maxConnections = maxConnections)
       })(factory => F.delay(factory.closeGroup()))
 
       def mkServerChannel(factory: ServerChannelGroup): Resource[F, ServerChannel] =
@@ -424,7 +411,6 @@ object BlazeServerBuilder {
       executionContext = executionContext,
       responseHeaderTimeout = defaults.ResponseTimeout,
       idleTimeout = defaults.IdleTimeout,
-      nioVersion = Nio1,
       connectorPoolSize = DefaultPoolSize,
       bufferSize = 64 * 1024,
       selectorThreadFactory = defaultThreadSelectorFactory,
@@ -539,8 +525,4 @@ object BlazeServerBuilder {
       case SSLClientAuthMode.Requested => engine.setWantClientAuth(true)
       case SSLClientAuthMode.NotRequested => ()
     }
-
-  private sealed trait NioVersion extends Product with Serializable
-  private case object Nio1 extends NioVersion
-  private case object Nio2 extends NioVersion
 }

From 1b34bee649e6e532be0af2c61b51cee4c7d6adfa Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 1 Feb 2021 22:18:10 -0500
Subject: [PATCH 24/35] Drop the nowarn annotation

---
 build.sbt                                     |  1 -
 .../scala-2.12/scala/annotation/nowarn.scala  | 22 -------------------
 2 files changed, 23 deletions(-)
 delete mode 100644 core/src/main/scala-2.12/scala/annotation/nowarn.scala

diff --git a/build.sbt b/build.sbt
index 59ecc751437..fb82d792c4e 100644
--- a/build.sbt
+++ b/build.sbt
@@ -113,7 +113,6 @@ lazy val core = libraryProject("core")
       )
     },
     unusedCompileDependenciesFilter -= moduleFilter("org.scala-lang", "scala-reflect"),
-    Compile / packageBin / mappings ~= { _.filterNot(_._2.startsWith("scala/")) },
   )
 
 lazy val laws = libraryProject("laws")
diff --git a/core/src/main/scala-2.12/scala/annotation/nowarn.scala b/core/src/main/scala-2.12/scala/annotation/nowarn.scala
deleted file mode 100644
index eb5bfbd79f1..00000000000
--- a/core/src/main/scala-2.12/scala/annotation/nowarn.scala
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright 2013 http4s.org
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package scala.annotation
-
-/** Shims Scala 2.13.2's `@nowarn` so it compiles on Scala 2.12.
-  * Silencer has rudimentary support.
-  */
-class nowarn(val value: String = "") extends StaticAnnotation

From d89be4f6ba210d78c5890fa0566f9b84841af2a1 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 1 Feb 2021 22:18:56 -0500
Subject: [PATCH 25/35] Drop the NowarnCompatPlugin

---
 build.sbt | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/build.sbt b/build.sbt
index bf56c730f3c..085fb789d61 100644
--- a/build.sbt
+++ b/build.sbt
@@ -74,7 +74,6 @@ lazy val core = libraryProject("core")
   .enablePlugins(
     BuildInfoPlugin,
     MimeLoaderPlugin,
-    NowarnCompatPlugin,
   )
   .settings(
     description := "Core http4s library for servers and clients",
@@ -149,7 +148,6 @@ lazy val tests = libraryProject("tests")
   .dependsOn(core, testing % "test->test")
 
 lazy val server = libraryProject("server")
-  .enablePlugins(NowarnCompatPlugin)
   .settings(
     description := "Base library for building http4s servers",
     startYear := Some(2014),
@@ -183,7 +181,6 @@ lazy val prometheusMetrics = libraryProject("prometheus-metrics")
   )
 
 lazy val client = libraryProject("client")
-  .enablePlugins(NowarnCompatPlugin)
   .settings(
     description := "Base library for building http4s clients",
     startYear := Some(2014),

From a8eb93a58e8f5b7d0b40d76efae108222a000837 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 1 Feb 2021 21:57:42 -0500
Subject: [PATCH 26/35] Bump sbt-http4s-org and cats-effect-testing

---
 .github/workflows/ci.yml   | 6 +++++-
 project/Http4sPlugin.scala | 2 +-
 project/plugins.sbt        | 2 +-
 3 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index e7b44215135..b17a421607c 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -24,6 +24,7 @@ jobs:
   build:
     name: Build and Test
     strategy:
+      fail-fast: false
       matrix:
         os: [ubuntu-latest]
         scala: [2.12.12, 2.13.3]
@@ -114,7 +115,10 @@ jobs:
 
       - run: git status
 
-      - run: sbt ++${{ matrix.scala }} release
+      - run: sbt ++${{ matrix.scala }} +publish
+
+      - if: startsWith(github.ref, 'refs/tags/v')
+        run: sbt ++${{ matrix.scala }} sonatypeBundleRelease
 
       - name: Setup Hugo
         run: |
diff --git a/project/Http4sPlugin.scala b/project/Http4sPlugin.scala
index 57da4da0b55..105de253f43 100644
--- a/project/Http4sPlugin.scala
+++ b/project/Http4sPlugin.scala
@@ -306,7 +306,7 @@ object Http4sPlugin extends AutoPlugin {
     val boopickle = "1.3.3"
     val cats = "2.3.1"
     val catsEffect = "2.3.1"
-    val catsEffectTesting = "0.5.0"
+    val catsEffectTesting = "0.5.1"
     val circe = "0.13.0"
     val cryptobits = "1.3"
     val disciplineCore = "1.1.3"
diff --git a/project/plugins.sbt b/project/plugins.sbt
index f3e973d2c3f..f7796ac6da5 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -8,7 +8,7 @@ addSbtPlugin("com.earldouglas"            %  "xsbt-web-plugin"           % "4.2.
 addSbtPlugin("com.eed3si9n"               %  "sbt-buildinfo"             % "0.10.0")
 addSbtPlugin("com.eed3si9n"               %  "sbt-unidoc"                % "0.4.3")
 addSbtPlugin("com.github.tkawachi"        %  "sbt-doctest"               % "0.9.9")
-addSbtPlugin("org.http4s"                 %  "sbt-http4s-org"            % "0.7.1")
+addSbtPlugin("org.http4s"                 %  "sbt-http4s-org"            % "0.7.2")
 addSbtPlugin("com.timushev.sbt"           %  "sbt-updates"               % "0.5.1")
 addSbtPlugin("com.typesafe.sbt"           %  "sbt-ghpages"               % "0.6.3")
 addSbtPlugin("com.typesafe.sbt"           %  "sbt-site"                  % "1.4.1")

From c0922b0a65dc09a7651db06805d97e22edefec0a Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 1 Feb 2021 22:55:27 -0500
Subject: [PATCH 27/35] Note #4301

---
 website/src/hugo/content/changelog.md | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/website/src/hugo/content/changelog.md b/website/src/hugo/content/changelog.md
index 6e4b36e419e..af887d45fb2 100644
--- a/website/src/hugo/content/changelog.md
+++ b/website/src/hugo/content/changelog.md
@@ -21,6 +21,12 @@ it.
 * [#4244](https://github.com/http4s/http4s/pull/4244): Internal refactoring of how the stream of server connections is parallelized and terminated.
 * [#4287](https://github.com/http4s/http4s/pull/4287): Replace `onError: Throwable => Response[F]` with `withErrorHandler: PartialFunction[Thrwable, F[Response[F]]`.  Error handling is invoked earlier, allowing custom responses to parsing and timeout failures.
 
+## http4s-ember-client
+
+### Enhancements
+
+* [#4301](https://github.com/http4s/http4s/pull/4301): Add an `idleConnectionTime` to `EmberClientBuilder`. Discard stale connections from the pool and try to acquire a new one.
+
 ## http4s-servlet
 
 ### Bugfixes

From 884c1b5d56b01dbbd95b012558a5cb45c67fa49e Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris@christopherdavenport.tech>
Date: Mon, 1 Feb 2021 19:56:07 -0800
Subject: [PATCH 28/35] Abstract getValidManaged and Only Cycle on Reused

---
 .../ember/client/EmberClientBuilder.scala     | 18 +++------------
 .../ember/client/internal/ClientHelpers.scala | 23 ++++++++++++++++++-
 2 files changed, 25 insertions(+), 16 deletions(-)

diff --git a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
index 7db01f44a1b..15bcc647148 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/EmberClientBuilder.scala
@@ -29,6 +29,7 @@ import fs2.io.tcp.SocketOptionMapping
 import fs2.io.tls._
 import scala.concurrent.duration.Duration
 import org.http4s.headers.{AgentProduct, Connection, `User-Agent`}
+import org.http4s.ember.client.internal.ClientHelpers
 
 final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
     private val blockerOpt: Option[Blocker],
@@ -142,21 +143,8 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
       pool <- builder.build
     } yield {
       val client = Client[F] { request =>
-        def getValidManaged: Resource[F, Managed[F, (RequestKeySocket[F], F[Unit])]] =
-          pool.take(RequestKey.fromRequest(request)).flatMap { managed =>
-            Resource
-              .liftF(managed.value._1.socket.isOpen)
-              .ifM(
-                managed.pure[Resource[F, *]],
-                // Already Closed,
-                // The Resource Scopes Aren't doing us anything
-                // if we have max removed from pool we will need to revisit
-                Resource.liftF(managed.canBeReused.set(Reusable.DontReuse)) >>
-                  getValidManaged
-              )
-          }
         for {
-          managed <- getValidManaged
+          managed <- ClientHelpers.getValidManaged(pool, request)
           _ <- Resource.liftF(
             pool.state.flatMap { poolState =>
               logger.trace(
@@ -166,7 +154,7 @@ final class EmberClientBuilder[F[_]: Concurrent: Timer: ContextShift] private (
           )
           responseResource <- Resource
             .liftF(
-              org.http4s.ember.client.internal.ClientHelpers
+              ClientHelpers
                 .request[F](
                   request,
                   managed.value._1,
diff --git a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
index fc5518219e8..8ead7f66d67 100644
--- a/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
+++ b/ember-client/src/main/scala/org/http4s/ember/client/internal/ClientHelpers.scala
@@ -31,7 +31,7 @@ import org.http4s.client.RequestKey
 import _root_.org.http4s.ember.core.{Encoder, Parser}
 import _root_.fs2.io.tcp.SocketGroup
 import _root_.fs2.io.tls._
-import _root_.io.chrisdavenport.keypool.Reusable
+import _root_.io.chrisdavenport.keypool._
 import javax.net.ssl.SNIHostName
 import org.http4s.headers.{Connection, Date, `User-Agent`}
 import _root_.org.http4s.ember.core.Util.durationToFinite
@@ -156,4 +156,25 @@ private[client] object ClientHelpers {
         val host = auth.host.value
         Sync[F].delay(new InetSocketAddress(host, port))
     }
+
+  // Assumes that the request doesn't have fancy finalizers besides shutting down the pool
+  private[client] def getValidManaged[F[_]: Sync](
+      pool: KeyPool[F, RequestKey, (RequestKeySocket[F], F[Unit])],
+      request: Request[F]): Resource[F, Managed[F, (RequestKeySocket[F], F[Unit])]] =
+    pool.take(RequestKey.fromRequest(request)).flatMap { managed =>
+      Resource
+        .liftF(managed.value._1.socket.isOpen)
+        .ifM(
+          managed.pure[Resource[F, *]],
+          // Already Closed,
+          // The Resource Scopes Aren't doing us anything
+          // if we have max removed from pool we will need to revisit
+          if (managed.isReused) {
+            Resource.liftF(managed.canBeReused.set(Reusable.DontReuse)) >>
+              getValidManaged(pool, request)
+          } else
+            Resource.liftF(Sync[F].raiseError(
+              new java.net.SocketException("Fresh connection from pool was not open")))
+        )
+    }
 }

From c8dbe60da4b447b2b49320fcf0a887f043c816a3 Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris@christopherdavenport.tech>
Date: Mon, 1 Feb 2021 20:00:40 -0800
Subject: [PATCH 29/35] Include Message In getMessage of throwable

---
 ember-core/src/main/scala/org/http4s/ember/core/Parser.scala | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
index 8d3f20b3b4b..512510f3993 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Parser.scala
@@ -254,7 +254,7 @@ private[ember] object Parser {
           uri: Option[Uri],
           httpVersion: Option[HttpVersion]
       ) extends Exception(
-            s"Parse Prelude Error Encountered - Partially Decoded: $method $uri $httpVersion",
+            s"Parse Prelude Error Encountered - Message: $message - Partially Decoded: $method $uri $httpVersion",
             caused.orNull
           )
           with ParsePreludeResult
@@ -471,7 +471,7 @@ private[ember] object Parser {
       case object RespPreludeIncomplete extends RespPreludeResult
       case class RespPreludeError(message: String, cause: Option[Throwable])
           extends Throwable(
-            s"Received Error while parsing prelude - ${cause.map(_.getMessage)}",
+            s"Received Error while parsing prelude - Message: $message - ${cause.map(_.getMessage)}",
             cause.orNull)
           with RespPreludeResult
 

From b25b64bba23f70b18980d8978861f3d676d65357 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Mon, 1 Feb 2021 22:59:59 -0500
Subject: [PATCH 30/35] More 0.22.0-M2 notes

---
 website/src/hugo/content/changelog.md | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/website/src/hugo/content/changelog.md b/website/src/hugo/content/changelog.md
index c8981c41e60..125a4768d38 100644
--- a/website/src/hugo/content/changelog.md
+++ b/website/src/hugo/content/changelog.md
@@ -19,6 +19,7 @@ it.
 ### Breaking changes
 
 * [#4259](https://github.com/http4s/http4s/pull/4259): Regenerate `MimeDb` from the IANA database. This shifts around some constants in a binary incompatible way, but almost nobody will notice.
+* [#4327](https://github.com/http4s/http4s/pull/4237): Shifted the parsers around in `Uri` to prevent deadlocks that appeared since M1.  This should not be visible, but is binary breaking.
 
 ## http4s-prometheus
 
@@ -30,6 +31,7 @@ it.
 
 * jawn-fs2-1.0.1
 * keypool-0.3.0-RC1 (moved to `org.typelevel`)
+* play-json-2.10.0-RC1
 * simpleclient-0.10.0 (Prometheus)
 
 # v0.21.17

From d311a66ceb0425ee9da51af5cccf6a7e35218bfa Mon Sep 17 00:00:00 2001
From: Christopher Davenport <chris@christopherdavenport.tech>
Date: Mon, 1 Feb 2021 21:30:17 -0800
Subject: [PATCH 31/35] Add NoPayloadMethods optimization

---
 .../scala/org/http4s/ember/core/Encoder.scala |  5 ++++-
 .../org/http4s/ember/core/EncoderSuite.scala  | 19 +++----------------
 2 files changed, 7 insertions(+), 17 deletions(-)

diff --git a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
index 2b5aa6e8fc7..eeb060bb3ae 100644
--- a/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
+++ b/ember-core/src/main/scala/org/http4s/ember/core/Encoder.scala
@@ -72,6 +72,9 @@ private[ember] object Encoder {
         .flatMap(Stream.chunk)
   }
 
+  private val NoPayloadMethods: Set[Method] =
+    Set(Method.GET, Method.DELETE, Method.CONNECT, Method.TRACE)
+
   def reqToBytes[F[_]: Sync](req: Request[F], writeBufferSize: Int = 32 * 1024): Stream[F, Byte] = {
     var chunked = req.isChunked
     val initSection = {
@@ -107,7 +110,7 @@ private[ember] object Encoder {
         ()
       }
 
-      if (!chunked && !appliedContentLength) {
+      if (!chunked && !appliedContentLength && !NoPayloadMethods.contains(req.method)) {
         stringBuilder.append(chunkedTansferEncodingHeaderRaw).append(CRLF)
         chunked = true
         ()
diff --git a/ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala b/ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala
index 74f0fc899db..3ee946c71cf 100644
--- a/ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala
+++ b/ember-core/src/test/scala/org/http4s/ember/core/EncoderSuite.scala
@@ -19,6 +19,7 @@ package ember.core
 
 import cats.syntax.all._
 import cats.effect.{IO, Sync}
+import org.http4s.headers.`Content-Length`
 
 class EncoderSuite extends Http4sSuite {
   private object Helpers {
@@ -48,9 +49,6 @@ class EncoderSuite extends Http4sSuite {
     val expected =
       """GET / HTTP/1.1
       |Host: www.google.com
-      |Transfer-Encoding: chunked
-      |
-      |0
       |
       |""".stripMargin
 
@@ -81,9 +79,6 @@ class EncoderSuite extends Http4sSuite {
       """GET / HTTP/1.1
         |Host: www.google.com
         |foo: bar
-        |Transfer-Encoding: chunked
-        |
-        |0
         |
         |""".stripMargin
     Helpers.encodeRequestRig(req).assertEquals(expected)
@@ -97,9 +92,6 @@ class EncoderSuite extends Http4sSuite {
     val expected =
       """GET /path?query HTTP/1.1
         |Host: www.example.com
-        |Transfer-Encoding: chunked
-        |
-        |0
         |
         |""".stripMargin
     Helpers.encodeRequestRig(req).assertEquals(expected)
@@ -114,22 +106,17 @@ class EncoderSuite extends Http4sSuite {
     val expected =
       """GET / HTTP/1.1
         |Host: example.org:8080
-        |Transfer-Encoding: chunked
-        |
-        |0
         |
         |""".stripMargin
     Helpers.encodeRequestRig(req).assertEquals(expected)
   }
 
   test("respToBytes should encode a no body response correctly") {
-    val resp = Response[IO](Status.Ok)
+    val resp = Response[IO](Status.Ok).putHeaders(`Content-Length`.zero)
 
     val expected =
       """HTTP/1.1 200 OK
-      |Transfer-Encoding: chunked
-      |
-      |0
+      |Content-Length: 0
       |
       |""".stripMargin
 

From d8fdb571816b79cfa04008ded7a7b3a914e5d24b Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Tue, 2 Feb 2021 01:24:22 -0500
Subject: [PATCH 32/35] Note #4331

---
 website/src/hugo/content/changelog.md | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/website/src/hugo/content/changelog.md b/website/src/hugo/content/changelog.md
index af887d45fb2..f75d0e1f360 100644
--- a/website/src/hugo/content/changelog.md
+++ b/website/src/hugo/content/changelog.md
@@ -10,6 +10,12 @@ it.
 
 # v0.21.17
 
+## http4s-ember-core
+
+### Enhancements
+
+* [#4331](https://github.com/http4s/http4s/pull/4331): Don't render an empty chunked payload if a request has neither a `Content-Length` or `Transfer-Encoding` and the method is one of `GET`, `DELETE`, `CONNECT`, or `TRACE`. It is undefined behavior for those methods to send payloads.
+
 ## http4s-ember-server
 
 ### Bugfixes

From e3143b40c124adbcbcb61a556a2f1d0fd0a0bb6a Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Tue, 2 Feb 2021 01:34:02 -0500
Subject: [PATCH 33/35] Reference the pending GHSA

---
 website/src/hugo/content/changelog.md | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/website/src/hugo/content/changelog.md b/website/src/hugo/content/changelog.md
index f75d0e1f360..a9ed0b83589 100644
--- a/website/src/hugo/content/changelog.md
+++ b/website/src/hugo/content/changelog.md
@@ -8,7 +8,17 @@ Maintenance branches are merged before each new release. This change log is
 ordered chronologically, so each release contains all changes described below
 it.
 
-# v0.21.17
+# v0.21.17 (2021-02-02)
+
+This release fixes a [High Severity vulnerability](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w) in blaze-server.
+
+## http4s-blaze-server
+
+### Security patches
+
+* [GHSA-xhv5-w9c5-2r2w](https://github.com/http4s/http4s/security/advisories/GHSA-xhv5-w9c5-2r2w): blaze-core, a library underlying http4s-blaze-server, accepts connections without bound.  Each connection claims a file handle, a scarce resource, leading to a denial of service vector.
+
+  `BlazeServerBuilder` now has a `maxConnections` property, limiting the number of concurrent connections.  The cap is not applied to the NIO2 socket server, which is now deprecated. 
 
 ## http4s-ember-core
 
@@ -45,6 +55,7 @@ it.
 
 ## Dependency upgrades
 
+* blaze-0.14.15
 * okhttp-4.9.1
 
 # v0.21.16 (2021-01-24)

From 4a26670f8c4de9125521867b2d9b91ef02fc63e7 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Tue, 2 Feb 2021 01:41:35 -0500
Subject: [PATCH 34/35] Upgrade to blaze-0.14.15

---
 .../org/http4s/server/blaze/BlazeServerBuilder.scala     | 9 +++------
 project/Http4sPlugin.scala                               | 2 +-
 2 files changed, 4 insertions(+), 7 deletions(-)

diff --git a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
index 75a262b9b4a..8014765427b 100644
--- a/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
+++ b/blaze-server/src/main/scala/org/http4s/server/blaze/BlazeServerBuilder.scala
@@ -50,6 +50,7 @@ import org.http4s.server.ServerRequestKeys
 import org.http4s.server.SSLKeyStoreSupport.StoreInfo
 import org.http4s.server.blaze.BlazeServerBuilder._
 import org.log4s.getLogger
+import scala.annotation.nowarn
 import scala.collection.immutable
 import scala.concurrent.{ExecutionContext, Future}
 import scala.concurrent.duration._
@@ -391,6 +392,7 @@ class BlazeServerBuilder[F[_]] private (
         if (address.isUnresolved) new InetSocketAddress(address.getHostName, address.getPort)
         else address
 
+      @nowarn("cat=deprecation")
       val mkFactory: Resource[F, ServerChannelGroup] = Resource.make(F.delay {
         nioVersion match {
           case Nio2 =>
@@ -398,12 +400,7 @@ class BlazeServerBuilder[F[_]] private (
               .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
           case Nio1 =>
             NIO1SocketServerGroup
-              .fixedGroup(
-                connectorPoolSize,
-                bufferSize,
-                channelOptions,
-                selectorThreadFactory,
-                maxConnections = maxConnections)
+              .fixed(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory, maxConnections)
         }
       })(factory => F.delay(factory.closeGroup()))
 
diff --git a/project/Http4sPlugin.scala b/project/Http4sPlugin.scala
index 74e6831170d..c980ee4ebb2 100644
--- a/project/Http4sPlugin.scala
+++ b/project/Http4sPlugin.scala
@@ -300,7 +300,7 @@ object Http4sPlugin extends AutoPlugin {
     // error-prone merge conflicts in the dependencies below.
     val argonaut = "6.2.5"
     val asyncHttpClient = "2.10.5"
-    val blaze = "0.14.15-SNAPSHOT"
+    val blaze = "0.14.15"
     val boopickle = "1.3.3"
     val cats = "2.3.1"
     val catsEffect = "2.3.1"

From 4ac539a2c15755339f81d7c1d61f817602201fc8 Mon Sep 17 00:00:00 2001
From: "Ross A. Baker" <ross@rossabaker.com>
Date: Tue, 2 Feb 2021 01:54:15 -0500
Subject: [PATCH 35/35] Grant MiMa exception to BlazeSeverBuilder private
 constructor

---
 build.sbt | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/build.sbt b/build.sbt
index 100d89fa28f..698b6729c63 100644
--- a/build.sbt
+++ b/build.sbt
@@ -321,6 +321,10 @@ lazy val blazeServer = libraryProject("blaze-server")
   .settings(
     description := "blaze implementation for http4s servers",
     startYear := Some(2014),
+    mimaBinaryIssueFilters ++= Seq(
+      // privat constructor with new parameter
+      ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.server.blaze.BlazeServerBuilder.this")
+    )
   )
   .dependsOn(blazeCore % "compile;test->test", server % "compile;test->test")
 
