From 174c053d1aa1bf5395647e3927d718255f3cbe75 Mon Sep 17 00:00:00 2001
From: Wu Gao <wugao@codeaurora.org>
Date: Tue, 20 Mar 2018 18:45:19 +0800
Subject: qcacld-2.0: Use request manager to handle setting random MAC

Use the new request manager framework for handling set random MAC.

Change-Id: Iea25711c81ae324082eb5a10f4a8bcc9768b60aa
CRs-Fixed: 2207705
---
 CORE/HDD/inc/wlan_hdd_main.h | 14 ---------
 CORE/HDD/src/wlan_hdd_p2p.c  | 74 ++++++++++++++++++++++----------------------
 2 files changed, 37 insertions(+), 51 deletions(-)

diff --git a/CORE/HDD/inc/wlan_hdd_main.h b/CORE/HDD/inc/wlan_hdd_main.h
index c9a3772..0b1344d 100644
--- a/CORE/HDD/inc/wlan_hdd_main.h
+++ b/CORE/HDD/inc/wlan_hdd_main.h
@@ -340,20 +340,6 @@ struct linkspeedContext
    unsigned int magic;
 };
 
-/**
- * struct random_mac_context - Context used with hdd_random_mac_callback
- * @random_mac_completion: Event on which hdd_set_random_mac will wait
- * @adapter: Pointer to adapter
- * @magic: For valid context this is set to ACTION_FRAME_RANDOM_CONTEXT_MAGIC
- * @set_random_addr: Status of random filter set
- */
-struct random_mac_context {
-	struct completion random_mac_completion;
-	hdd_adapter_t *adapter;
-	unsigned int magic;
-	bool set_random_addr;
-};
-
 extern spinlock_t hdd_context_lock;
 
 #define STATS_CONTEXT_MAGIC 0x53544154   //STAT
diff --git a/CORE/HDD/src/wlan_hdd_p2p.c b/CORE/HDD/src/wlan_hdd_p2p.c
index fa5fc03..e851d98 100644
--- a/CORE/HDD/src/wlan_hdd_p2p.c
+++ b/CORE/HDD/src/wlan_hdd_p2p.c
@@ -51,6 +51,7 @@
 #include "vos_types.h"
 #include "vos_trace.h"
 #include "vos_sched.h"
+#include "wlan_hdd_request_manager.h"
 
 //Ms to Micro Sec
 #define MS_TO_MUS(x)   ((x)*1000)
@@ -165,6 +166,10 @@ static bool hdd_p2p_is_action_type_rsp( const u8 *buf, uint32_t len )
     return FALSE;
 }
 
+struct random_mac_priv {
+	bool set_random_addr;
+};
+
 /**
  * hdd_random_mac_callback() - Callback invoked from wmi layer
  * @set_random_addr: Status of random mac filter set operation
@@ -177,32 +182,20 @@ static bool hdd_p2p_is_action_type_rsp( const u8 *buf, uint32_t len )
  */
 static void hdd_random_mac_callback(bool set_random_addr, void *context)
 {
-	struct random_mac_context *rnd_ctx;
-	hdd_adapter_t *adapter;
-
-	if (!context) {
-		hddLog(LOGE, FL("Bad param, pContext"));
-		return;
-	}
-
-	rnd_ctx = context;
-	adapter = rnd_ctx->adapter;
+	struct hdd_request *request;
+	struct random_mac_priv *priv;
 
-	spin_lock(&hdd_context_lock);
-	if ((!adapter) ||
-	    (rnd_ctx->magic != ACTION_FRAME_RANDOM_CONTEXT_MAGIC)) {
-		spin_unlock(&hdd_context_lock);
-		hddLog(VOS_TRACE_LEVEL_WARN,
-		       FL("Invalid context, magic [%08x]"), rnd_ctx->magic);
+	request = hdd_request_get(context);
+	if (!request) {
+		hddLog(LOGE,FL("invalid request"));
 		return;
 	}
 
-	rnd_ctx->magic = 0;
-	if (set_random_addr)
-		rnd_ctx->set_random_addr = true;
+	priv = hdd_request_priv(request);
+	priv->set_random_addr = set_random_addr;
 
-	complete(&rnd_ctx->random_mac_completion);
-	spin_unlock(&hdd_context_lock);
+	hdd_request_complete(request);
+	hdd_request_put(request);
 }
 
 /**
@@ -214,11 +207,17 @@ static void hdd_random_mac_callback(bool set_random_addr, void *context)
  */
 static bool hdd_set_random_mac(hdd_adapter_t *adapter, uint8_t *random_mac_addr)
 {
-	struct random_mac_context context;
 	hdd_context_t *hdd_ctx;
 	eHalStatus sme_status;
 	unsigned long rc;
+	void *cookie;
 	bool status = false;
+	struct hdd_request     *request;
+	struct random_mac_priv *priv;
+	static const struct hdd_request_params params = {
+		.priv_size = sizeof(*priv),
+		.timeout_ms = WLAN_WAIT_TIME_SET_RND,
+	};
 
 	ENTER();
 	hdd_ctx = WLAN_HDD_GET_CTX(adapter);
@@ -227,32 +226,33 @@ static bool hdd_set_random_mac(hdd_adapter_t *adapter, uint8_t *random_mac_addr)
 		return false;
 	}
 
-	init_completion(&context.random_mac_completion);
-	context.adapter = adapter;
-	context.magic = ACTION_FRAME_RANDOM_CONTEXT_MAGIC;
-	context.set_random_addr = false;
+	request = hdd_request_alloc(&params);
+	if (!request) {
+		hddLog(LOGE, FL("Request allocation failure"));
+		return false;
+	}
+
+	cookie = hdd_request_cookie(request);
 
 	sme_status = sme_set_random_mac(hdd_ctx->hHal, hdd_random_mac_callback,
 				     adapter->sessionId, random_mac_addr,
-				     &context);
+				     cookie);
 
 	if (sme_status != eHAL_STATUS_SUCCESS) {
 		hddLog(LOGE,FL("Unable to set random mac"));
 	} else {
-		rc = wait_for_completion_timeout(&context.random_mac_completion,
-                                    msecs_to_jiffies(WLAN_WAIT_TIME_SET_RND));
-		if (!rc) {
-			hddLog(LOGE,
-			FL("SME timed out while setting random mac"));
+		rc = hdd_request_wait_for_response(request);
+		if (rc) {
+			hddLog(LOGE, FL("SME timed out while setting random mac"));
+		} else {
+			priv = hdd_request_priv(request);
+			status = priv->set_random_addr;
 		}
 	}
 
-	spin_lock(&hdd_context_lock);
-	context.magic = 0;
-	status = context.set_random_addr;
-	spin_unlock(&hdd_context_lock);
-
+	hdd_request_put(request);
 	EXIT();
+
 	return status;
 }
 
-- 
cgit v1.1

