From 106f5c62b01b5a212bb53d13e3a3e70db2baedee Mon Sep 17 00:00:00 2001
From: Zhang Qian <zhangq@codeaurora.org>
Date: Tue, 22 May 2018 12:45:55 +0800
Subject: qcacld-2.0: Use HDD request manager for get dcc stats

Change wlan_hdd_cfg80211_dcc_get_stats to HDD request manager framework.

Change-Id: I5cc4cdb3cc3b85988816eb80a93438ed6aff3e3a
CRs-Fixed: 2230971
---
 CORE/HDD/inc/wlan_hdd_main.h |   1 -
 CORE/HDD/src/wlan_hdd_ocb.c  | 157 +++++++++++++++++++++++++------------------
 2 files changed, 92 insertions(+), 66 deletions(-)

diff --git a/CORE/HDD/inc/wlan_hdd_main.h b/CORE/HDD/inc/wlan_hdd_main.h
index da6c779..4af1a46 100644
--- a/CORE/HDD/inc/wlan_hdd_main.h
+++ b/CORE/HDD/inc/wlan_hdd_main.h
@@ -1419,7 +1419,6 @@ struct hdd_adapter_s
     /* State for synchronous OCB requests to WMI */
     struct sir_ocb_set_config_response ocb_set_config_resp;
     struct sir_ocb_get_tsf_timer_response ocb_get_tsf_timer_resp;
-    struct sir_dcc_get_stats_response *dcc_get_stats_resp;
     struct sir_dcc_update_ndl_response dcc_update_ndl_resp;
     struct dsrc_radio_chan_stats_ctxt dsrc_chan_stats;
 #ifdef WLAN_FEATURE_DSRC
diff --git a/CORE/HDD/src/wlan_hdd_ocb.c b/CORE/HDD/src/wlan_hdd_ocb.c
index 8de1fd9..5263660 100644
--- a/CORE/HDD/src/wlan_hdd_ocb.c
+++ b/CORE/HDD/src/wlan_hdd_ocb.c
@@ -40,6 +40,7 @@
 #include "schApi.h"
 #include "wma.h"
 #include "vos_types.h"
+#include "wlan_hdd_request_manager.h"
 
 /* Structure definitions for WLAN_SET_DOT11P_CHANNEL_SCHED */
 #define AIFSN_MIN		(2)
@@ -1693,52 +1694,74 @@ int wlan_hdd_cfg80211_ocb_get_tsf_timer(struct wiphy *wiphy,
 }
 
 /**
- * hdd_dcc_get_stats_callback() - Callback to get stats command
+ * hdd_dcc_stats_priv - DCC stats private parameters
+ * @response: response from SME
+ * @status: status of response
+ */
+struct hdd_dcc_stats_priv {
+	struct sir_dcc_get_stats_response *response;
+	int status;
+};
+
+/**
+ * hdd_dcc_get_stats_dealloc() - Callback when put request
  * @context_ptr: request context
+ *
+ * Return: None
+ */
+static void hdd_dcc_get_stats_dealloc(void *context_ptr)
+{
+	struct hdd_dcc_stats_priv *priv = context_ptr;
+
+	if (priv->response) {
+		vos_mem_free(priv->response);
+		priv->response = NULL;
+	}
+}
+
+/**
+ * hdd_dcc_get_stats_callback() - Callback to get stats command
+ * @context: request context
  * @response_ptr: response data
  */
-static void hdd_dcc_get_stats_callback(void *context_ptr, void *response_ptr)
+static void hdd_dcc_get_stats_callback(void *context, void *response_ptr)
 {
-	struct hdd_ocb_ctxt *context = context_ptr;
+	struct hdd_dcc_stats_priv *priv;
 	struct sir_dcc_get_stats_response *response = response_ptr;
 	struct sir_dcc_get_stats_response *hdd_resp;
+	struct hdd_request *request;
 
-	if (!context)
+	request = hdd_request_get(context);
+	if (!request) {
+		hddLog(VOS_TRACE_LEVEL_ERROR, "%s: Obsolete request", __func__);
 		return;
+	}
 
-	spin_lock(&hdd_context_lock);
-	if (context->magic == HDD_OCB_MAGIC) {
-		if (response) {
-			/*
-			 * If the response is hanging around from the previous
-			 * request, delete it
-			 */
-			if (context->adapter->dcc_get_stats_resp) {
-				vos_mem_free(
-				    context->adapter->dcc_get_stats_resp);
-			}
-			context->adapter->dcc_get_stats_resp =
-				vos_mem_malloc(sizeof(
-				    *context->adapter->dcc_get_stats_resp) +
-				    response->channel_stats_array_len);
-			if (context->adapter->dcc_get_stats_resp) {
-				hdd_resp = context->adapter->dcc_get_stats_resp;
-				*hdd_resp = *response;
-				hdd_resp->channel_stats_array =
-					(void *)hdd_resp + sizeof(*hdd_resp);
-				vos_mem_copy(hdd_resp->channel_stats_array,
-					     response->channel_stats_array,
-					     response->channel_stats_array_len);
-				context->status = 0;
-			} else {
-				context->status = -ENOMEM;
-			}
-		} else {
-			context->status = -EINVAL;
-		}
-		complete(&context->completion_evt);
+	priv = hdd_request_priv(request);
+
+	priv->response = vos_mem_malloc(sizeof(*response) +
+					response->channel_stats_array_len);
+	if (!priv->response) {
+		priv->status = -ENOMEM;
+		goto end;
 	}
-	spin_unlock(&hdd_context_lock);
+
+	if (response) {
+		hdd_resp = priv->response;
+		*hdd_resp = *response;
+		hdd_resp->channel_stats_array = (uint8_t *)hdd_resp +
+						sizeof(*hdd_resp);
+		vos_mem_copy(hdd_resp->channel_stats_array,
+			     response->channel_stats_array,
+			     response->channel_stats_array_len);
+		priv->status = 0;
+	} else {
+		priv->status = -EINVAL;
+	}
+
+end:
+	hdd_request_complete(request);
+	hdd_request_put(request);
 }
 
 /**
@@ -1765,7 +1788,15 @@ static int __wlan_hdd_cfg80211_dcc_get_stats(struct wiphy *wiphy,
 	struct sk_buff *nl_resp = 0;
 	int rc = -EINVAL;
 	struct sir_dcc_get_stats request = {0};
-	struct hdd_ocb_ctxt context = {0};
+	void *cookie;
+	struct hdd_request *hdd_request;
+	struct sir_dcc_get_stats_response *response;
+	struct hdd_dcc_stats_priv *priv;
+	static const struct hdd_request_params params = {
+		.priv_size = sizeof(*priv),
+		.timeout_ms = WLAN_WAIT_TIME_OCB_CMD,
+		.dealloc = hdd_dcc_get_stats_dealloc,
+	};
 
 	ENTER();
 
@@ -1811,9 +1842,14 @@ static int __wlan_hdd_cfg80211_dcc_get_stats(struct wiphy *wiphy,
 		tb[QCA_WLAN_VENDOR_ATTR_DCC_GET_STATS_REQUEST_ARRAY]);
 
 	/* Initialize the callback context */
-	init_completion(&context.completion_evt);
-	context.adapter = adapter;
-	context.magic = HDD_OCB_MAGIC;
+	hdd_request = hdd_request_alloc(&params);
+	if (!hdd_request) {
+		hddLog(LOGE, FL("Request allocation failure"));
+		return -ENOMEM;
+	}
+	priv = hdd_request_priv(hdd_request);
+	priv->response = NULL;
+	cookie = hdd_request_cookie(hdd_request);
 
 	request.vdev_id = adapter->sessionId;
 	request.channel_count = channel_count;
@@ -1821,39 +1857,34 @@ static int __wlan_hdd_cfg80211_dcc_get_stats(struct wiphy *wiphy,
 	request.request_array = request_array;
 
 	/* Call the SME function. */
-	rc = sme_dcc_get_stats(hdd_ctx->hHal, &context,
+	rc = sme_dcc_get_stats(hdd_ctx->hHal, cookie,
 			       hdd_dcc_get_stats_callback,
 			       &request);
 	if (rc) {
 		hddLog(LOGE, FL("Error calling SME function"));
 		/* Need to convert from eHalStatus to errno. */
-		return -EINVAL;
-	}
-
-	/* Wait for the function to complete. */
-	rc = wait_for_completion_timeout(&context.completion_evt,
-				msecs_to_jiffies(WLAN_WAIT_TIME_OCB_CMD));
-	if (rc == 0) {
-		hddLog(LOGE, FL("Operation failed: %d"), rc);
-		rc = -ETIMEDOUT;
+		rc = -EINVAL;
 		goto end;
 	}
 
-	if (context.status) {
-		hddLog(LOGE, FL("There was error: %d"), context.status);
-		rc = context.status;
+	/* Wait for the function to complete. */
+	rc = hdd_request_wait_for_response(hdd_request);
+	if (rc) {
+		hddLog(LOGE, FL("Operation timed out"));
 		goto end;
 	}
 
-	if (!adapter->dcc_get_stats_resp) {
-		hddLog(LOGE, FL("The response was NULL"));
-		rc = -EINVAL;
+	priv = hdd_request_priv(hdd_request);
+	rc = priv->status;
+	if (rc) {
+		hddLog(LOGE, FL("Operation failed: %d"), rc);
 		goto end;
 	}
 
+	response = priv->response;
 	/* Allocate the buffer for the response. */
 	nl_resp = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, sizeof(uint32_t) +
-		adapter->dcc_get_stats_resp->channel_stats_array_len +
+		response->channel_stats_array_len + 2 * NLA_HDRLEN +
 		NLMSG_HDRLEN);
 	if (!nl_resp) {
 		hddLog(LOGE, FL("cfg80211_vendor_cmd_alloc_reply_skb failed"));
@@ -1864,13 +1895,13 @@ static int __wlan_hdd_cfg80211_dcc_get_stats(struct wiphy *wiphy,
 	/* Populate the response. */
 	rc = nla_put_u32(nl_resp,
 			 QCA_WLAN_VENDOR_ATTR_DCC_GET_STATS_RESP_CHANNEL_COUNT,
-			 adapter->dcc_get_stats_resp->num_channels);
+			 response->num_channels);
 	if (rc)
 		goto end;
 	rc = nla_put(nl_resp,
 		     QCA_WLAN_VENDOR_ATTR_DCC_GET_STATS_RESP_STATS_ARRAY,
-		     adapter->dcc_get_stats_resp->channel_stats_array_len,
-		     adapter->dcc_get_stats_resp->channel_stats_array);
+		     response->channel_stats_array_len,
+		     response->channel_stats_array);
 	if (rc)
 		goto end;
 
@@ -1884,11 +1915,7 @@ static int __wlan_hdd_cfg80211_dcc_get_stats(struct wiphy *wiphy,
 
 	/* fall through */
 end:
-	spin_lock(&hdd_context_lock);
-	context.magic = 0;
-	vos_mem_free(adapter->dcc_get_stats_resp);
-	adapter->dcc_get_stats_resp = NULL;
-	spin_unlock(&hdd_context_lock);
+	hdd_request_put(hdd_request);
 	if (nl_resp)
 		kfree_skb(nl_resp);
 	return rc;
-- 
cgit v1.1

