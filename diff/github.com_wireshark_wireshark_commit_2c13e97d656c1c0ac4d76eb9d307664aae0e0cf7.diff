From 2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7 Mon Sep 17 00:00:00 2001
From: Guy Harris <guy@alum.mit.edu>
Date: Sat, 14 May 2016 01:15:56 -0700
Subject: [PATCH] The WTAP_ENCAP_ETHERNET dissector needs to be passed a struct
 eth_phdr.

We now require that.  Make it so.

Bug: 12440
Change-Id: Iffee520976b013800699bde3c6092a3e86be0d76
Reviewed-on: https://code.wireshark.org/review/15424
Reviewed-by: Guy Harris <guy@alum.mit.edu>
---
 epan/dissectors/packet-pktap.c | 19 +++++++++++++++++--
 epan/dissectors/packet-ppi.c   | 19 +++++++++++++++++--
 epan/dissectors/packet-rpcap.c | 15 ++++++++++++++-
 3 files changed, 48 insertions(+), 5 deletions(-)

diff --git a/epan/dissectors/packet-pktap.c b/epan/dissectors/packet-pktap.c
index 6825cdb6298..59a6d4c00f0 100644
--- a/epan/dissectors/packet-pktap.c
+++ b/epan/dissectors/packet-pktap.c
@@ -135,6 +135,9 @@ dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
 	tvbuff_t *next_tvb;
 	int offset = 0;
 	guint32 pkt_len, rectype, dlt;
+	int wtap_encap;
+	struct eth_phdr eth;
+	void *phdr;
 
 	col_set_str(pinfo->cinfo, COL_PROTOCOL, "PKTAP");
 	col_clear(pinfo->cinfo, COL_INFO);
@@ -202,8 +205,20 @@ dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
 
 	if (rectype == PKT_REC_PACKET) {
 		next_tvb = tvb_new_subset_remaining(tvb, pkt_len);
-		dissector_try_uint(wtap_encap_dissector_table,
-		    wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);
+		wtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);
+		switch (wtap_encap) {
+
+		case WTAP_ENCAP_ETHERNET:
+			eth.fcs_len = -1;    /* Unknown whether we have an FCS */
+			phdr = &eth;
+			break;
+
+		default:
+			phdr = NULL;
+			break;
+		}
+		dissector_try_uint_new(wtap_encap_dissector_table,
+		    wtap_encap, next_tvb, pinfo, tree, TRUE, phdr);
 	}
 }
 
diff --git a/epan/dissectors/packet-ppi.c b/epan/dissectors/packet-ppi.c
index 95693ca5e39..c8eb503adff 100644
--- a/epan/dissectors/packet-ppi.c
+++ b/epan/dissectors/packet-ppi.c
@@ -857,6 +857,9 @@ dissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
     guint          last_frame  = 0;
     gint len_remain, /*pad_len = 0,*/ ampdu_len = 0;
     struct ieee_802_11_phdr phdr;
+    int            wtap_encap;
+    struct eth_phdr eth;
+    void          *phdrp;
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, "PPI");
     col_clear(pinfo->cinfo, COL_INFO);
@@ -1137,8 +1140,20 @@ dissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
         call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, tree, &phdr);
     } else {
         /* Everything else.  This will pass a NULL data argument. */
-        dissector_try_uint(wtap_encap_dissector_table,
-            wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);
+        wtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);
+        switch (wtap_encap) {
+
+        case WTAP_ENCAP_ETHERNET:
+            eth.fcs_len = -1;    /* Unknown whether we have an FCS */
+            phdrp = &eth;
+            break;
+
+        default:
+            phdrp = NULL;
+            break;
+        }
+        dissector_try_uint_new(wtap_encap_dissector_table,
+            wtap_encap, next_tvb, pinfo, tree, TRUE, phdrp);
     }
 }
 
diff --git a/epan/dissectors/packet-rpcap.c b/epan/dissectors/packet-rpcap.c
index 46a2e62c8b5..673421a9fd3 100644
--- a/epan/dissectors/packet-rpcap.c
+++ b/epan/dissectors/packet-rpcap.c
@@ -838,6 +838,8 @@ dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,
   tvbuff_t *new_tvb;
   guint caplen, len, frame_no;
   gint reported_length_remaining;
+  struct eth_phdr eth;
+  void *phdr;
 
   ti = proto_tree_add_item (parent_tree, hf_packet, tvb, offset, 20, ENC_NA);
   tree = proto_item_add_subtree (ti, ett_packet);
@@ -874,7 +876,18 @@ dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,
 
   new_tvb = tvb_new_subset (tvb, offset, caplen, len);
   if (decode_content && linktype != WTAP_ENCAP_UNKNOWN) {
-    dissector_try_uint(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree);
+    switch (linktype) {
+
+    case WTAP_ENCAP_ETHERNET:
+      eth.fcs_len = -1;    /* Unknown whether we have an FCS */
+      phdr = &eth;
+      break;
+
+    default:
+      phdr = NULL;
+      break;
+    }
+    dissector_try_uint_new(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree, TRUE, phdr);
 
     if (!info_added) {
       /* Only indicate when not added before */
