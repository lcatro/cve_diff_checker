From c5bd64ea146162967c29bd2af0cbb845ba3eaaaf Mon Sep 17 00:00:00 2001
From: Young_X <YangX92@hotmail.com>
Date: Fri, 23 Nov 2018 14:47:36 +0800
Subject: [PATCH] [MJ2] To avoid divisions by zero / undefined behaviour on
 shift

Signed-off-by: Young_X <YangX92@hotmail.com>
---
 src/lib/openmj2/pi.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/src/lib/openmj2/pi.c b/src/lib/openmj2/pi.c
index d0fdb9b19..ce9c16e40 100644
--- a/src/lib/openmj2/pi.c
+++ b/src/lib/openmj2/pi.c
@@ -224,6 +224,13 @@ static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi)
                     try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;
+
+                    /* To avoid divisions by zero / undefined behaviour on shift */
+                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
+                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
+                        continue;
+                    }
+
                     if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;
@@ -317,6 +324,13 @@ static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)
                     try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;
+
+                    /* To avoid divisions by zero / undefined behaviour on shift */
+                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
+                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
+                        continue;
+                    }
+
                     if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;
@@ -408,6 +422,13 @@ static opj_bool pi_next_cprl(opj_pi_iterator_t * pi)
                     try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
                     rpx = res->pdx + levelno;
                     rpy = res->pdy + levelno;
+
+                    /* To avoid divisions by zero / undefined behaviour on shift */
+                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
+                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
+                        continue;
+                    }
+
                     if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                             ((try0 << levelno) % (1 << rpy))))) {
                         continue;
