From 49c1ce19c8a4689c33e6e8f17ab77d77fae6ff93 Mon Sep 17 00:00:00 2001
From: Arif Hussain <arifhussain@codeaurora.org>
Date: Mon, 25 Sep 2017 18:11:15 -0700
Subject: qcacld-3.0: Fix possible buffer overflow in spectral_create_samp_msg

if bin_pwr_data/sec80 from firmware is greater than the sizeof
bin_pwr/sec80, than copy only sizeof bin_pwr/sec80 data to bin_pwr
to prevent buffer overflow. Add similar validation in other memcpy.

Also replace memcpy with qdf_mem_copy.

Change-Id: Id7dba17c783234d52584e9c365f1ce0b129a91ad
CRs-Fixed: 2115365
---
 core/wma/src/wma_features.c | 75 +++++++++++++++++++++++++++++++--------------
 1 file changed, 52 insertions(+), 23 deletions(-)

diff --git a/core/wma/src/wma_features.c b/core/wma/src/wma_features.c
index e0427e3..fae4a96 100644
--- a/core/wma/src/wma_features.c
+++ b/core/wma/src/wma_features.c
@@ -718,7 +718,7 @@ static QDF_STATUS wma_lphb_conf_tcp_pkt_filter(tp_wma_handle wma_handle,
 	hb_tcp_filter_fp.length = ts_lphb_tcp_filter->length;
 	hb_tcp_filter_fp.offset = ts_lphb_tcp_filter->offset;
 	hb_tcp_filter_fp.session = ts_lphb_tcp_filter->session;
-	memcpy((void *)&hb_tcp_filter_fp.filter,
+	qdf_mem_copy((void *)&hb_tcp_filter_fp.filter,
 	       (void *)&ts_lphb_tcp_filter->filter,
 	       WMI_WLAN_HB_MAX_FILTER_SIZE);
 
@@ -823,7 +823,7 @@ static QDF_STATUS wma_lphb_conf_udp_pkt_filter(tp_wma_handle wma_handle,
 	hb_udp_filter_fp.length = ts_lphb_udp_filter->length;
 	hb_udp_filter_fp.offset = ts_lphb_udp_filter->offset;
 	hb_udp_filter_fp.session = ts_lphb_udp_filter->session;
-	memcpy((void *)&hb_udp_filter_fp.filter,
+	qdf_mem_copy((void *)&hb_udp_filter_fp.filter,
 	       (void *)&ts_lphb_udp_filter->filter,
 	       WMI_WLAN_HB_MAX_FILTER_SIZE);
 
@@ -2487,8 +2487,8 @@ static int process_search_fft_report(struct spectral_phyerr_tlv *ptlv,
 	}
 
 	/* Doing copy as the contents may not be aligned */
-	memcpy(&fft_summary_A, (uint8_t *)phdr, sizeof(int));
-	memcpy(&fft_summary_B, (uint8_t *)((uint8_t *)phdr + sizeof(int)),
+	qdf_mem_copy(&fft_summary_A, (uint8_t *)phdr, sizeof(int));
+	qdf_mem_copy(&fft_summary_B, (uint8_t *)((uint8_t *)phdr + sizeof(int)),
 						sizeof(int));
 
 	relpwr_db       = ((fft_summary_B >> 26) & 0x3f);
@@ -2530,7 +2530,6 @@ static int process_search_fft_report(struct spectral_phyerr_tlv *ptlv,
 static void spectral_create_samp_msg(tp_wma_handle wma,
 			struct samp_msg_params *params)
 {
-	uint64_t temp_samp_msg_len   = 0;
 	static struct spectral_samp_msg spec_samp_msg;
 	struct samp_msg_data  *data        = NULL;
 	uint8_t *bin_pwr_data          = NULL;
@@ -2547,13 +2546,7 @@ static void spectral_create_samp_msg(tp_wma_handle wma,
 		return;
 	}
 
-	temp_samp_msg_len   = sizeof(struct spectral_samp_msg) -
-				(MAX_NUM_BINS * sizeof(uint8_t));
-	temp_samp_msg_len  += (params->pwr_count * sizeof(uint8_t));
 	chan_width = wma->interfaces[wma->ss_configs.vdev_id].chan_width;
-	if (chan_width == CH_WIDTH_160MHZ)
-		temp_samp_msg_len  += (params->pwr_count_sec80 *
-					sizeof(uint8_t));
 	bin_pwr_data        = *(params->bin_pwr_data);
 
 	memset(&spec_samp_msg, 0, sizeof(struct spectral_samp_msg));
@@ -2571,9 +2564,22 @@ static void spectral_create_samp_msg(tp_wma_handle wma,
 	data->spectral_upper_rssi     = params->upper_rssi;
 	data->spectral_lower_rssi     = params->lower_rssi;
 
-	memcpy(data->spectral_chain_ctl_rssi,
+	if (sizeof(params->chain_ctl_rssi) >
+		sizeof(data->spectral_chain_ctl_rssi))
+		qdf_mem_copy(data->spectral_chain_ctl_rssi,
+			params->chain_ctl_rssi,
+			sizeof(data->spectral_chain_ctl_rssi));
+	else
+		qdf_mem_copy(data->spectral_chain_ctl_rssi,
 			params->chain_ctl_rssi, sizeof(params->chain_ctl_rssi));
-	memcpy(data->spectral_chain_ext_rssi,
+
+	if (sizeof(params->chain_ext_rssi) >
+		sizeof(data->spectral_chain_ext_rssi))
+		qdf_mem_copy(data->spectral_chain_ext_rssi,
+			params->chain_ext_rssi,
+			sizeof(data->spectral_chain_ext_rssi));
+	else
+		qdf_mem_copy(data->spectral_chain_ext_rssi,
 			params->chain_ext_rssi, sizeof(params->chain_ext_rssi));
 
 	data->spectral_bwinfo         = params->bwinfo;
@@ -2587,7 +2593,6 @@ static void spectral_create_samp_msg(tp_wma_handle wma,
 	data->spectral_nb_upper           = params->nb_upper;
 	data->spectral_last_tstamp        = params->last_tstamp;
 	data->spectral_max_mag            = params->max_mag;
-	data->bin_pwr_count               = params->pwr_count;
 	data->lb_edge_extrabins           =
 		wma->ss_configs.rpt_mode == 2 ? 4 : 0;
 	data->rb_edge_extrabins           =
@@ -2597,7 +2602,14 @@ static void spectral_create_samp_msg(tp_wma_handle wma,
 
 	data->noise_floor = params->noise_floor;
 
-	memcpy(&data->bin_pwr[0], bin_pwr_data, params->pwr_count);
+	if (params->pwr_count > sizeof(data->bin_pwr)) {
+		data->bin_pwr_count = sizeof(data->bin_pwr);
+		params->pwr_count = sizeof(data->bin_pwr);
+	} else {
+		data->bin_pwr_count = params->pwr_count;
+	}
+
+	qdf_mem_copy(&data->bin_pwr[0], bin_pwr_data, data->bin_pwr_count);
 
 	spec_samp_msg.vhtop_ch_freq_seg1 = params->vhtop_ch_freq_seg1;
 	spec_samp_msg.vhtop_ch_freq_seg2 = params->vhtop_ch_freq_seg2;
@@ -2608,9 +2620,17 @@ static void spectral_create_samp_msg(tp_wma_handle wma,
 		data->spectral_data_len_sec80 = params->datalen_sec80;
 		data->spectral_max_index_sec80 = params->max_index_sec80;
 		data->spectral_max_mag_sec80 = params->max_mag_sec80;
-		data->bin_pwr_count_sec80 = params->pwr_count_sec80;
-		memcpy(&data->bin_pwr_sec80[0],
-			*(params->bin_pwr_data_sec80), params->pwr_count_sec80);
+
+		if (params->pwr_count_sec80 > sizeof(data->bin_pwr_sec80)) {
+			data->bin_pwr_count_sec80 = sizeof(data->bin_pwr_sec80);
+			params->pwr_count_sec80 = sizeof(data->bin_pwr_sec80);
+		} else {
+			data->bin_pwr_count_sec80 = params->pwr_count_sec80;
+		}
+
+		qdf_mem_copy(&data->bin_pwr_sec80[0],
+			*(params->bin_pwr_data_sec80),
+			data->bin_pwr_count_sec80);
 
 		/* Note: REVERSE_ORDER is not a known use case for secondary
 		 * 80 data at this point.
@@ -3103,10 +3123,19 @@ static QDF_STATUS spectral_phyerr_event_handler(void *handle,
 		}
 
 		if (phyerr.buf_len > 0) {
-			memcpy(&rfqual_info, &phyerr.rf_info,
-					sizeof(wmi_host_rf_info_t));
-			memcpy(&chan_info, &phyerr.chan_info,
-					sizeof(wmi_host_chan_info_t));
+			if (sizeof(phyerr.rf_info) > sizeof(rfqual_info))
+				qdf_mem_copy(&rfqual_info, &phyerr.rf_info,
+						sizeof(rfqual_info));
+			else
+				qdf_mem_copy(&rfqual_info, &phyerr.rf_info,
+						sizeof(phyerr.rf_info));
+
+			if (sizeof(phyerr.chan_info) > sizeof(chan_info))
+				qdf_mem_copy(&chan_info, &phyerr.chan_info,
+						sizeof(chan_info));
+			else
+				qdf_mem_copy(&chan_info, &phyerr.chan_info,
+						sizeof(phyerr.chan_info));
 
 			status = spectral_process_phyerr(wma, phyerr.bufp,
 							phyerr.buf_len,
@@ -10674,7 +10703,7 @@ void wma_spectral_scan_config(WMA_HANDLE wma_handle,
 		return;
 
 	/* save the copy of the config params */
-	memcpy(&wma->ss_configs, req, sizeof(*req));
+	qdf_mem_copy(&wma->ss_configs, req, sizeof(*req));
 
 	status = wmi_unified_vdev_spectral_configure_cmd_send(wma->wmi_handle,
 								req);
-- 
cgit v1.1

