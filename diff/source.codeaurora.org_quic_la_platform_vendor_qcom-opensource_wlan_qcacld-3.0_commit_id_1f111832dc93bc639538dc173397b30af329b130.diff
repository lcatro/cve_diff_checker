From 1f111832dc93bc639538dc173397b30af329b130 Mon Sep 17 00:00:00 2001
From: Bala Venkatesh <bjavvaji@codeaurora.org>
Date: Fri, 16 Feb 2018 16:17:44 +0530
Subject: qcacld-3.0: Fix UAF in the function
 wlan_hdd_execute_remain_on_channel

In function wlan_hdd_execute_remain_on_channel after calling
sme_remain_on_channel  Buffer pointed by "pRemainChanCtx" may be freed
in other thread "wlan_hdd_remain_on_channel_callback". UAF will happen
on when accessing "pRemainChanCtx->rem_on_chan_request".

Access pRemainChanCtx only when it is not NULL.

Change-Id: I32696ca9d88bc55f7c9841c7d602f363c35ed49f
CRs-Fixed: 2191365
---
 core/hdd/src/wlan_hdd_p2p.c | 17 ++++++++++-------
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/core/hdd/src/wlan_hdd_p2p.c b/core/hdd/src/wlan_hdd_p2p.c
index ea59f42..bb1ff6c 100644
--- a/core/hdd/src/wlan_hdd_p2p.c
+++ b/core/hdd/src/wlan_hdd_p2p.c
@@ -1165,15 +1165,18 @@ static int wlan_hdd_execute_remain_on_channel(hdd_adapter_t *pAdapter,
 			return -EINVAL;
 		}
 
-		if (REMAIN_ON_CHANNEL_REQUEST ==
-		    pRemainChanCtx->rem_on_chan_request) {
+		mutex_lock(&cfgState->remain_on_chan_ctx_lock);
+		pRemainChanCtx = cfgState->remain_on_chan_ctx;
+		if ((pRemainChanCtx) && (REMAIN_ON_CHANNEL_REQUEST ==
+		    pRemainChanCtx->rem_on_chan_request)) {
+			mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
 			if (QDF_STATUS_SUCCESS != sme_register_mgmt_frame(
-						WLAN_HDD_GET_HAL_CTX(pAdapter),
-						sessionId,
-						(SIR_MAC_MGMT_FRAME << 2) |
-						(SIR_MAC_MGMT_PROBE_REQ << 4),
-						NULL, 0))
+			    WLAN_HDD_GET_HAL_CTX(pAdapter), sessionId,
+			    (SIR_MAC_MGMT_FRAME << 2) |
+			    (SIR_MAC_MGMT_PROBE_REQ << 4), NULL, 0))
 				hdd_err("sme_register_mgmt_frame failed");
+		} else {
+			mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
 		}
 
 	} else if ((QDF_SAP_MODE == pAdapter->device_mode) ||
-- 
cgit v1.1

