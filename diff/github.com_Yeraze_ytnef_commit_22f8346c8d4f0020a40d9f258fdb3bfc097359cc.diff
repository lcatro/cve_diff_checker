From 22f8346c8d4f0020a40d9f258fdb3bfc097359cc Mon Sep 17 00:00:00 2001
From: Randall Hand <randall.hand@gmail.com>
Date: Sat, 25 Feb 2017 07:41:45 -0500
Subject: [PATCH] Added safety check for Compressed RTF Streams

You could potentially overflow the input pointer.

in response to #34
---
 ChangeLog   | 1 +
 lib/ytnef.c | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/ChangeLog b/ChangeLog
index bbe88de..e94c97b 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -3,6 +3,7 @@ v1.9.2 - February 23, 2017
 Thanks to @hannob for finding some Out-of-bound exceptions in memory handline.
 * [SECURITY] An invalid memory access (heap overrun) in handling LONG datatypes
 * [SECURITY] Missing a check for fields of size 0
+* [SECURITY] Potential buffer overrun on incoming Compressed RTF Streams
 
 This version  & the previous 1.9.1 resolves the following CVEs:
 * CVE-2017-6306
diff --git a/lib/ytnef.c b/lib/ytnef.c
index eea43b7..548fcfa 100644
--- a/lib/ytnef.c
+++ b/lib/ytnef.c
@@ -1541,7 +1541,7 @@ BYTE *DecompressRTF(variableLength *p, int *size) {
     ALLOCCHECK_CHAR(dst);
     memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);
     out = comp_Prebuf.size;
-    while (out < (comp_Prebuf.size + uncompressedSize)) {
+    while ((out < (comp_Prebuf.size + uncompressedSize)) && (in < p->size)) {
       // each flag byte flags 8 literals/references, 1 per bit
       flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;
       if ((flags & 1) == 1) { // each flag bit is 1 for reference, 0 for literal
