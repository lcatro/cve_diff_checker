From e4dbb2c8180d6f3b600b93f9090fe1a7f49df027 Mon Sep 17 00:00:00 2001
From: Hanumanth Reddy Pothula <c_hpothu@codeaurora.org>
Date: Thu, 26 Oct 2017 13:58:18 +0530
Subject: qcacld-2.0: Remove FW memory dump feature

FW memory dump feature is no longer used. Hence remove FW memory
dump feature code changes.

Change-Id: Ida655f83630c369df746e7c0c9d61a8fee2932a2
CRs-Fixed: 2120605
---
 CORE/EPPING/src/epping_main.c            |   3 -
 CORE/HDD/inc/wlan_hdd_cfg80211.h         |  10 +-
 CORE/HDD/inc/wlan_hdd_main.h             |  11 -
 CORE/HDD/inc/wlan_hdd_memdump.h          |  92 -----
 CORE/HDD/src/wlan_hdd_cfg80211.c         |  22 +-
 CORE/HDD/src/wlan_hdd_main.c             |  19 -
 CORE/HDD/src/wlan_hdd_memdump.c          | 682 -------------------------------
 CORE/MAC/inc/sirApi.h                    |  55 ---
 CORE/MAC/inc/wniApi.h                    |   1 -
 CORE/MAC/src/include/sirParams.h         |   2 +-
 CORE/SERVICES/WMA/wma.c                  | 201 ---------
 CORE/SME/inc/smeInternal.h               |   3 -
 CORE/SME/inc/sme_Api.h                   |   5 -
 CORE/SME/src/sme_common/sme_Api.c        | 173 --------
 CORE/SYS/legacy/src/utils/src/macTrace.c |   1 -
 CORE/WDA/inc/wlan_qct_wda.h              |   1 -
 Kbuild                                   |  11 -
 Kconfig                                  |   3 -
 18 files changed, 5 insertions(+), 1290 deletions(-)
 delete mode 100644 CORE/HDD/inc/wlan_hdd_memdump.h
 delete mode 100644 CORE/HDD/src/wlan_hdd_memdump.c

diff --git a/CORE/EPPING/src/epping_main.c b/CORE/EPPING/src/epping_main.c
index 593edf0..574cacc 100644
--- a/CORE/EPPING/src/epping_main.c
+++ b/CORE/EPPING/src/epping_main.c
@@ -69,7 +69,6 @@
 #include "if_ath_sdio.h"
 #endif
 #include "epping_main.h"
-#include "wlan_hdd_memdump.h"
 #include "epping_internal.h"
 
 #ifdef TIMER_MANAGER
@@ -215,7 +214,6 @@ void epping_exit(v_CONTEXT_t pVosContext)
             __func__);
          return;
       }
-   memdump_deinit();
    if (pEpping_ctx->epping_adapter) {
       epping_destroy_adapter(pEpping_ctx->epping_adapter);
       pEpping_ctx->epping_adapter = NULL;
@@ -418,7 +416,6 @@ int epping_wlan_startup(struct device *parent_dev, v_VOID_t *hif_sc)
       }
    }
 #endif /* HIF_PCI */
-   memdump_init();
    EPPING_LOG(VOS_TRACE_LEVEL_INFO_HIGH, "%s: Exit", __func__);
    complete(&pEpping_ctx->wlan_start_comp);
    return ret;
diff --git a/CORE/HDD/inc/wlan_hdd_cfg80211.h b/CORE/HDD/inc/wlan_hdd_cfg80211.h
index d5fbb99..67b5941 100644
--- a/CORE/HDD/inc/wlan_hdd_cfg80211.h
+++ b/CORE/HDD/inc/wlan_hdd_cfg80211.h
@@ -218,8 +218,9 @@ enum qca_nl80211_vendor_subcmds {
     QCA_NL80211_VENDOR_SUBCMD_GET_WIFI_INFO = 61,
     /* Start Wifi Logger */
     QCA_NL80211_VENDOR_SUBCMD_WIFI_LOGGER_START = 62,
-    /* Start Wifi Memory Dump */
-    QCA_NL80211_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP = 63,
+
+    /* FW Memory Dump feature is deprecated */
+
     QCA_NL80211_VENDOR_SUBCMD_ROAM = 64,
 
     /*
@@ -322,9 +323,6 @@ enum qca_nl80211_vendor_subcmds_index {
 
     /* OCB events */
     QCA_NL80211_VENDOR_SUBCMD_DCC_STATS_EVENT_INDEX,
-#ifdef WLAN_FEATURE_MEMDUMP
-    QCA_NL80211_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP_INDEX,
-#endif /* WLAN_FEATURE_MEMDUMP */
     QCA_NL80211_VENDOR_SUBCMD_MONITOR_RSSI_INDEX,
 };
 
@@ -1392,7 +1390,6 @@ enum qca_wlan_vendor_features {
 
 /**
  * enum wifi_logger_supported_features - values for supported logger features
- * @WIFI_LOGGER_MEMORY_DUMP_SUPPORTED - Memory dump of FW
  * @WIFI_LOGGER_PER_PACKET_TX_RX_STATUS_SUPPORTED - Per packet statistics
  * @WIFI_LOGGER_CONNECT_EVENT_SUPPORTED - Logging of Connectivity events
  * @WIFI_LOGGER_POWER_EVENT_SUPPORTED - Power of driver
@@ -1400,7 +1397,6 @@ enum qca_wlan_vendor_features {
  * @WIFI_LOGGER_WATCHDOG_TIMER_SUPPORTED - monitor FW health
  */
 enum wifi_logger_supported_features {
-	WIFI_LOGGER_MEMORY_DUMP_SUPPORTED = (1 << (0)),
 	WIFI_LOGGER_PER_PACKET_TX_RX_STATUS_SUPPORTED = (1 << (1)),
 	WIFI_LOGGER_CONNECT_EVENT_SUPPORTED = (1 << (2)),
 	WIFI_LOGGER_POWER_EVENT_SUPPORTED = (1 << (3)),
diff --git a/CORE/HDD/inc/wlan_hdd_main.h b/CORE/HDD/inc/wlan_hdd_main.h
index ca6af6d..20e1833 100644
--- a/CORE/HDD/inc/wlan_hdd_main.h
+++ b/CORE/HDD/inc/wlan_hdd_main.h
@@ -1648,15 +1648,6 @@ struct hdd_context_s
     struct hdd_ll_stats_context ll_stats_context;
 #endif /* End of WLAN_FEATURE_LINK_LAYER_STATS */
 
-#ifdef WLAN_FEATURE_MEMDUMP
-    uint8_t *fw_dump_loc;
-    uint32_t dump_loc_paddr;
-    vos_timer_t memdump_cleanup_timer;
-    struct mutex memdump_lock;
-    bool memdump_in_progress;
-    bool memdump_init_done;
-#endif /* WLAN_FEATURE_MEMDUMP */
-
     /* number of rf chains supported by target */
     uint32_t  num_rf_chains;
 
@@ -1922,8 +1913,6 @@ void hdd_get_fw_version(hdd_context_t *hdd_ctx,
 			uint32_t *major_spid, uint32_t *minor_spid,
 			uint32_t *siid, uint32_t *crmid);
 
-bool hdd_is_memdump_supported(void);
-
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28))
 static inline void
 hdd_set_needed_headroom(struct net_device *wlan_dev, uint16_t len)
diff --git a/CORE/HDD/inc/wlan_hdd_memdump.h b/CORE/HDD/inc/wlan_hdd_memdump.h
deleted file mode 100644
index c56e384..0000000
--- a/CORE/HDD/inc/wlan_hdd_memdump.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (c) 2015 The Linux Foundation. All rights reserved.
- *
- * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
- *
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all
- * copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
- * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
- * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
- * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
- * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
- * PERFORMANCE OF THIS SOFTWARE.
- */
-
-/*
- * This file was originally distributed by Qualcomm Atheros, Inc.
- * under proprietary terms before Copyright ownership was assigned
- * to the Linux Foundation.
- */
-
-/**
- * DOC : wlan_hdd_memdump.h
- *
- * WLAN Host Device Driver file for dumping firmware memory
- *
- */
-
-#if !defined(WLAN_HDD_MEMDUMP_H)
-#define WLAN_HDD_MEMDUMP_H
-
-#include "wlan_hdd_main.h"
-
-#ifdef WLAN_FEATURE_MEMDUMP
-/**
- * enum qca_wlan_vendor_attr_memory_dump - values for memory dump attributes
- * @QCA_WLAN_VENDOR_ATTR_MEMORY_DUMP_INVALID - Invalid
- * @QCA_WLAN_VENDOR_ATTR_REQUEST_ID - Indicate request ID
- * @QCA_WLAN_VENDOR_ATTR_MEMDUMP_SIZE - Indicate size of the memory dump
- * @QCA_WLAN_VENDOR_ATTR_MEMORY_DUMP_AFTER_LAST - To keep track of the last enum
- * @QCA_WLAN_VENDOR_ATTR_MEMORY_DUMP_MAX - max value possible for this type
- *
- * enum values are used for NL attributes for data used by
- * QCA_NL80211_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP sub command.
- */
-enum qca_wlan_vendor_attr_memory_dump {
-	QCA_WLAN_VENDOR_ATTR_MEMORY_DUMP_INVALID = 0,
-	QCA_WLAN_VENDOR_ATTR_REQUEST_ID = 1,
-	QCA_WLAN_VENDOR_ATTR_MEMDUMP_SIZE = 2,
-
-	QCA_WLAN_VENDOR_ATTR_MEMORY_DUMP_AFTER_LAST,
-	QCA_WLAN_VENDOR_ATTR_MEMORY_DUMP_MAX =
-		QCA_WLAN_VENDOR_ATTR_MEMORY_DUMP_AFTER_LAST - 1,
-};
-
-/* Size of fw memory dump is estimated to be 327680 bytes */
-#define FW_MEM_DUMP_SIZE    327680
-#define FW_DRAM_LOCATION    0x00400000
-#define FW_MEM_DUMP_REQ_ID  1
-#define FW_MEM_DUMP_NUM_SEG 1
-#define MEMDUMP_COMPLETION_TIME_MS 800
-
-int memdump_init(void);
-void memdump_deinit(void);
-int wlan_hdd_cfg80211_get_fw_mem_dump(struct wiphy *wiphy,
-				      struct wireless_dev *wdev,
-				      const void *data, int data_len);
-#else
-static inline int memdump_init(void)
-{
-	return -ENOTSUPP;
-}
-
-static inline void memdump_deinit(void)
-{
-}
-
-static inline int wlan_hdd_cfg80211_get_fw_mem_dump(struct wiphy *wiphy,
-					struct wireless_dev *wdev,
-					const void *data, int data_len)
-{
-	return -ENOTSUPP;
-}
-#endif
-
-#endif /* if !defined(WLAN_HDD_MEMDUMP_H)*/
diff --git a/CORE/HDD/src/wlan_hdd_cfg80211.c b/CORE/HDD/src/wlan_hdd_cfg80211.c
index 9716585..a6782d2 100644
--- a/CORE/HDD/src/wlan_hdd_cfg80211.c
+++ b/CORE/HDD/src/wlan_hdd_cfg80211.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2017 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -109,8 +109,6 @@
 #include "wlan_hdd_ocb.h"
 #include "qwlan_version.h"
 
-#include "wlan_hdd_memdump.h"
-
 #include "wlan_logging_sock_svc.h"
 #include "sapApi.h"
 
@@ -1320,12 +1318,6 @@ static const struct nl80211_vendor_cmd_info wlan_hdd_cfg80211_vendor_events[] =
 		.vendor_id = QCA_NL80211_VENDOR_ID,
 		.subcmd = QCA_NL80211_VENDOR_SUBCMD_DCC_STATS_EVENT
 	},
-#ifdef WLAN_FEATURE_MEMDUMP
-    [QCA_NL80211_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP_INDEX] = {
-        .vendor_id = QCA_NL80211_VENDOR_ID,
-        .subcmd = QCA_NL80211_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP
-    },
-#endif /* WLAN_FEATURE_MEMDUMP */
     [QCA_NL80211_VENDOR_SUBCMD_MONITOR_RSSI_INDEX] = {
         .vendor_id = QCA_NL80211_VENDOR_ID,
         .subcmd = QCA_NL80211_VENDOR_SUBCMD_MONITOR_RSSI
@@ -6528,8 +6520,6 @@ __wlan_hdd_cfg80211_get_logger_supp_feature(struct wiphy *wiphy,
 
 	features = 0;
 
-	if (hdd_is_memdump_supported())
-		features |= WIFI_LOGGER_MEMORY_DUMP_SUPPORTED;
 	features |= WIFI_LOGGER_PER_PACKET_TX_RX_STATUS_SUPPORTED;
 	features |= WIFI_LOGGER_CONNECT_EVENT_SUPPORTED;
 	features |= WIFI_LOGGER_WAKE_LOCK_SUPPORTED;
@@ -9985,16 +9975,6 @@ const struct wiphy_vendor_command hdd_wiphy_vendor_commands[] =
         .doit = wlan_hdd_cfg80211_get_logger_supp_feature
     },
 
-#ifdef WLAN_FEATURE_MEMDUMP
-    {
-        .info.vendor_id = QCA_NL80211_VENDOR_ID,
-        .info.subcmd = QCA_NL80211_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP,
-        .flags = WIPHY_VENDOR_CMD_NEED_WDEV |
-                 WIPHY_VENDOR_CMD_NEED_NETDEV |
-                 WIPHY_VENDOR_CMD_NEED_RUNNING,
-        .doit = wlan_hdd_cfg80211_get_fw_mem_dump
-    },
-#endif /* WLAN_FEATURE_MEMDUMP */
 	{
 		.info.vendor_id = QCA_NL80211_VENDOR_ID,
 		.info.subcmd = QCA_NL80211_VENDOR_SUBCMD_WIFI_LOGGER_START,
diff --git a/CORE/HDD/src/wlan_hdd_main.c b/CORE/HDD/src/wlan_hdd_main.c
index c6d2d42..6b7e0c2 100644
--- a/CORE/HDD/src/wlan_hdd_main.c
+++ b/CORE/HDD/src/wlan_hdd_main.c
@@ -119,7 +119,6 @@ extern int hdd_hostapd_stop (struct net_device *dev);
 
 #include "wlan_hdd_debugfs.h"
 #include "epping_main.h"
-#include "wlan_hdd_memdump.h"
 
 #include <wlan_hdd_ipa.h>
 #if defined(HIF_PCI)
@@ -13186,7 +13185,6 @@ void __hdd_wlan_exit(void)
 
    hdd_close_tx_queues(pHddCtx);
    //Do all the cleanup before deregistering the driver
-   memdump_deinit();
    hdd_wlan_exit(pHddCtx);
    EXIT();
 }
@@ -14523,7 +14521,6 @@ int hdd_wlan_startup(struct device *dev, v_VOID_t *hif_sc)
       vos_set_load_unload_in_progress(VOS_MODULE_ID_VOSS, FALSE);
       pHddCtx->isLoadInProgress = FALSE;
 
-      memdump_init();
       hddLog(LOGE, FL("FTM driver loaded"));
       complete(&wlan_start_comp);
       return VOS_STATUS_SUCCESS;
@@ -17279,22 +17276,6 @@ void hdd_get_fw_version(hdd_context_t *hdd_ctx,
 	*crmid = hdd_ctx->target_fw_version & 0x7fff;
 }
 
-/**
- * hdd_is_memdump_supported() - to check if memdump feature support
- *
- * This function is used to check if memdump feature is supported in
- * the host driver
- *
- * Return: true if supported and false otherwise
- */
-bool hdd_is_memdump_supported(void)
-{
-#ifdef WLAN_FEATURE_MEMDUMP
-	return true;
-#endif
-	return false;
-}
-
 #ifdef QCA_CONFIG_SMP
 int wlan_hdd_get_cpu()
 {
diff --git a/CORE/HDD/src/wlan_hdd_memdump.c b/CORE/HDD/src/wlan_hdd_memdump.c
deleted file mode 100644
index 25a4902..0000000
--- a/CORE/HDD/src/wlan_hdd_memdump.c
+++ /dev/null
@@ -1,682 +0,0 @@
-/*
- * Copyright (c) 2015 The Linux Foundation. All rights reserved.
- *
- * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
- *
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all
- * copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
- * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
- * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
- * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
- * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
- * PERFORMANCE OF THIS SOFTWARE.
- */
-
-/*
- * This file was originally distributed by Qualcomm Atheros, Inc.
- * under proprietary terms before Copyright ownership was assigned
- * to the Linux Foundation.
- */
-
-/**
- * DOC : wlan_hdd_memdump.c
- *
- * WLAN Host Device Driver file for dumping firmware memory
- *
- */
-
-#include <sme_Api.h>
-#include <wlan_hdd_includes.h>
-#include "wlan_hdd_memdump.h"
-#include "vos_sched.h"
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/proc_fs.h> /* Necessary because we use the proc fs */
-#include <linux/uaccess.h> /* for copy_to_user */
-
-/**
- * hdd_fw_dump_context - hdd firmware memory dump context
- *
- * @request_id: userspace assigned firmware memory dump request ID
- * @response_event: firmware memory dump request wait event
- */
-struct hdd_fw_dump_context {
-	uint32_t request_id;
-	struct completion response_event;
-};
-static struct hdd_fw_dump_context fw_dump_context;
-
-/**
- * memdump_cleanup_timer_cb() - Timer callback function for memory dump cleanup.
- *
- * @data: Callback data (used to stored HDD context)
- *
- * Callback function registered for memory dump cleanup VOS timer.
- *
- * Return: none
- */
-
-static void memdump_cleanup_timer_cb(void *data)
-{
-	int status;
-	hdd_context_t *hdd_ctx = data;
-	adf_os_dma_addr_t paddr;
-	adf_os_dma_addr_t dma_ctx;
-	adf_os_device_t adf_ctx;
-
-	status = wlan_hdd_validate_context(hdd_ctx);
-	if (0 != status) {
-		hddLog(LOGE, FL("HDD context is not valid"));
-		return;
-	}
-
-	if (!hdd_ctx->fw_dump_loc) {
-		hddLog(LOG1, FL("Memory dump already freed"));
-		return;
-	}
-
-	adf_ctx = vos_get_context(VOS_MODULE_ID_ADF, hdd_ctx->pvosContext);
-	if (!adf_ctx) {
-		hddLog(LOGE, FL("ADF context is NULL"));
-		return;
-	}
-
-	paddr = hdd_ctx->dump_loc_paddr;
-	mutex_lock(&hdd_ctx->memdump_lock);
-	adf_os_mem_free_consistent(adf_ctx,
-		FW_MEM_DUMP_SIZE, hdd_ctx->fw_dump_loc, paddr, dma_ctx);
-	hdd_ctx->fw_dump_loc = NULL;
-	hdd_ctx->memdump_in_progress = false;
-	mutex_unlock(&hdd_ctx->memdump_lock);
-
-}
-
-/**
- * wlan_hdd_cfg80211_fw_mem_dump_cb() -  Callback to receive FW memory dump
- * @ctx: pointer to HDD context.
- * @rsp: pointer to fw dump copy complete response
- *
- * This is a callback function used to indicate user space about the
- * availability for firmware memory dump via vendor event.
- *
- * Return: None
- */
-static void wlan_hdd_cfg80211_fw_mem_dump_cb(void *ctx,
-					     struct fw_dump_rsp *dump_rsp)
-{
-	hdd_context_t *hdd_ctx = ctx;
-	struct hdd_fw_dump_context *context;
-	int status;
-
-	status = wlan_hdd_validate_context(hdd_ctx);
-	if (0 != status) {
-		hddLog(LOGE, FL("HDD context is not valid"));
-		return;
-	}
-
-	spin_lock(&hdd_context_lock);
-	context = &fw_dump_context;
-	/* validate the response received */
-	if (!dump_rsp->dump_complete ||
-	    context->request_id != dump_rsp->request_id) {
-		spin_unlock(&hdd_context_lock);
-		hddLog(LOGE,
-		       FL("Error @ request_id: %d response_id: %d status: %d"),
-		       context->request_id, dump_rsp->request_id,
-		       dump_rsp->dump_complete);
-		return;
-	} else {
-		complete(&context->response_event);
-	}
-	spin_unlock(&hdd_context_lock);
-
-	return;
-}
-
-/**
- * wlan_hdd_send_memdump_rsp - send memory dump response to user space
- * @hdd_ctx: Pointer to hdd context
- *
- * Return: 0 for success; non-zero for failure
- */
-static int wlan_hdd_send_memdump_rsp(hdd_context_t *hdd_ctx)
-{
-	struct sk_buff *skb;
-	int status;
-
-	status = wlan_hdd_validate_context(hdd_ctx);
-	if (0 != status) {
-		hddLog(LOGE, FL("HDD context is not valid"));
-		return status;
-	}
-
-	skb = cfg80211_vendor_cmd_alloc_reply_skb(hdd_ctx->wiphy,
-			NLMSG_HDRLEN + NLA_HDRLEN + sizeof(uint32_t));
-
-	if (!skb) {
-		hddLog(LOGE, FL("cfg80211_vendor_cmd_alloc_reply_skb failed"));
-		return -ENOMEM;
-	}
-
-	if (nla_put_u32(skb, QCA_WLAN_VENDOR_ATTR_MEMDUMP_SIZE,
-			     FW_MEM_DUMP_SIZE)) {
-		hddLog(LOGE, FL("nla put fail"));
-		goto nla_put_failure;
-	}
-
-	cfg80211_vendor_cmd_reply(skb);
-	hddLog(LOG1, FL("Memdump event sent successfully to user space"));
-	return 0;
-
-nla_put_failure:
-	kfree_skb(skb);
-	return -EINVAL;
-}
-
-/**
- * __wlan_hdd_cfg80211_get_fw_mem_dump() - Get FW memory dump
- * @wiphy:   pointer to wireless wiphy structure.
- * @wdev:    pointer to wireless_dev structure.
- * @data:    Pointer to the NL data.
- * @data_len:Length of @data
- *
- * This is called when wlan driver needs to get the firmware memory dump
- * via vendor specific command.
- *
- * Return:   0 on success, error number otherwise.
- */
-static int
-__wlan_hdd_cfg80211_get_fw_mem_dump(struct wiphy *wiphy,
-				    struct wireless_dev *wdev,
-				    const void *data, int data_len)
-{
-	int status;
-	VOS_STATUS sme_status;
-	hdd_context_t *hdd_ctx = wiphy_priv(wiphy);
-	struct fw_dump_req fw_mem_dump_req;
-	struct fw_dump_seg_req* seg_req;
-	uint8_t loop;
-	adf_os_dma_addr_t paddr;
-	adf_os_dma_addr_t dma_ctx;
-	adf_os_device_t adf_ctx;
-	unsigned long rc;
-	struct hdd_fw_dump_context *context;
-
-	if (VOS_FTM_MODE == hdd_get_conparam()) {
-		hddLog(LOGE, FL("Command not allowed in FTM mode"));
-		return -EINVAL;
-	}
-
-	status = wlan_hdd_validate_context(hdd_ctx);
-	if (0 != status) {
-		hddLog(LOGE, FL("HDD context is invalid"));
-		return status;
-	}
-
-	adf_ctx = vos_get_context(VOS_MODULE_ID_ADF, hdd_ctx->pvosContext);
-	if (!adf_ctx) {
-		hddLog(LOGE, FL("ADF context is NULL"));
-		return -EINVAL;
-	}
-
-	if (hdd_ctx->memdump_in_progress) {
-		hddLog(LOGE, FL("Already a memdump req in progress."));
-		return -EBUSY;
-	}
-
-	/*
-	 * Allocate memory for fw memory dump. Memory allocated should be
-	 * contiguous. Physical address of the allocated memory is passed
-	 * to the FW for copy
-	 *
-	 * Reuse the memory if available.
-	 */
-	mutex_lock(&hdd_ctx->memdump_lock);
-	if (!hdd_ctx->fw_dump_loc) {
-		hdd_ctx->fw_dump_loc = adf_os_mem_alloc_consistent(
-			adf_ctx, FW_MEM_DUMP_SIZE, &paddr, dma_ctx);
-		if (!hdd_ctx->fw_dump_loc) {
-			mutex_unlock(&hdd_ctx->memdump_lock);
-			hddLog(LOGE, FL("adf_os_mem_alloc_consistent failed"));
-			return -ENOMEM;
-		}
-		hdd_ctx->dump_loc_paddr = paddr;
-	}
-	mutex_unlock(&hdd_ctx->memdump_lock);
-
-	/*
-	 * Currently request_id and num_seg is assumed to be default(1)
-	 * It is assumed that firmware dump requested is for DRAM section
-	 * only
-	 */
-
-	fw_mem_dump_req.request_id = FW_MEM_DUMP_REQ_ID;
-	fw_mem_dump_req.num_seg = FW_MEM_DUMP_NUM_SEG;
-
-	hddLog(LOG1, FL("request_id:%d num_seg:%d"),
-		fw_mem_dump_req.request_id, fw_mem_dump_req.num_seg);
-	seg_req = (struct fw_dump_seg_req *) fw_mem_dump_req.segment;
-	for (loop = 0; loop < fw_mem_dump_req.num_seg; loop++) {
-		seg_req->seg_id = 1;
-		seg_req->seg_start_addr_lo = FW_DRAM_LOCATION;
-		seg_req->seg_start_addr_hi = 0;
-		seg_req->seg_length = FW_MEM_DUMP_SIZE;
-		seg_req->dst_addr_lo = hdd_ctx->dump_loc_paddr;
-		seg_req->dst_addr_hi = 0;
-		hddLog(LOG1, FL("seg_number:%d"), loop);
-		hddLog(LOG1,
-		    FL("seg_id:%d start_addr_lo:0x%x start_addr_hi:0x%x"),
-		    seg_req->seg_id, seg_req->seg_start_addr_lo,
-		    seg_req->seg_start_addr_hi);
-		hddLog(LOG1,
-		    FL("seg_length:%d dst_addr_lo:0x%x dst_addr_hi:0x%x"),
-		    seg_req->seg_length, seg_req->dst_addr_lo,
-		    seg_req->dst_addr_hi);
-		seg_req++;
-	}
-
-	/**
-	 * Start the cleanup timer.
-	 * Memory allocated for this request will be freed up
-	 * once the timer expires. Memory dump request is expected to be
-	 * completed by this time.
-	 *
-	 * User space will not be able to access the dump after this time.
-	 * New request should be issued to get the dump again.
-	 */
-	vos_timer_start(&hdd_ctx->memdump_cleanup_timer,
-			MEMDUMP_COMPLETION_TIME_MS);
-	hdd_ctx->memdump_in_progress = true;
-
-	spin_lock(&hdd_context_lock);
-	context = &fw_dump_context;
-	context->request_id = fw_mem_dump_req.request_id;
-	INIT_COMPLETION(context->response_event);
-	spin_unlock(&hdd_context_lock);
-
-	sme_status = sme_fw_mem_dump(hdd_ctx->hHal, &fw_mem_dump_req);
-	if (VOS_STATUS_SUCCESS != sme_status) {
-		hddLog(LOGE, FL("sme_fw_mem_dump Failed"));
-		mutex_lock(&hdd_ctx->memdump_lock);
-		adf_os_mem_free_consistent(adf_ctx,
-			FW_MEM_DUMP_SIZE, hdd_ctx->fw_dump_loc, paddr, dma_ctx);
-		hdd_ctx->fw_dump_loc = NULL;
-		mutex_unlock(&hdd_ctx->memdump_lock);
-		hdd_ctx->memdump_in_progress = false;
-		if (VOS_TIMER_STATE_RUNNING ==
-		  vos_timer_getCurrentState(&hdd_ctx->memdump_cleanup_timer)) {
-			vos_timer_stop(&hdd_ctx->memdump_cleanup_timer);
-		}
-		return -EINVAL;
-	}
-
-	rc = wait_for_completion_timeout(&context->response_event,
-		msecs_to_jiffies(MEMDUMP_COMPLETION_TIME_MS));
-	if (!rc) {
-		hddLog(LOGE, FL("Target response timed out for request_id: %d"),
-		       context->request_id);
-		return -ETIMEDOUT;
-	}
-
-	status = wlan_hdd_send_memdump_rsp(hdd_ctx);
-	if (status)
-		hddLog(LOGE,
-			FL("Failed to send FW memory dump rsp to user space"));
-
-	return status;
-}
-
-/**
- * wlan_hdd_cfg80211_get_fw_mem_dump() - Get FW memory dump
- * @wiphy:   pointer to wireless wiphy structure.
- * @wdev:    pointer to wireless_dev structure.
- * @data:    Pointer to the NL data.
- * @data_len:Length of @data
- *
- * This is called when wlan driver needs to get the firmware memory dump
- * via vendor specific command.
- *
- * Return:   0 on success, error number otherwise.
- */
-int wlan_hdd_cfg80211_get_fw_mem_dump(struct wiphy *wiphy,
-					     struct wireless_dev *wdev,
-					     const void *data, int data_len)
-{
-	int ret;
-
-	vos_ssr_protect(__func__);
-	ret = __wlan_hdd_cfg80211_get_fw_mem_dump(wiphy, wdev, data, data_len);
-	vos_ssr_unprotect(__func__);
-
-	return ret;
-}
-
-#define PROCFS_MEMDUMP_DIR "debug"
-#define PROCFS_MEMDUMP_NAME "fwdump"
-#define PROCFS_MEMDUMP_PERM 0444
-
-static struct proc_dir_entry *proc_file, *proc_dir;
-
-/** memdump_get_file_data() - get data available in proc file
- *
- * @file - handle for the proc file.
- *
- * This function is used to retrieve the data passed while
- * creating proc file entry.
- *
- * Return: void pointer to hdd_context
- */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)) || defined(WITH_BACKPORTS)
-static void *memdump_get_file_data(struct file *file)
-{
-	void *hdd_ctx;
-
-	hdd_ctx = PDE_DATA(file_inode(file));
-	return hdd_ctx;
-}
-#else
-static void *memdump_get_file_data(struct file *file)
-{
-	void *hdd_ctx;
-
-	hdd_ctx = PDE(file->f_path.dentry->d_inode)->data;
-	return hdd_ctx;
-}
-#endif
-
-/**
- * memdump_read() - perform read operation in memory dump proc file
- *
- * @file  - handle for the proc file.
- * @buf   - pointer to user space buffer.
- * @count - number of bytes to be read.
- * @pos   - offset in the from buffer.
- *
- * This function performs read operation for the memory dump proc file.
- *
- * Return: number of bytes read on success, error code otherwise.
- */
-static ssize_t memdump_read(struct file *file, char __user *buf,
-					size_t count, loff_t *pos)
-{
-	int status;
-	hdd_context_t *hdd_ctx;
-	adf_os_dma_addr_t paddr;
-	adf_os_dma_addr_t dma_ctx;
-	adf_os_device_t adf_ctx;
-
-	hdd_ctx = memdump_get_file_data(file);
-
-	hddLog(LOG1, FL("Read req for size:%zu pos:%llu"), count, *pos);
-	status = wlan_hdd_validate_context(hdd_ctx);
-	if (0 != status) {
-		hddLog(LOGE, FL("HDD context is not valid"));
-		return -EINVAL;
-	}
-	adf_ctx = vos_get_context(VOS_MODULE_ID_ADF, hdd_ctx->pvosContext);
-	if (!adf_ctx) {
-		hddLog(LOGE, FL("ADF context is NULL"));
-		return -EINVAL;
-	}
-	mutex_lock(&hdd_ctx->memdump_lock);
-	if (!hdd_ctx->memdump_in_progress) {
-		hddLog(LOGE, FL("Current mem dump request timed out/failed"));
-		status = -EINVAL;
-		goto memdump_read_fail;
-	}
-
-	if (*pos < 0) {
-		hddLog(LOGE, FL("Invalid start offset for memdump read"));
-		status = -EINVAL;
-		goto memdump_read_fail;
-	} else if (*pos >= FW_MEM_DUMP_SIZE || !count) {
-		hddLog(LOGE, FL("No more data to copy"));
-		status = 0;
-		goto memdump_read_fail;
-	} else if (count > FW_MEM_DUMP_SIZE - *pos) {
-		count = FW_MEM_DUMP_SIZE - *pos;
-	}
-
-	if (!hdd_ctx->fw_dump_loc) {
-		hddLog(LOGE, FL("Invalid fw mem dump location"));
-		status = -EINVAL;
-		goto memdump_read_fail;
-	}
-
-	if (copy_to_user(buf, hdd_ctx->fw_dump_loc + *pos, count)) {
-		hddLog(LOGE, FL("copy to user space failed"));
-		status = -EFAULT;
-		goto memdump_read_fail;
-	}
-
-	/* offset(pos) should be updated here based on the copy done*/
-	*pos += count;
-
-	/* Entire FW memory dump copy completed */
-	if (*pos >= FW_MEM_DUMP_SIZE) {
-		paddr = hdd_ctx->dump_loc_paddr;
-		adf_os_mem_free_consistent(adf_ctx,
-			FW_MEM_DUMP_SIZE, hdd_ctx->fw_dump_loc, paddr, dma_ctx);
-		hdd_ctx->fw_dump_loc = NULL;
-		hdd_ctx->memdump_in_progress = false;
-		if (VOS_TIMER_STATE_RUNNING ==
-		  vos_timer_getCurrentState(&hdd_ctx->memdump_cleanup_timer)) {
-			vos_timer_stop(&hdd_ctx->memdump_cleanup_timer);
-		}
-	}
-	status = count;
-memdump_read_fail:
-	mutex_unlock(&hdd_ctx->memdump_lock);
-	return status;
-}
-
-/**
- * struct memdump_fops - file operations for memory dump feature
- * @read - read function for memory dump operation.
- *
- * This structure initialize the file operation handle for memory
- * dump feature
- */
-static const struct file_operations memdump_fops = {
-	read: memdump_read
-};
-
-/**
- * memdump_procfs_init() - Initialize procfs for memory dump
- *
- * @vos_ctx - Global vos context.
- *
- * This function create file under proc file system to be used later for
- * processing firmware memory dump
- *
- * Return:   0 on success, error code otherwise.
- */
-static int memdump_procfs_init(void *vos_ctx)
-{
-	hdd_context_t *hdd_ctx;
-
-	hdd_ctx = vos_get_context(VOS_MODULE_ID_HDD, vos_ctx);
-	if (!hdd_ctx) {
-		hddLog(LOGE , FL("Invalid HDD context"));
-		return -EINVAL;
-	}
-
-	proc_dir = proc_mkdir(PROCFS_MEMDUMP_DIR, NULL);
-	if (proc_dir == NULL) {
-		remove_proc_entry(PROCFS_MEMDUMP_DIR, NULL);
-		pr_debug("Error: Could not initialize /proc/%s\n",
-			 PROCFS_MEMDUMP_DIR);
-		return -ENOMEM;
-	}
-
-	proc_file = proc_create_data(PROCFS_MEMDUMP_NAME,
-				     PROCFS_MEMDUMP_PERM, proc_dir,
-				     &memdump_fops, hdd_ctx);
-	if (proc_file == NULL) {
-		remove_proc_entry(PROCFS_MEMDUMP_NAME, proc_dir);
-		pr_debug("Error: Could not initialize /proc/%s\n",
-			  PROCFS_MEMDUMP_NAME);
-		return -ENOMEM;
-	}
-
-	pr_debug("/proc/%s/%s created\n", PROCFS_MEMDUMP_DIR,
-		 PROCFS_MEMDUMP_NAME);
-	return 0;
-}
-
-/**
- * memdump_procfs_remove() - Remove file/dir under procfs for memory dump
- *
- * This function removes file/dir under proc file system that was
- * processing firmware memory dump
- *
- * Return:  None
- */
-static void memdump_procfs_remove(void)
-{
-	remove_proc_entry(PROCFS_MEMDUMP_NAME, proc_dir);
-	pr_debug("/proc/%s/%s removed\n", PROCFS_MEMDUMP_DIR,
-					  PROCFS_MEMDUMP_NAME);
-	remove_proc_entry(PROCFS_MEMDUMP_DIR, NULL);
-	pr_debug("/proc/%s removed\n", PROCFS_MEMDUMP_DIR);
-}
-
-/**
- * memdump_init() - Intialization function for memory dump feature
- *
- * This function creates proc file for memdump feature and registers
- * HDD callback function with SME.
- *
- * Return - 0 on success, error otherwise
- */
-int memdump_init(void)
-{
-	hdd_context_t *hdd_ctx;
-	void *vos_ctx;
-	int status = 0;
-	eHalStatus cb_status;
-	VOS_STATUS vos_status;
-
-	vos_ctx = vos_get_global_context(VOS_MODULE_ID_SYS, NULL);
-	if (!vos_ctx) {
-		hddLog(LOGE, FL("Invalid VOS context"));
-		return -EINVAL;
-	}
-
-	hdd_ctx = vos_get_context(VOS_MODULE_ID_HDD, vos_ctx);
-	if (!hdd_ctx) {
-		hddLog(LOGE , FL("Invalid HDD context"));
-		return -EINVAL;
-	}
-
-	if (VOS_FTM_MODE == hdd_get_conparam()) {
-		hddLog(LOGE, FL("Not initializing memdump in FTM mode"));
-		return -EINVAL;
-	}
-
-	cb_status = sme_fw_mem_dump_register_cb(hdd_ctx->hHal,
-				wlan_hdd_cfg80211_fw_mem_dump_cb);
-	if (eHAL_STATUS_SUCCESS != cb_status) {
-		hddLog(LOGE , FL("Failed to register the callback"));
-		return -EINVAL;
-	}
-
-	status = memdump_procfs_init(vos_ctx);
-	if (status) {
-		hddLog(LOGE , FL("Failed to create proc file"));
-		return status;
-	}
-
-	init_completion(&fw_dump_context.response_event);
-
-	vos_status = vos_timer_init(&hdd_ctx->memdump_cleanup_timer,
-				    VOS_TIMER_TYPE_SW, memdump_cleanup_timer_cb,
-				    (void *)hdd_ctx);
-	if (!VOS_IS_STATUS_SUCCESS(vos_status)) {
-		hddLog(LOGE, FL("Failed to init memdump cleanup timer"));
-		return -EINVAL;
-	}
-
-	mutex_init(&hdd_ctx->memdump_lock);
-	hdd_ctx->memdump_init_done = true;
-
-	return 0;
-}
-
-/**
- * memdump_deinit() - De initialize memdump feature
- *
- * This function removes proc file created for memdump feature.
- *
- * Return: None
- */
-void memdump_deinit(void) {
-	hdd_context_t *hdd_ctx;
-	void *vos_ctx;
-	adf_os_dma_addr_t paddr;
-	adf_os_dma_addr_t dma_ctx;
-	adf_os_device_t adf_ctx;
-	VOS_STATUS vos_status;
-
-	vos_ctx = vos_get_global_context(VOS_MODULE_ID_SYS, NULL);
-	if (!vos_ctx) {
-		hddLog(LOGE, FL("Invalid VOS context"));
-		return;
-	}
-
-	hdd_ctx = vos_get_context(VOS_MODULE_ID_HDD, vos_ctx);
-	if(!hdd_ctx) {
-		hddLog(LOGE , FL("Invalid HDD context"));
-		return;
-	}
-
-	if (VOS_FTM_MODE == hdd_get_conparam()) {
-		hddLog(LOGE, FL("Not deinitializing memdump in FTM mode"));
-		return;
-	}
-
-	if (!hdd_ctx->memdump_init_done) {
-		hddLog(LOGE, FL("MemDump not initialized"));
-		return;
-	}
-
-	hdd_ctx->memdump_init_done = false;
-	adf_ctx = vos_get_context(VOS_MODULE_ID_ADF, hdd_ctx->pvosContext);
-	if (!adf_ctx) {
-		hddLog(LOGE, FL("ADF context is NULL"));
-		return;
-	}
-
-	memdump_procfs_remove();
-	sme_fw_mem_dump_unregister_cb(hdd_ctx->hHal);
-
-	mutex_lock(&hdd_ctx->memdump_lock);
-	if (hdd_ctx->fw_dump_loc) {
-		paddr = hdd_ctx->dump_loc_paddr;
-		adf_os_mem_free_consistent(adf_ctx,
-			FW_MEM_DUMP_SIZE, hdd_ctx->fw_dump_loc, paddr, dma_ctx);
-		hdd_ctx->fw_dump_loc = NULL;
-		hdd_ctx->memdump_in_progress = false;
-	}
-
-	mutex_unlock(&hdd_ctx->memdump_lock);
-	mutex_destroy(&hdd_ctx->memdump_lock);
-
-	if (VOS_TIMER_STATE_RUNNING ==
-	  vos_timer_getCurrentState(&hdd_ctx->memdump_cleanup_timer)) {
-		vos_timer_stop(&hdd_ctx->memdump_cleanup_timer);
-	}
-
-	vos_status = vos_timer_destroy(&hdd_ctx->memdump_cleanup_timer);
-	if (!VOS_IS_STATUS_SUCCESS(vos_status)) {
-		hddLog(LOGE, FL("Failed to deallocate timer"));
-	}
-}
diff --git a/CORE/MAC/inc/sirApi.h b/CORE/MAC/inc/sirApi.h
index 3a3c77b..6e7aef0 100644
--- a/CORE/MAC/inc/sirApi.h
+++ b/CORE/MAC/inc/sirApi.h
@@ -6361,61 +6361,6 @@ struct sir_guard_time_request {
 /* Max number of rates allowed in Supported Rates IE */
 #define MAX_NUM_SUPPORTED_RATES (8)
 
-#define MAX_NUM_FW_SEGMENTS 4
-
-/**
- * struct fw_dump_seg_req - individual segment details
- * @seg_id - segment id.
- * @seg_start_addr_lo - lower address of the segment.
- * @seg_start_addr_hi - higher address of the segment.
- * @seg_length - length of the segment.
- * @dst_addr_lo - lower address of the destination buffer.
- * @dst_addr_hi - higher address of the destination buffer.
- *
- * This structure carries the information to firmware about the
- * individual segments. This structure is part of firmware memory
- * dump request.
- */
-struct fw_dump_seg_req
-{
-	uint8_t seg_id;
-	uint32_t seg_start_addr_lo;
-	uint32_t seg_start_addr_hi;
-	uint32_t seg_length;
-	uint32_t dst_addr_lo;
-	uint32_t dst_addr_hi;
-};
-
-/**
- * struct fw_dump_req - firmware memory dump request details.
- * @request_id - request id.
- * @num_seg - requested number of segments.
- * @fw_dump_seg_req - individual segment information.
- *
- * This structure carries information about the firmware
- * memory dump request.
- */
-struct fw_dump_req
-{
-	uint32_t request_id;
-	uint32_t num_seg;
-	struct fw_dump_seg_req segment[MAX_NUM_FW_SEGMENTS];
-};
-
-/**
- * struct fw_dump_rsp - firmware dump response details.
- * @request_id - request id.
- * @dump_complete - copy completion status.
- *
- * This structure is used to store the firmware dump copy complete
- * response from the firmware.
- */
-struct fw_dump_rsp
-{
-	uint32_t request_id;
-	uint32_t dump_complete;
-};
-
 /**
  * struct vdev_ie_info - IE info
  * @vdev_i - vdev for which the IE is being sent
diff --git a/CORE/MAC/inc/wniApi.h b/CORE/MAC/inc/wniApi.h
index 0635735..5dcfe9c 100644
--- a/CORE/MAC/inc/wniApi.h
+++ b/CORE/MAC/inc/wniApi.h
@@ -392,7 +392,6 @@ enum eWniMsgTypes
     eWNI_SME_DCC_STATS_EVENT,
 
     eWNI_SME_TSF_EVENT,
-    eWNI_SME_FW_DUMP_IND,
     eWNI_SME_PDEV_SET_HT_VHT_IE,
     eWNI_SME_EXT_CHANGE_CHANNEL,
     eWNI_SME_EXT_CHANGE_CHANNEL_IND,
diff --git a/CORE/MAC/src/include/sirParams.h b/CORE/MAC/src/include/sirParams.h
index c70198a..4db9a69 100644
--- a/CORE/MAC/src/include/sirParams.h
+++ b/CORE/MAC/src/include/sirParams.h
@@ -731,7 +731,7 @@ typedef struct sSirMbMsgP2p
 #define SIR_HAL_DCC_GET_STATS_CMD           (SIR_HAL_ITC_MSG_TYPES_BEGIN + 324)
 #define SIR_HAL_DCC_CLEAR_STATS_CMD         (SIR_HAL_ITC_MSG_TYPES_BEGIN + 325)
 #define SIR_HAL_DCC_UPDATE_NDL_CMD          (SIR_HAL_ITC_MSG_TYPES_BEGIN + 326)
-#define SIR_HAL_FW_MEM_DUMP_REQ            (SIR_HAL_ITC_MSG_TYPES_BEGIN + 327)
+/* FW Memory Dump feature is deprecated */
 #define SIR_HAL_START_STOP_LOGGING          (SIR_HAL_ITC_MSG_TYPES_BEGIN + 328)
 #define SIR_HAL_EXTSCAN_STATUS_IND          (SIR_HAL_ITC_MSG_TYPES_BEGIN + 329)
 
diff --git a/CORE/SERVICES/WMA/wma.c b/CORE/SERVICES/WMA/wma.c
index 15322bd..bd85bb9 100644
--- a/CORE/SERVICES/WMA/wma.c
+++ b/CORE/SERVICES/WMA/wma.c
@@ -2678,49 +2678,6 @@ static void wma_post_link_status(tAniGetLinkStatus *pGetLinkStatus,
 	}
 }
 
-#ifdef WLAN_FEATURE_MEMDUMP
-/**
- * wma_fw_mem_dump_rsp() - send fw mem dump response to SME
- *
- * @req_id - request id.
- * @status - copy status from the firmware.
- *
- * This function is called by the memory dump response handler to
- * indicate SME that firmware dump copy is complete
- */
-static VOS_STATUS wma_fw_mem_dump_rsp(uint32_t req_id, uint32_t status)
-{
-	struct fw_dump_rsp *dump_rsp;
-	vos_msg_t sme_msg = {0} ;
-	VOS_STATUS vos_status = VOS_STATUS_SUCCESS;
-
-	dump_rsp = vos_mem_malloc(sizeof(*dump_rsp));
-
-	if (!dump_rsp) {
-		WMA_LOGE(FL("Memory allocation failed."));
-		vos_status = VOS_STATUS_E_NOMEM;
-		return vos_status;
-	}
-
-	WMA_LOGI(FL("FW memory dump copy complete status: %d for request: %d"),
-		 status, req_id);
-
-	dump_rsp->request_id = req_id;
-	dump_rsp->dump_complete = status;
-
-	sme_msg.type = eWNI_SME_FW_DUMP_IND;
-	sme_msg.bodyptr = dump_rsp;
-	sme_msg.bodyval = 0;
-
-	vos_status = vos_mq_post_message(VOS_MODULE_ID_SME, &sme_msg);
-	if (!VOS_IS_STATUS_SUCCESS(vos_status)) {
-		WMA_LOGE(FL("Fail to post fw mem dump ind msg"));
-		vos_mem_free(dump_rsp);
-	}
-
-	return vos_status;
-}
-#endif /* WLAN_FEATURE_MEMDUMP */
 
 static int wma_link_status_rsp(tp_wma_handle wma, u_int8_t *buf)
 {
@@ -4587,48 +4544,6 @@ static int wma_unified_link_radio_stats_event_handler(void *handle,
 
 #endif /* WLAN_FEATURE_LINK_LAYER_STATS */
 
-/**
- * wma_fw_mem_dump_event_handler() - handles fw memory dump event
- *
- * handle - pointer to wma handle.
- * cmd_param_info - pointer to TLV info received in the event.
- * len - length of data in @cmd_param_info
- *
- * This function is a handler for firmware memory dump event.
- */
-#ifdef WLAN_FEATURE_MEMDUMP
-static int wma_fw_mem_dump_event_handler(void *handle, u_int8_t *cmd_param_info,
-					 u_int32_t len)
-{
-	WMI_UPDATE_FW_MEM_DUMP_EVENTID_param_tlvs *param_buf;
-	wmi_update_fw_mem_dump_fixed_param *event;
-	VOS_STATUS status;
-
-	param_buf =
-	    (WMI_UPDATE_FW_MEM_DUMP_EVENTID_param_tlvs *) cmd_param_info;
-	if (!param_buf) {
-		WMA_LOGA("%s: Invalid stats event", __func__);
-		return -EINVAL;
-	}
-
-	event = param_buf->fixed_param;
-
-	status = wma_fw_mem_dump_rsp(event->request_id,
-					 event->fw_mem_dump_complete);
-	if (VOS_STATUS_SUCCESS != status) {
-		return -EINVAL;
-	}
-
-	WMA_LOGI("FW MEM DUMP RSP posted successfully");
-	return 0;
-}
-#else
-static int wma_fw_mem_dump_event_handler(void *handle, u_int8_t *cmd_param_info,
-					 u_int32_t len)
-{
-	return 0;
-}
-#endif /* WLAN_FEATURE_MEMDUMP */
 
 u_int8_t *wma_add_p2p_ie(u_int8_t *frm)
 {
@@ -6821,12 +6736,6 @@ VOS_STATUS WDA_open(v_VOID_t *vos_context, v_VOID_t *os_ctx,
 	wma_register_ll_stats_event_handler(wma_handle);
 
 #endif /* WLAN_FEATURE_LINK_LAYER_STATS */
-	/* Register event handler to receive firmware mem dump
-	 * copy complete indication
-	 */
-	wmi_unified_register_event_handler(wma_handle->wmi_handle,
-		WMI_UPDATE_FW_MEM_DUMP_EVENTID,
-		wma_fw_mem_dump_event_handler);
 
 	wmi_set_tgt_assert(wma_handle->wmi_handle,
 			   mac_params->force_target_assert_enabled);
@@ -26941,111 +26850,6 @@ VOS_STATUS wma_config_guard_time(tp_wma_handle wma,
 	return ret;
 }
 
-#ifdef WLAN_FEATURE_MEMDUMP
-/*
- * wma_process_fw_mem_dump_req() - Function to request fw memory dump from
- *				   firmware
- * @wma:                Pointer to WMA handle
- * @mem_dump_req:       Pointer for mem_dump_req
- *
- * This function sends memory dump request to firmware
- *
- * Return: VOS_STATUS_SUCCESS for success otherwise failure
- *
- */
-static VOS_STATUS wma_process_fw_mem_dump_req(tp_wma_handle wma,
-					struct fw_dump_req* mem_dump_req)
-{
-	wmi_get_fw_mem_dump_fixed_param *cmd;
-	wmi_fw_mem_dump *dump_params;
-	struct fw_dump_seg_req *seg_req;
-	int32_t len;
-	wmi_buf_t buf;
-	u_int8_t *buf_ptr;
-	int ret, loop;
-
-	if (!mem_dump_req || !wma) {
-		WMA_LOGE(FL("input pointer is NULL"));
-		return VOS_STATUS_E_FAILURE;
-	}
-
-	/*
-	 * len = sizeof(fixed param) that includes tlv header +
-	 *       tlv header for array of struc +
-	 *       sizeof (each struct)
-	 */
-	len = sizeof(*cmd) + WMI_TLV_HDR_SIZE;
-	len += mem_dump_req->num_seg * sizeof(wmi_fw_mem_dump);
-	buf = wmi_buf_alloc(wma->wmi_handle, len);
-
-	if (!buf) {
-		WMA_LOGE(FL("Failed allocate wmi buffer"));
-		return VOS_STATUS_E_NOMEM;
-        }
-
-	buf_ptr = (u_int8_t *) wmi_buf_data(buf);
-	vos_mem_zero(buf_ptr, len);
-	cmd = (wmi_get_fw_mem_dump_fixed_param *) buf_ptr;
-
-	WMITLV_SET_HDR(&cmd->tlv_header,
-		WMITLV_TAG_STRUC_wmi_get_fw_mem_dump_fixed_param,
-		WMITLV_GET_STRUCT_TLVLEN(wmi_get_fw_mem_dump_fixed_param));
-
-	cmd->request_id = mem_dump_req->request_id;
-	cmd->num_fw_mem_dump_segs = mem_dump_req->num_seg;
-
-	/* TLV indicating array of structures to follow */
-	buf_ptr += sizeof(wmi_get_fw_mem_dump_fixed_param);
-	WMITLV_SET_HDR(buf_ptr, WMITLV_TAG_ARRAY_STRUC,
-		       sizeof(wmi_fw_mem_dump) *
-		       cmd->num_fw_mem_dump_segs);
-
-	buf_ptr += WMI_TLV_HDR_SIZE;
-	dump_params = (wmi_fw_mem_dump *) buf_ptr;
-
-	WMA_LOGI(FL("request_id:%d num_seg:%d"),
-		    mem_dump_req->request_id, mem_dump_req->num_seg);
-	for (loop = 0; loop < cmd->num_fw_mem_dump_segs; loop++) {
-		seg_req = (struct fw_dump_seg_req *)
-			  ((uint8_t *)(mem_dump_req->segment) +
-			    loop * sizeof(*seg_req));
-		WMITLV_SET_HDR(&dump_params->tlv_header,
-			    WMITLV_TAG_STRUC_wmi_fw_mem_dump_params,
-			    WMITLV_GET_STRUCT_TLVLEN(wmi_fw_mem_dump));
-		dump_params->seg_id = seg_req->seg_id;
-		dump_params->seg_start_addr_lo = seg_req-> seg_start_addr_lo;
-		dump_params->seg_start_addr_hi = seg_req->seg_start_addr_hi;
-		dump_params->seg_length = seg_req->seg_length;
-		dump_params->dest_addr_lo = seg_req->dst_addr_lo;
-		dump_params->dest_addr_hi = seg_req->dst_addr_hi;
-		WMA_LOGI(FL("seg_number:%d"), loop);
-		WMA_LOGI(FL("seg_id:%d start_addr_lo:0x%x start_addr_hi:0x%x"),
-			 dump_params->seg_id, dump_params->seg_start_addr_lo,
-			 dump_params->seg_start_addr_hi);
-		WMA_LOGI(FL("seg_length:%d dst_addr_lo:0x%x dst_addr_hi:0x%x"),
-			 dump_params->seg_length, dump_params->dest_addr_lo,
-			 dump_params->dest_addr_hi);
-		dump_params++;
-	}
-
-	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
-				   WMI_GET_FW_MEM_DUMP_CMDID);
-        if (ret) {
-		WMA_LOGE(FL("Failed to send get firmware mem dump request"));
-		wmi_buf_free(buf);
-		return VOS_STATUS_E_FAILURE;
-        }
-
-	WMA_LOGI(FL("Get firmware mem dump request sent successfully"));
-	return VOS_STATUS_SUCCESS;
-}
-#else
-static VOS_STATUS wma_process_fw_mem_dump_req(tp_wma_handle wma,
-                                        void *mem_dump_req)
-{
-	return VOS_STATUS_SUCCESS;
-}
-#endif /* WLAN_FEATURE_MEMDUMP */
 
 /*
  * wma_process_set_ie_info() - Function to send IE info to firmware
@@ -28385,11 +28189,6 @@ VOS_STATUS wma_mc_process_msg(v_VOID_t *vos_context, vos_msg_t *msg)
 				(struct sir_guard_time_request *)msg->bodyptr);
 			vos_mem_free(msg->bodyptr);
 			break;
-		case WDA_FW_MEM_DUMP_REQ:
-			wma_process_fw_mem_dump_req(wma_handle,
-				(struct fw_dump_req*)msg->bodyptr);
-			vos_mem_free(msg->bodyptr);
-                        break;
 		case SIR_HAL_START_STOP_LOGGING:
 			wma_set_wifi_start_packet_stats(wma_handle,
 				(struct sir_wifi_start_log *)msg->bodyptr);
diff --git a/CORE/SME/inc/smeInternal.h b/CORE/SME/inc/smeInternal.h
index fd5ac88..e34a1a5 100644
--- a/CORE/SME/inc/smeInternal.h
+++ b/CORE/SME/inc/smeInternal.h
@@ -219,9 +219,6 @@ typedef struct tagSmeStruct
     ocb_callback dcc_update_ndl_callback;
     void *dcc_stats_event_context;
     ocb_callback dcc_stats_event_callback;
-#ifdef WLAN_FEATURE_MEMDUMP
-    void (*fw_dump_callback)(void *context, struct fw_dump_rsp *rsp);
-#endif
     void (*set_thermal_level_cb)(void *hdd_context, uint8_t level);
 
     void (*rssi_threshold_breached_cb)(void *, struct rssi_breach_event *);
diff --git a/CORE/SME/inc/sme_Api.h b/CORE/SME/inc/sme_Api.h
index 1815810..ec8442f 100644
--- a/CORE/SME/inc/sme_Api.h
+++ b/CORE/SME/inc/sme_Api.h
@@ -4145,11 +4145,6 @@ eHalStatus sme_SetLinkLayerStatsIndCB
 
 #endif /* WLAN_FEATURE_LINK_LAYER_STATS */
 
-eHalStatus sme_fw_mem_dump(tHalHandle hHal, void *recvd_req);
-eHalStatus sme_fw_mem_dump_register_cb(tHalHandle hHal,
-    void (*callback_routine)(void *cb_context, struct fw_dump_rsp *rsp));
-eHalStatus sme_fw_mem_dump_unregister_cb(tHalHandle hHal);
-
 #ifdef WLAN_FEATURE_ROAM_OFFLOAD
 /*--------------------------------------------------------------------------
   \brief sme_UpdateRoamOffloadEnabled() - enable/disable roam offload feature
diff --git a/CORE/SME/src/sme_common/sme_Api.c b/CORE/SME/src/sme_common/sme_Api.c
index ddf94cd..3db8097 100644
--- a/CORE/SME/src/sme_common/sme_Api.c
+++ b/CORE/SME/src/sme_common/sme_Api.c
@@ -77,7 +77,6 @@
 extern tSirRetStatus uMacPostCtrlMsg(void* pSirGlobal, tSirMbMsg* pMb);
 
 #define LOG_SIZE 256
-#define READ_MEMORY_DUMP_CMD     9
 #define TL_INIT_STATE            0
 
 static tSelfRecoveryStats gSelfRecoveryStats;
@@ -2481,31 +2480,6 @@ eHalStatus sme_SetEseBeaconRequest(tHalHandle hHal, const tANI_U8 sessionId,
 }
 
 #endif /* FEATURE_WLAN_ESE && FEATURE_WLAN_ESE_UPLOAD */
-
-/**
- * sme_process_fw_mem_dump_rsp - process fw memory dump response from WMA
- *
- * @pMac - pointer to MAC handle.
- * @pMsg - pointer to received SME msg.
- *
- * This function process the received SME message and calls the corresponding
- * callback which was already registered with SME.
- */
-#ifdef WLAN_FEATURE_MEMDUMP
-static void sme_process_fw_mem_dump_rsp(tpAniSirGlobal pMac, vos_msg_t* pMsg)
-{
-	if (pMsg->bodyptr) {
-		if (pMac->sme.fw_dump_callback)
-			pMac->sme.fw_dump_callback(pMac->hHdd,
-				(struct fw_dump_rsp*) pMsg->bodyptr);
-		vos_mem_free(pMsg->bodyptr);
-	}
-}
-#else
-static void sme_process_fw_mem_dump_rsp(tpAniSirGlobal pMac, vos_msg_t* pMsg)
-{
-}
-#endif
 eHalStatus sme_IbssPeerInfoResponseHandleer( tHalHandle hHal,
                                       tpSirIbssGetPeerInfoRspParams pIbssPeerInfoParams)
 {
@@ -3191,9 +3165,6 @@ eHalStatus sme_ProcessMsg(tHalHandle hHal, vos_msg_t* pMsg)
                }
                vos_mem_free(pMsg->bodyptr);
                break;
-          case eWNI_SME_FW_DUMP_IND:
-               sme_process_fw_mem_dump_rsp(pMac, pMsg);
-               break;
           case eWNI_SME_SET_THERMAL_LEVEL_IND:
                if (pMac->sme.set_thermal_level_cb)
                {
@@ -16047,76 +16018,6 @@ eHalStatus sme_SetLinkLayerStatsIndCB
 
 #endif /* WLAN_FEATURE_LINK_LAYER_STATS */
 
-/**
- * sme_fw_mem_dump_register_cb() - Register fw memory dump callback
- *
- * @hHal - MAC global handle
- * @callback_routine - callback routine from HDD
- *
- * This API is invoked by HDD to register its callback in SME
- *
- * Return: eHalStatus
- */
-#ifdef WLAN_FEATURE_MEMDUMP
-eHalStatus sme_fw_mem_dump_register_cb(tHalHandle hal,
-		void (*callback_routine)(void *cb_context,
-					 struct fw_dump_rsp *rsp))
-{
-	eHalStatus status = eHAL_STATUS_SUCCESS;
-	tpAniSirGlobal pmac = PMAC_STRUCT(hal);
-
-	status = sme_AcquireGlobalLock(&pmac->sme);
-	if (eHAL_STATUS_SUCCESS == status) {
-		pmac->sme.fw_dump_callback = callback_routine;
-		sme_ReleaseGlobalLock(&pmac->sme);
-	} else {
-		VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
-			  FL("sme_AcquireGlobalLock error"));
-	}
-
-	return status;
-}
-#else
-eHalStatus sme_fw_mem_dump_register_cb(tHalHandle hal,
-		void (*callback_routine)(void *cb_context,
-					 struct fw_dump_rsp *rsp))
-{
-	return eHAL_STATUS_SUCCESS;
-}
-#endif /* WLAN_FEATURE_MEMDUMP */
-
-/**
- * sme_fw_mem_dump_unregister_cb() - Unregister fw memory dump callback
- *
- * @hHal - MAC global handle
- *
- * This API is invoked by HDD to unregister its callback in SME
- *
- * Return: eHalStatus
- */
-#ifdef WLAN_FEATURE_MEMDUMP
-eHalStatus sme_fw_mem_dump_unregister_cb(tHalHandle hal)
-{
-	eHalStatus status;
-	tpAniSirGlobal pmac = PMAC_STRUCT(hal);
-
-	status = sme_AcquireGlobalLock(&pmac->sme);
-	if (eHAL_STATUS_SUCCESS == status) {
-		pmac->sme.fw_dump_callback = NULL;
-		sme_ReleaseGlobalLock(&pmac->sme);
-	} else {
-		VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
-			  FL("sme_AcquireGlobalLock error"));
-	}
-
-	return status;
-}
-#else
-eHalStatus sme_fw_mem_dump_unregister_cb(tHalHandle hal)
-{
-	return eHAL_STATUS_SUCCESS;
-}
-#endif /* WLAN_FEATURE_MEMDUMP */
 
 #ifdef WLAN_FEATURE_ROAM_OFFLOAD
 /*--------------------------------------------------------------------------
@@ -16712,80 +16613,6 @@ VOS_STATUS sme_apfind_set_cmd(struct sme_ap_find_request_req *input)
      return VOS_STATUS_SUCCESS;
 }
 #endif /* WLAN_FEATURE_APFIND */
-/**
- * sme_fw_mem_dump() - Get FW memory dump
- *
- * This API is invoked by HDD to indicate FW to start
- * dumping firmware memory.
- *
- * Return: eHalStatus
- */
-#ifdef WLAN_FEATURE_MEMDUMP
-eHalStatus sme_fw_mem_dump(tHalHandle hHal, void *recvd_req)
-{
-	eHalStatus status = eHAL_STATUS_SUCCESS;
-	VOS_STATUS vos_status = VOS_STATUS_SUCCESS;
-	tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
-	vos_msg_t msg;
-	struct fw_dump_req* send_req;
-	struct fw_dump_seg_req seg_req;
-	int loop;
-
-	send_req = vos_mem_malloc(sizeof(*send_req));
-	if(!send_req) {
-		VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
-			FL("Memory allocation failed for WDA_FW_MEM_DUMP"));
-		return eHAL_STATUS_FAILURE;
-	}
-	vos_mem_copy(send_req, recvd_req, sizeof(*send_req));
-
-	VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_INFO,
-		  FL("request_id:%d num_seg:%d"),
-		  send_req->request_id, send_req->num_seg);
-        VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_INFO,
-		  FL("Segment Information"));
-	for (loop = 0; loop < send_req->num_seg; loop++) {
-		seg_req = send_req->segment[loop];
-		VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_INFO,
-			  FL("seg_number:%d"), loop);
-		VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_INFO,
-			  FL("seg_id:%d start_addr_lo:0x%x start_addr_hi:0x%x"),
-			  seg_req.seg_id, seg_req.seg_start_addr_lo,
-			  seg_req.seg_start_addr_hi);
-		VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_INFO,
-			  FL("seg_length:%d dst_addr_lo:0x%x dst_addr_hi:0x%x"),
-			  seg_req.seg_length, seg_req.dst_addr_lo,
-			  seg_req.dst_addr_hi);
-	}
-
-	if (eHAL_STATUS_SUCCESS == sme_AcquireGlobalLock(&pMac->sme)) {
-		msg.bodyptr = send_req;
-		msg.type = WDA_FW_MEM_DUMP_REQ;
-		msg.reserved = 0;
-
-		vos_status = vos_mq_post_message(VOS_MODULE_ID_WDA, &msg);
-		if (VOS_STATUS_SUCCESS != vos_status) {
-			VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
-				  FL("Not able to post WDA_FW_MEM_DUMP"));
-			vos_mem_free(send_req);
-			status = eHAL_STATUS_FAILURE;
-		}
-		sme_ReleaseGlobalLock(&pMac->sme);
-	} else {
-		VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
-			FL("Failed to acquire SME Global Lock"));
-		vos_mem_free(send_req);
-		status = eHAL_STATUS_FAILURE;
-	}
-
-	return status;
-}
-#else
-eHalStatus sme_fw_mem_dump(tHalHandle hHal, void *recvd_req)
-{
-	return eHAL_STATUS_SUCCESS;
-}
-#endif /* WLAN_FEATURE_MEMDUMP */
 #ifdef FEATURE_WLAN_MCC_TO_SCC_SWITCH
 /*
  * sme_validate_sap_channel_switch() - validate target channel switch w.r.t
diff --git a/CORE/SYS/legacy/src/utils/src/macTrace.c b/CORE/SYS/legacy/src/utils/src/macTrace.c
index 27c20a5..8c7bc0f 100644
--- a/CORE/SYS/legacy/src/utils/src/macTrace.c
+++ b/CORE/SYS/legacy/src/utils/src/macTrace.c
@@ -903,7 +903,6 @@ tANI_U8* macTraceGetWdaMsgString( tANI_U16 wdaMsg )
         CASE_RETURN_STRING(SIR_HAL_SET_MIRACAST);
         CASE_RETURN_STRING(SIR_HAL_CONFIG_STATS_FACTOR);
         CASE_RETURN_STRING(SIR_HAL_CONFIG_GUARD_TIME);
-        CASE_RETURN_STRING(WDA_FW_MEM_DUMP_REQ);
         CASE_RETURN_STRING(SIR_HAL_START_STOP_LOGGING);
         CASE_RETURN_STRING(WDA_TSF_GPIO_PIN);
         CASE_RETURN_STRING(SIR_HAL_FLUSH_LOG_TO_FW);
diff --git a/CORE/WDA/inc/wlan_qct_wda.h b/CORE/WDA/inc/wlan_qct_wda.h
index 0f002ec..ac06cd3 100644
--- a/CORE/WDA/inc/wlan_qct_wda.h
+++ b/CORE/WDA/inc/wlan_qct_wda.h
@@ -1052,7 +1052,6 @@ tSirRetStatus uMacPostCtrlMsg(void* pSirGlobal, tSirMbMsg* pMb);
 #define WDA_UPDATE_Q2Q_IE_IND                 SIR_HAL_UPDATE_Q2Q_IE_IND
 #endif /* FEATURE_AP_MCC_CH_AVOIDANCE */
 
-#define WDA_FW_MEM_DUMP_REQ                   SIR_HAL_FW_MEM_DUMP_REQ
 #define WDA_TSF_GPIO_PIN                      SIR_HAL_TSF_GPIO_PIN_REQ
 #define WDA_SET_RSSI_MONITOR_REQ              SIR_HAL_SET_RSSI_MONITOR_REQ
 
diff --git a/Kbuild b/Kbuild
index 60e5260..fd1c1f8 100644
--- a/Kbuild
+++ b/Kbuild
@@ -105,9 +105,6 @@ ifeq ($(KERNEL_BUILD), 0)
         endif
 
 	ifneq ($(CONFIG_ARCH_MDMFERMIUM), y)
-		#Flag to enable memdump feature
-		CONFIG_WLAN_FEATURE_MEMDUMP := y
-
 		#Flag to enable offload packets feature
 		CONFIG_WLAN_OFFLOAD_PACKETS := y
 	endif
@@ -394,10 +391,6 @@ ifeq ($(CONFIG_WLAN_SYNC_TSF),y)
 HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_tsf.o
 endif
 
-ifeq ($(CONFIG_WLAN_FEATURE_MEMDUMP),y)
-HDD_OBJS += $(HDD_SRC_DIR)/wlan_hdd_memdump.o
-endif
-
 ############ EPPING ############
 EPPING_DIR :=	CORE/EPPING
 EPPING_INC_DIR :=	$(EPPING_DIR)/inc
@@ -1412,10 +1405,6 @@ ifeq ($(CONFIG_STATICALLY_ADD_11P_CHANNELS),y)
 CDEFINES += -DFEATURE_STATICALLY_ADD_11P_CHANNELS
 endif
 
-ifeq ($(CONFIG_WLAN_FEATURE_MEMDUMP),y)
-CDEFINES += -DWLAN_FEATURE_MEMDUMP
-endif
-
 ifeq ($(CONFIG_WLAN_OFFLOAD_PACKETS),y)
 CDEFINES += -DWLAN_FEATURE_OFFLOAD_PACKETS
 endif
diff --git a/Kconfig b/Kconfig
index 2adf384..0f4623a 100644
--- a/Kconfig
+++ b/Kconfig
@@ -49,9 +49,6 @@ config WLAN_SYNC_TSF
 	bool "Enable QCOM sync multi devices tsf feature"
 	default n
 
-config WLAN_FEATURE_MEMDUMP
-	bool "Enable MEMDUMP feature"
-	default n
 
 config WLAN_OFFLOAD_PACKETS
 	bool "Enable offload packets feature"
-- 
cgit v1.1

